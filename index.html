<!DOCTYPE html>

<!-- Maintained version: duplicate helper functions consolidated (el, getLogs). No functional changes. Generated on 2025-10-23 by ChatGPT. -->
<html lang="ja">
<head>
<!-- Quota-safe localStorage shim (compression + graceful fallback).
     Inserts LZW compression and in-memory fallback to avoid QuotaExceededError.
     MIT License (shim code by ChatGPT; LZW algorithm adapted to JS from public-domain references). -->
<script>
(function(){
  // --- Minimal LZW encoder/decoder (sync) ---
  function lzw_encode(s){
    if (s == null) return s;
    var dict = Object.create(null);
    var data = (s + "").split("");
    var out = [];
    var phrase = data[0];
    var currChar;
    var code = 256;
    for (var i = 1; i < data.length; i++) {
      currChar = data[i];
      var combo = phrase + currChar;
      if (dict[combo] != null) {
        phrase = combo;
      } else {
        out.push(phrase.length > 1 ? dict[phrase] : phrase.charCodeAt(0));
        dict[combo] = code;
        code++;
        phrase = currChar;
      }
    }
    out.push(phrase.length > 1 ? dict[phrase] : phrase.charCodeAt(0));
    for (var i = 0; i < out.length; i++) {
      out[i] = String.fromCharCode(out[i]);
    }
    return out.join("");
  }
  function lzw_decode(s){
    if (s == null) return s;
    var dict = Object.create(null);
    var data = (s + "").split("");
    var currChar = data[0];
    var oldPhrase = currChar;
    var out = [currChar];
    var code = 256;
    var phrase;
    for (var i = 1; i < data.length; i++) {
      var currCode = data[i].charCodeAt(0);
      if (currCode < 256) {
        phrase = data[i];
      } else {
        phrase = dict[currCode] ? dict[currCode] : (oldPhrase + currChar);
      }
      out.push(phrase);
      currChar = phrase.charAt(0);
      dict[code] = oldPhrase + currChar;
      code++;
      oldPhrase = phrase;
    }
    return out.join("");
  }

  function compressIfHelpful(str) {
    try {
      if (typeof str !== "string") str = String(str);
      if (str.length < 2048) return {v: str, compressed: false}; // small: skip
      var c = lzw_encode(str);
      if (c.length < str.length) {
        return {v: "LZW:" + c, compressed: true};
      } else {
        return {v: str, compressed: false};
      }
    } catch (e) {
      return {v: str, compressed: false};
    }
  }
  function maybeDecompress(str) {
    if (typeof str !== "string") return str;
    if (str.startsWith("LZW:")) {
      try {
        return lzw_decode(str.slice(4));
      } catch(e) {
        console.warn("[quota-shim] Decompression failed:", e);
        return null;
      }
    }
    return str;
  }

  var rawSet = Storage.prototype.setItem;
  var rawGet = Storage.prototype.getItem;
  var rawRemove = Storage.prototype.removeItem;
  var inMemory = new Map();
  var warned = false;

  function showQuotaWarningOnce() {
    if (warned) return;
    warned = true;
    try {
      alert("保存データが大きすぎるため、ブラウザの保存容量を超えました。\\n"
          + "・可能な限りデータは圧縮保存しました。\\n"
          + "・なお、それでも保存できない分は『一時保存（このタブを閉じると消えます）』に切り替えています。\\n"
          + "・不要なセーブデータを削除するか、エクスポート機能をご利用ください。");
    } catch(_) {}
    console.warn("[quota-shim] Quota exceeded. Using in-memory fallback for this session.");
  }

  Storage.prototype.setItem = function(key, value){
    // Attempt compressed write first (if helpful), then plain as fallback.
    var candidate = compressIfHelpful(value);
    try {
      rawSet.call(this, key, candidate.v);
      return;
    } catch (e1) {
      // If compressed attempt failed with quota, try plain (or vice versa)
      try {
        if (candidate.compressed) {
          rawSet.call(this, key, String(value));
          return;
        } else {
          var c2 = "LZW:" + lzw_encode(String(value));
          rawSet.call(this, key, c2);
          return;
        }
      } catch (e2) {
        // Quota exceeded even after attempts -> in-memory fallback
        if (e2 && (e2.name === "QuotaExceededError" || e2.code === 22 || e2.code === 1014)) {
          inMemory.set(key, String(value));
          showQuotaWarningOnce();
          return;
        }
        // Unknown error: rethrow
        throw e2;
      }
    }
  };

  Storage.prototype.getItem = function(key){
    var v = rawGet.call(this, key);
    if (v != null) {
      var dec = maybeDecompress(v);
      if (dec != null) return dec;
    }
    if (inMemory.has(key)) return inMemory.get(key);
    return null;
  };

  Storage.prototype.removeItem = function(key){
    try { rawRemove.call(this, key); } catch(_) {}
    if (inMemory.has(key)) inMemory.delete(key);
  };

  // Keep a small, visible marker to help users see the patch is active (optional, non-fatal).
  try { if (!rawGet.call(localStorage, "__quota_shim")) rawSet.call(localStorage, "__quota_shim", "1"); } catch(_) {}
})();
</script>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>オセロ暗記トレーナー v17 Clean（重複統合・コーチ無効化）</title>
<style>
  :root { --cell: 56px; --gap: 2px; --left-col: 360px; }
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic UI", "YuGothic", Meiryo, sans-serif; margin: 20px; }
  h1 { font-size: 1.2rem; margin: 0 0 10px; }
  .topbar { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
  .stat { font-size: .9rem; color: #333; background: #f5f7ff; border: 1px solid #e1e6ff; border-radius: 999px; padding: 4px 10px; }

  .grid { display: grid; grid-template-columns: minmax(300px, var(--left-col)) 1fr; gap: 14px; align-items: start; }
  @media (max-width: 900px) { .grid { grid-template-columns: 1fr; } }

  .panel { display: grid; gap: 12px; }
  .card { border: 1px solid #e7e7e7; border-radius: 10px; padding: 10px; background: #fff; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
  .card h2 { margin: 0 0 6px; font-size: 0.96rem; }
  .field { display: grid; gap: 6px; margin-bottom: 8px; }
  .row { display: flex; gap: 8px; align-items: center; }
  .row.wrap { flex-wrap: wrap; }
  label { font-size: 0.95rem; }
  input[type="text"], input[type="number"], textarea, select { width: 100%; font-size: 0.92rem; padding: 6px 8px; border: 1px solid #d6d6d6; border-radius: 6px; }
  input[type="number"] { width: 120px; }
  textarea { min-height: 52px; resize: vertical; }
  button { font-size: 0.90rem; padding: 5px 9px; border: 1px solid #d0d0d0; background: #f7f7f7; border-radius: 8px; cursor: pointer; }
  button.primary { background: #0f62fe; border-color: #0f62fe; color: #fff; }
  button.warn { background: #ffeded; border-color: #ffb3b3; color: #a80000; }

  .muted { color: #666; font-size: 0.9rem; }
  .small { font-size: 0.82rem; color: #666; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Roboto Mono", monospace; }

  /* Board & axes */
  .board-wrap {
    position: relative;
    display: grid; grid-template-columns: var(--axis, auto) repeat(8, var(--cell)) var(--axis, auto);
    grid-template-rows: var(--axis, auto) repeat(8, var(--cell)) var(--axis, auto); gap: var(--gap);
    background: #0a5a2a; padding: 6px 0; border-radius: 12px; box-shadow: 0 2px 12px rgba(0,0,0,0.15); user-select: none;
    overflow: hidden;
    margin-left:auto; margin-right:auto; /* center */
  }
  .axis { display: grid; place-items: center; font-size: 0.80rem; color: #f0f0f0; opacity: 0.95; }
  .axis.top, .axis.bottom { grid-column: 2 / span 8; grid-template-columns: repeat(8, var(--cell)); gap: var(--gap); }
  .axis.left, .axis.right { grid-row: 2 / span 8; grid-template-rows: repeat(8, var(--cell)); gap: var(--gap); }
  .axis.left { grid-column: 1; }
  .axis.right { grid-column: 10; }
  .axis.top { grid-row: 1; }
  .axis.bottom { grid-row: 10; }

  .board { grid-column: 2 / span 8; grid-row: 2 / span 8;
           display: grid; grid-template-columns: repeat(8, var(--cell)); grid-template-rows: repeat(8, var(--cell)); gap: var(--gap); }
  .cell { background: #1e7a3b; border-radius: 6px; position: relative; cursor: pointer; }
  .cell:hover { outline: 2px solid rgba(255,255,255,0.25); }
  .disc { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
          width: 82%; height: 82%; border-radius: 50%; box-shadow: inset 0 2px 6px rgba(0,0,0,0.35), 0 2px 2px rgba(0,0,0,0.25); }
  .disc.black { background: #111; } .disc.white { background: #eee; }

  .hint-on .cell.expected::after {
    content: ""; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    width: 18px; height: 18px; border-radius: 50%; background: rgba(255,255,255,0.7);
  }
  .showCoords .cell::before {
    content: attr(data-coord);
    position: absolute; top: 5px; left: 6px; font-size: 11px; line-height: 1;
    color: rgba(255,255,255,0.85); text-shadow: 0 1px 2px rgba(0,0,0,0.5); pointer-events: none;
  }
  .xmark::after {
    content: "✕"; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    font-size: 32px; color: #ff2d2d; text-shadow: 0 1px 2px rgba(0,0,0,0.5); animation: fadeOut 600ms ease-out forwards; pointer-events: none;
  }
  @keyframes fadeOut { 0%{opacity:1} 100%{opacity:0} }

  .status { font-size: 0.97rem; padding: 8px 10px; background: #f7f7f7; border: 1px solid #e8e8e8; border-radius: 8px; }
  .row-just { display: flex; justify-content: space-between; align-items: center; gap: 8px; }

  /* Pause / Inspect overlay */
  .inspect-bar {
    position: absolute; left: 10px; top: 10px; z-index: 5;
    background: rgba(0,0,0,0.55); color: #fff; padding: 4px 8px; border-radius: 8px; font-size: 0.9rem; display: none;
  }
  .inspect-action {
    position: absolute; right: 10px; top: 10px; z-index: 5; display: none;
  }
  .inspect-action button { background: #0f62fe; color: #fff; border-color: #0f62fe; }

  /* Celebration overlay */
  .celebrate {
    position: absolute; inset: 0; background: rgba(0,0,0,0.45);
    display: none; align-items: center; justify-content: center; z-index: 8;
  }
  .celebrate .content {
    position: relative; background: rgba(255,255,255,0.95); border-radius: 16px; padding: 24px;
    text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.3);
  }
  .celebrate .title { font-size: 1.4rem; font-weight: 700; margin-bottom: 12px; }
  .celebrate .actions { display: flex; gap: 10px; justify-content: center; margin-top: 10px; }
  .confetti { position: absolute; width: 6px; height: 12px; background: hsl(var(--h), 90%, 55%); top: -20px; left: var(--x); opacity: .9; animation: fall 1200ms linear forwards; transform: rotate(var(--r)); }
  @keyframes fall { to { transform: translateY(380px) rotate(calc(var(--r) + 360deg)); opacity: 1; } }

  /* Modal for kifu list */
  .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.4); display: none; align-items: center; justify-content: center; z-index: 20; }
  .modal .window { width: min(1060px, 94vw); max-height: 88vh; background: #fff; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.25); display: grid; grid-template-rows: auto 1fr auto; }
  .modal header { padding: 10px 14px; border-bottom: 1px solid #eee; display: flex; align-items: center; justify-content: space-between; gap: 10px; }
  .modal header h3 { margin: 0; font-size: 1.02rem; }
  .modal .body { padding: 10px 14px; overflow: auto; }
  .modal .footer { padding: 10px 14px; border-top: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; gap: 10px; }

  .klist-controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 8px; }
  /* rename-controls spacing */
  .rename-controls{ display:grid; gap:8px; margin-top:6px; }
  .klist-row { display: grid; grid-template-columns: auto 1fr auto auto auto; gap: 10px; align-items: start; padding: 8px 0; border-bottom: 1px dashed #eee; }
  .kindex { width: 2.5em; text-align: right; color: #444; padding-top: 4px; }
  .kmeta { color: #444; font-size: 0.85rem; }
  .tag { display: inline-block; padding: 2px 6px; border-radius: 999px; border: 1px solid #ccc; margin-left: 6px; }

  /* Toast */
  .toast { position: fixed; left: 50%; transform: translateX(-50%); bottom: 18px; background: rgba(0,0,0,0.8); color: #fff; padding: 8px 12px; border-radius: 8px; font-size: 0.9rem; display: none; z-index: 99; }

  /* --- UI polish for KIFU list --- */
  .klist-row { display: grid; grid-template-columns: 28px 1fr auto auto auto; gap: 10px; align-items: start; padding: 8px 0; border-bottom: 1px dashed #e9e9e9; }
  .kindex { opacity: .6; padding-top: 6px; }
  .kinfo { display: grid; gap: 6px; }
  .kifu-wrap { display: grid; grid-template-columns: 48px 1fr auto; gap: 8px; align-items: center; }
  .kifu-wrap .label { font-size: .86rem; color: #555; text-align: right; }
  .kifu-text { width: 100%; resize: vertical; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; padding: 6px 8px; border-radius: 8px; border: 1px solid #e1e1e1; background: #fafafa; }
  .kifu-text:focus { outline: 2px solid #bcd3ff; background: #fff; }
  .kifu-btns { display: flex; gap: 8px; align-items: center; }
  .switch { display: inline-flex; gap: 6px; align-items: center; user-select: none; }
  .small.muted { color: #666; font-size: .85rem; }
  button.ghost { background: #f4f4f4; border: 1px solid #ddd; }
  button.danger.ghost { color: #b00020; border-color: #f0d0d0; background: #fff5f5; }

  /* --- Notes UI additions (v6.1) --- */
  .note-text { background: #fffdfa; }
  .kifu-wrap .label { opacity: .85; }
  .klist-row .kifu-wrap + .kifu-wrap { margin-top: 6px; }

  /* --- Legal-move click gating & in-board problem number (v6.2+) --- */
  .legal-only .cell { pointer-events: none; cursor: default; }
  .legal-only .cell.legal { pointer-events: auto; cursor: pointer; }
  .cell.legal:hover { outline: 2px solid rgba(255,255,255,0.35); }

  /* 盤面ラベル（問題番号）を左下＆クリック非干渉 */
  .corner-label {
    position: absolute;
    left: 10px; bottom: 10px;
    z-index: 6;
    background: rgba(0,0,0,0.55);
    color: #fff;
    padding: 2px 8px;
    border-radius: 8px;
    font-weight: 700;
    font-variant-numeric: tabular-nums;
    font-size: .95rem;
    display: none;
    pointer-events: none;
  }

  .result-box { text-align: left; margin: 10px 0 8px; }
  .result-box .field { margin: 6px 0; }

  /* 新規大フォルダ行のUI幅調整 */
  .row.wrap #newBigFolderColor { width: auto; flex: 0 0 auto; }
  .row.wrap #addBigFolderBtn  { width: auto; flex: 0 0 auto; }
  .row.wrap #newBigFolderName { flex: 1 1 240px; min-width: 180px; }

  /* v7.1 additions: axis width & compact reorder buttons */
  :root { --axis: 22px; }
  .board-wrap { grid-template-columns: var(--axis) repeat(8, var(--cell)) var(--axis); }
  .axis { font-size: 0.78rem; }
  button.tiny { padding: 2px 6px; font-size: 0.84rem; }

  /* v7.2 Drag&Drop reorder + board centering */
  .reorder-list { display:flex; gap:8px; flex-wrap:wrap; align-items:center; padding:6px; border:1px dashed #ddd; border-radius:8px; background:#fafafa; }
  .reorder-item { padding:3px 10px; border:1px solid #ddd; border-radius:999px; background:#fff; cursor:grab; user-select:none; }
  .reorder-item.dragging { opacity:.6; }
  .reorder-item.drop-before { box-shadow: inset 3px 0 0 #8ab4ff; outline:2px dashed #8ab4ff; outline-offset:-4px; }
  .reorder-item.drop-after  { box-shadow: inset -3px 0 0 #8ab4ff; outline:2px dashed #8ab4ff; outline-offset:-4px; }
  .board-wrap { margin-left:auto; margin-right:auto; }

  /* v7.3: Dock ② and ③ to the right of the board */
  .panel.rightDock { display: grid; grid-template-columns: 1fr minmax(340px, 520px); gap: 14px; align-items: start; }
  .rightDock .dockGrid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; align-items: start; }
  @media (max-width: 1400px){
    .panel.rightDock { grid-template-columns: 1fr; }
    .rightDock .dockGrid { grid-template-columns: 1fr; }
  }
<!-- v21 Calendar readability upgrade -->
<style id="v21-calendar-css">
  :root { --cal-size: 20px; --cal-gap: 5px; }
  .cal-modal .window { width: min(720px, 92vw); }

  .cal-wrap { display: grid; gap: 8px; }
  .cal-grid {
    display: grid;
    grid-template-columns: max-content repeat(7, var(--cal-size));
    align-items: center;
    gap: var(--cal-gap);
    font-size: 12px;
  }

  .cal-week    { color:#6b7280; font-variant-numeric: tabular-nums; text-align:right; padding-right:6px; }
  .cal-weekday { text-align:center; opacity:.75; font-size:11px; }

  .cal-cell {
    width: var(--cal-size); height: var(--cal-size);
    border-radius: 4px; position: relative;
    box-shadow: inset 0 0 0 1px rgba(0,0,0,.04);
  }
  body.theme-dark .cal-week  { color:#9aa1ad; }
  body.theme-dark .cal-cell  { box-shadow: inset 0 0 0 1px rgba(255,255,255,.06); }

  .cal-cell.future { opacity:.35; }
  .cal-cell.today  { outline: 2px solid #10b981; outline-offset: 1px; }
  .cal-cell .freeze-dot{
    position:absolute; left:2px; top:2px; width:6px; height:6px; border-radius:50%;
    background:#38bdf8; box-shadow:0 0 0 1px rgba(0,0,0,.3);
  }

  .cal-month { grid-column: 1 / span 8; margin-top: 6px; font-weight: 600; opacity:.85; }

  /* 既存凡例を少し見やすく */
  .cal-legend { display:flex; align-items:center; gap:6px; flex-wrap:wrap; font-size:12px; }
  .cal-legend .cal-cell { margin-right:2px; }
</style>

<style>
/* ===== v9 addons: heatmap overlay ===== */
.cell .heat{
  position:absolute; inset:0; border-radius:6px; pointer-events:none; display:none;
  z-index: 4;
}

.cell .heat .cnt{
  position:absolute; right:4px; bottom:4px; font-size:11px; color:#fff;
  text-shadow:0 1px 2px rgba(0,0,0,0.7);
  z-index: 5;
}

.board-wrap.heat-on .cell .heat{ display:block;
  z-index: 4;
}

</style>
<style>
/* === Coach feature removed (UI hidden) === */
#coachSel, #coachRow, #coachOverlay, #coachBtn, .coach-btn, .coach-select, .coach-overlay { display: none !important; }
</style>
<!-- ===== v20 Patch: keyboard overlay position (board-left-bottom) & robust buttons ===== -->
<style id="v20-kbd-pos-css">
/* Always anchor the keyboard input overlay to the board's lower-left (not the viewport) */
.kbd-overlay{
  position: absolute;
  left: 10px;
  bottom: 10px;
  z-index: 7;
  background: rgba(0,0,0,0.55);
  color: #fff;
  padding: 2px 6px;
  border-radius: 6px;
  font-variant-numeric: tabular-nums;
  display: none;
  pointer-events: none; /* overlay should never block clicks */
}
</style>
<meta content="オセロ/リバーシの手筋・棋譜を効率よく暗記するためのトレーナー。フォルダ管理、SRS、カレンダー凍結、ショートカット対応。" name="description"/><meta content="#1B5E20" name="theme-color"/><link href="manifest.webmanifest" rel="manifest"/><link href="icon_othello_green-192.png" rel="icon" sizes="192x192" type="image/png"/><link href="icon_othello_green-512.png" rel="icon" sizes="512x512" type="image/png"/><link href="icon_othello_green-192.png" rel="apple-touch-icon"/></head>
<body><noscript>このアプリはJavaScriptが必要です。ブラウザの設定でJavaScriptを有効にしてください。</noscript>
<div class="topbar">
<h1>オセロ暗記トレーナー v7</h1>
<span class="stat">覚えた棋譜（ユニーク）：<b id="uniqueSolved">0</b></span>
</div>
<div class="grid">
<div class="panel">
<div class="card">
<h2>① 大/小フォルダと棋譜入出力</h2>
<div class="field">
<div class="row wrap">
<label>大フォルダ：</label>
<select id="bigFolderSelect"></select>
<button class="warn" id="deleteBigFolderBtn">大フォルダ削除</button>
</div>
<div class="row wrap">
<input id="newBigFolderName" placeholder="新規大フォルダ名（例：虎大量）" type="text"/>
<div aria-label="持色（任意）" class="row" id="newBigFolderColorGroup" role="group" style="gap:10px;">
<label class="small"><input checked="" name="newBigColor" type="radio" value=""/> 指定なし</label>
<label class="small"><input name="newBigColor" type="radio" value="BLACK"/> 黒</label>
<label class="small"><input name="newBigColor" type="radio" value="WHITE"/> 白</label>
</div>
<button id="addBigFolderBtn">作成</button>
</div>
<div class="row wrap">
<button class="ghost tiny" id="toggleBigReorderBtn">大フォルダを並べ替える</button>
</div>
<div class="row wrap">
<div aria-label="大フォルダの順序（ドラッグで並び替え）" class="reorder-list" id="bigReorderList" style="display:none;"></div>
</div>
</div>
<div class="field">
<div class="row wrap">
<label>小フォルダ：</label>
<select id="smallFolderSelect"></select>
<button class="warn" id="deleteSmallFolderBtn">小フォルダ削除</button>
</div>
<div class="row wrap">
<input id="newSmallFolderName" placeholder="新規小フォルダ名（例：FJT）" type="text"/>
<button id="addSmallFolderBtn">作成</button>
</div>
<div class="row wrap">
<button class="ghost tiny" id="toggleSmallReorderBtn">小フォルダを並べ替える</button>
</div>
<div class="row wrap">
<div aria-label="小フォルダの順序（ドラッグで並び替え）" class="reorder-list" id="smallReorderList" style="display:none;"></div>
</div>
</div>
<div class="field">
<label>棋譜入力（1行=1棋譜／複数行ペーストOK）</label>
<textarea class="mono" id="kifuInput" placeholder="例：
f5d6c3d3c4f4c5b3...（区切りなし・大/小文字どちらでも可）
または F5 D6 C3 ... / F5,D6,C3 ...（空白/カンマ区切り）
PASSは P または PASS。"></textarea>
<div class="row wrap">
<button id="addKifuBtn">棋譜を追加</button>
<button class="ghost" id="clearKifuInputBtn">入力クリア</button>
</div>
<div class="small">※ 追加時に重複棋譜は自動スキップ（暗黙パスも考慮して判定）。</div>
</div>
<div class="field row wrap">
<button class="ghost" id="openListBtn">棋譜一覧を開く</button>
</div>
<div class="field row wrap">
<button class="ghost" id="exportBtn">エクスポート（JSON）</button>
<input accept="application/json" id="importFile" style="display:none;" type="file"/>
<button class="ghost" id="importBtn">インポート</button>
<button class="warn" id="initAllBtn">初期化（全データ消去）</button>
</div>
<div class="small muted">※ 初期化はローカルに保存された全データ（大/小フォルダ・棋譜・キュー・統計）を削除し、インポート前の初期状態に戻します。</div>
<div class="small muted">Excel（XLSX/XLSM）からの取り込みは、事前に同梱の「Excel→JSON 変換ツール」で JSON にしてから本ボタンで取り込むのが確実です。</div>
</div>
</div>
<div class="panel rightDock">
<div class="card">
<div class="board-wrap" id="boardWrap">
<div class="inspect-bar" id="inspectBar">確認中</div>
<div class="inspect-action" id="inspectAction"><button id="resumeBtn">暗記再開</button></div>
<div aria-label="問題番号" class="corner-label" id="boardIndexLabel"></div>
<div class="celebrate" id="celebrate">
<div class="content">
<div class="title">暗記成功！</div>
<div class="small muted" id="celebrateMsg"></div>
<div class="result-box" id="resultInfo">
<div class="small muted">問題番号：<span id="resultIndex">—</span></div>
<div class="field">
<label class="small">棋譜</label>
<textarea class="kifu-text" id="resultKifuText" readonly="" rows="2"></textarea>
<div class="row">
<button class="ghost" id="resultCopyBtn">コピー</button>
<span class="small muted" id="resultLen"></span>
</div>
</div>
<div class="field">
<label class="small">コメント</label>
<textarea class="kifu-text note-text" id="resultCommentInput" placeholder="メモや気づき、対策などを自由に" rows="3"></textarea>
</div>
</div>
<div class="actions">
<button class="primary" id="repeatBtn">今の棋譜をもう一度トレーニング</button>
<button id="nextBtn">次の問題に進む</button>
</div>
</div>
</div>
<div class="axis top" id="topAxis"></div>
<div class="axis left" id="leftAxis"></div>
<div aria-label="オセロ盤（A-H/1-8）" class="board" id="board"></div>
<div class="axis right" id="rightAxis"></div>
<div class="axis bottom" id="bottomAxis"></div>
</div>
<div class="row-just">
<div class="small">座標：左→右 A–H、上→下 1–8（左上=A1）</div>
</div>
</div>
<div class="dockGrid">
<div class="card">
<h2>② トレーニング設定</h2>
<div class="field row">
<label>自分の色：</label>
<label><input checked="" name="myColor" type="radio" value="BLACK"/> 黒（先手）</label>
<label><input name="myColor" type="radio" value="WHITE"/> 白（後手）</label>
</div>
<div class="field row wrap">
<label>出題モード：</label>
<select id="pickMode">
<option selected="" value="RANDOM">ランダム（出題オンのみ）</option>
<option value="NUMBER">番号指定（表示順）</option>
<option value="NUMBER_ENABLED">番号指定（出題オンに限定）</option>
<option value="QUEUE">キュー順（この小フォルダ）</option>
<option value="HARD">誤答が多い順（出題オンのみ）</option>
<option value="UNSOLVED">未クリアのみ（出題オンのみ）</option>
</select>
<input id="kifuNumberInput" min="1" placeholder="番号（1〜）" title="番号指定時のみ使用" type="number"/>
</div>
<div class="field row wrap">
<label for="startIndexInput">Start index（開始手）：</label>
<input id="startIndexInput" max="60" min="1" placeholder="例：30" type="number"/>
<label for="endIndexInput">End index（終了手）：</label>
<input id="endIndexInput" max="60" min="1" placeholder="例：60" type="number"/>
</div>
<div class="field row wrap">
<label><input id="toggleHint" type="checkbox"/> 期待手をハイライト</label>
<label><input id="toggleMiniCoord" type="checkbox"/> マス内に座標表示</label>
<label><input checked="" id="toggleSound" type="checkbox"/> 効果音</label>
</div>
<div class="field row wrap">
<label><input id="toggleSelfBoth" type="checkbox"/> 両方を自分で打つ（AIは打たない）</label>
<span class="small muted">※オンの間は「自分の色」は無視されます。</span>
</div>
<div class="row wrap">
<button class="primary" id="startBtn">トレーニング開始</button>
<button id="resetBtn">盤面リセット</button>
</div>
<div class="status" id="status">大/小フォルダを選び、棋譜を登録して開始してください。</div>
<div class="small">
          範囲進行：<span id="progress">0 / 0</span> 手 |
          現在：<span id="pathView">—</span> |
          出題オン：<span id="enabledCount">0</span>件 |
          キュー：<span id="queueCount">0</span>件 |
          誤答：<span id="mistakesNow">0</span>回
        </div>
</div>
<div class="card">
<h2>③ キュー &amp; クリアリスト</h2>
<div class="field">
<div class="row wrap">
<button class="ghost" id="clearQueueBtn">キューをクリア（この小フォルダ）</button>
<button class="ghost" id="peekQueueBtn">キュー先頭を確認</button>
</div>
<div class="small" id="queueView" style="display:flex;gap:6px;flex-wrap:wrap;"></div>
</div>
<div class="field">
<div><b>クリアリスト（この小フォルダ）</b></div>
<div class="small" id="solvedList"></div>
</div>
</div>
</div>
</div>
</div>
<!-- Modal (棋譜一覧 兼 編集・検索) -->
<div class="modal" id="kifuModal">
<div class="window">
<header>
<h3>棋譜一覧（<span id="modalPathName">—</span>）</h3>
<div class="klist-controls">
<label>並び替え：</label>
<select id="sortBy">
<option selected="" value="INDEX">表示順（追加順）</option>
<option value="NAME">名前</option>
<option value="LEN">手数</option>
<option value="SOLVED">クリア回数</option>
<option value="MISTAKES">誤答回数</option>
</select>
<select id="sortDir">
<option selected="" value="ASC">昇順</option>
<option value="DESC">降順</option>
</select>
<input id="searchInput" placeholder="棋譜／備考／名前で検索（空白区切りAND）" style="min-width:280px;" type="text"/>
<button class="ghost" id="clearSearchBtn">初期設定</button>
</div>
<div class="rename-controls">
<div class="row wrap" id="renameBigRow">
<label>大フォルダ名：</label>
<input id="renameBigInput" placeholder="大フォルダ名を編集" type="text"/>
<button class="ghost" id="renameBigSaveBtn">保存</button>
</div>
<div class="row wrap" id="renameSmallRow">
<label>小フォルダ名：</label>
<input id="renameSmallInput" placeholder="小フォルダ名を編集" type="text"/>
<button class="ghost" id="renameSmallSaveBtn">保存</button>
</div>
</div>
<button class="ghost" id="closeModalBtn">閉じる</button>
</header>
<div class="body">
<div class="field" id="kifuList"></div>
</div>
<div class="footer">
<div class="small">出題オン：<span id="enabledCountModal">0</span>件</div>
<div class="row">
<button class="ghost" id="clearStatsBtn">統計をリセット（この小フォルダ）</button>
</div>
</div>
</div>
</div>
<div class="toast" id="toast"></div>
<script>
// Patched on 2025-10-18: stable '追加順' numbers across sorts (list & board & result panel).
/* ====== Compact layout: fit board to viewport (no vertical scroll) ====== */
function fitBoardToViewport(){
  try{
    const topbar = document.querySelector('.topbar');
    const topH = topbar ? topbar.getBoundingClientRect().height : 0;
    const reserved = 54; // margins, card shadows etc.
    const vh = window.innerHeight;
    const cell = Math.max(34, Math.min(56, Math.floor((vh - topH - reserved) / 10)));
    document.documentElement.style.setProperty('--cell', cell + 'px');
  }catch(e){ /* ignore */ }
}
window.addEventListener('resize', fitBoardToViewport);
document.addEventListener('DOMContentLoaded', fitBoardToViewport);

/* ====== ルール基盤 ====== */
const EMPTY=0, BLACK=1, WHITE=-1;
const DIRS=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
const COLS="ABCDEFGH".split("");
const ROWS=[1,2,3,4,5,6,7,8];
function inBounds(r,c){ return r>=0 && r<8 && c>=0 && c<8; }
function toCoord(r,c){ return COLS[c] + (r+1); }
function coordToRC(coord){
  const m = String(coord).trim().toUpperCase().match(/^([A-H])\s*([1-8])$/);
  if(!m) return null;
  const c = COLS.indexOf(m[1]);
  const r = parseInt(m[2],10)-1;
  return [r,c];
}
function newBoard(){
  const b = Array.from({length:8},()=>Array(8).fill(EMPTY));
  b[3][3]=WHITE; b[4][4]=WHITE; b[3][4]=BLACK; b[4][3]=BLACK;
  return b;
}
function findFlips(b, r, c, player) {
  if (b[r][c] !== EMPTY) return [];
  const flips = [];
  for (const [dr, dc] of DIRS) {
    let i = r + dr, j = c + dc, tmp = [];
    while (inBounds(i,j) && b[i][j] === -player) { tmp.push([i,j]); i += dr; j += dc; }
    if (tmp.length && inBounds(i,j) && b[i][j] === player) flips.push(...tmp);
  }
  return flips;
}
function legalMoves(b, player) {
  const moves=[];
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    const flips = findFlips(b,r,c,player);
    if(flips.length) moves.push({ r, c, flips });
  }
  return moves;
}
function applyMove(b, move, player){
  b[move.r][move.c]=player;
  for(const [r,c] of move.flips) b[r][c]=player;
}

/* ====== ストア v6 ====== */
const FILE_BASENAME = (location && location.pathname ? location.pathname.split('/').pop() : 'index.html');
const STORE_PREFIX = "reversi_trainer_" + FILE_BASENAME + "_";
const STORE_KEY_V6 = STORE_PREFIX + "store_v6";
const LEGACY_KEYS = [STORE_PREFIX + "store_v5", STORE_PREFIX + "store_v4", STORE_PREFIX + "store_v3", STORE_PREFIX + "store_v2", STORE_PREFIX + "store_v1"];
function pathKey(big, small){ return big + "/" + (small || "__ROOT__"); }
function defaultStore(){
  return {
    version:6,
    bigFolders:[],
    smallByBig:{},
    kifuByPath:{},
    queueByPath:{},
    learnedOnceIds: []
  };
}
function loadStore(){
  const raw = localStorage.getItem(STORE_KEY_V6);
  if(raw){ try{ return JSON.parse(raw); }catch(e){ console.warn(e); } }
  for(const key of LEGACY_KEYS){
    const rk = localStorage.getItem(key);
    if(!rk) continue;
    try{
      const old = JSON.parse(rk);
      let store = defaultStore();
      store.bigFolders=[]; store.smallByBig={}; store.kifuByPath={}; store.queueByPath={}; store.learnedOnceIds = old.learnedOnceIds || [];
      if(old.folders && old.kifuByFolder){
        for(const f of old.folders){
          store.bigFolders.push({ name: f, defaultColor: "" });
          store.smallByBig[f] = [];
          const p = pathKey(f, null);
          store.kifuByPath[p] = (old.kifuByFolder[f]||[]).map(k=>({ ...k, sig: k.sig || canonicalSignature(k.moves||[]) }));
          store.queueByPath[p] = (old.queueByFolder?.[f]||[]);
        }
      }else if(old.bigFolders && old.kifuByPath){
        store = old; store.version=6;
      }
      saveStore(store); alert("旧データをv6形式に移行しました。"); return store;
    }catch(e){ console.warn("migration failed", e); }
  }
  const d = defaultStore(); saveStore(d); return d;
}
function saveStore(obj){ localStorage.setItem(STORE_KEY_V6, JSON.stringify(obj)); }
let store = loadStore();

/* ====== UI参照 ====== */
const uniqueSolvedEl = document.getElementById('uniqueSolved');

const boardWrap = document.getElementById('boardWrap');
const boardEl = document.getElementById('board');
const topAxis = document.getElementById('topAxis');
const bottomAxis = document.getElementById('bottomAxis');
const leftAxis = document.getElementById('leftAxis');
const rightAxis = document.getElementById('rightAxis');

const bigFolderSelect = document.getElementById('bigFolderSelect');
const newBigFolderName = document.getElementById('newBigFolderName');
const newBigFolderColor = document.getElementById('newBigFolderColor');
const addBigFolderBtn = document.getElementById('addBigFolderBtn');
const deleteBigFolderBtn = document.getElementById('deleteBigFolderBtn');

const smallFolderSelect = document.getElementById('smallFolderSelect');
const newSmallFolderName = document.getElementById('newSmallFolderName');
const addSmallFolderBtn = document.getElementById('addSmallFolderBtn');
const deleteSmallFolderBtn = document.getElementById('deleteSmallFolderBtn');

const bigReorderList = document.getElementById('bigReorderList');
const smallReorderList = document.getElementById('smallReorderList');

const bigUpBtn = document.getElementById('bigUpBtn');
const bigDownBtn = document.getElementById('bigDownBtn');
const bigTopBtn = document.getElementById('bigTopBtn');
const bigBottomBtn = document.getElementById('bigBottomBtn');
const smallUpBtn = document.getElementById('smallUpBtn');
const smallDownBtn = document.getElementById('smallDownBtn');
const smallTopBtn = document.getElementById('smallTopBtn');
const smallBottomBtn = document.getElementById('smallBottomBtn');

const openListBtn = document.getElementById('openListBtn');

const kifuInput = document.getElementById('kifuInput');
const addKifuBtn = document.getElementById('addKifuBtn');
const clearKifuInputBtn = document.getElementById('clearKifuInputBtn');

const startBtn = document.getElementById('startBtn');
const resetBtn = document.getElementById('resetBtn');
const statusEl = document.getElementById('status');
const progressEl = document.getElementById('progress');
const pathViewEl = document.getElementById('pathView');
const enabledCountEl = document.getElementById('enabledCount');
const queueCountEl = document.getElementById('queueCount');
const mistakesNowEl = document.getElementById('mistakesNow');
const toggleHintEl = document.getElementById('toggleHint');
const toggleMiniCoordEl = document.getElementById('toggleMiniCoord');
const toggleSoundEl = document.getElementById('toggleSound');

const pickModeEl = document.getElementById('pickMode');
const kifuNumberInput = document.getElementById('kifuNumberInput');
const startIndexInput = document.getElementById('startIndexInput');
const endIndexInput = document.getElementById('endIndexInput');

const exportBtn = document.getElementById('exportBtn');
const importBtn = document.getElementById('importBtn');
const importFile = document.getElementById('importFile');
const initAllBtn = document.getElementById('initAllBtn');

const clearQueueBtn = document.getElementById('clearQueueBtn');
const peekQueueBtn = document.getElementById('peekQueueBtn');
const queueView = document.getElementById('queueView');
const solvedListEl = document.getElementById('solvedList');

const kifuModal = document.getElementById('kifuModal');
const modalPathName = document.getElementById('modalPathName');
const kifuList = document.getElementById('kifuList');
const closeModalBtn = document.getElementById('closeModalBtn');
const sortByEl = document.getElementById('sortBy');
const sortDirEl = document.getElementById('sortDir');
const searchInput = document.getElementById('searchInput');
const clearSearchBtn = document.getElementById('clearSearchBtn');
const enabledCountModalEl = document.getElementById('enabledCountModal');

const renameBigInput = document.getElementById('renameBigInput');
const renameSmallInput = document.getElementById('renameSmallInput');
const renameBigSaveBtn = document.getElementById('renameBigSaveBtn');
const renameSmallSaveBtn = document.getElementById('renameSmallSaveBtn');
const renameSmallRow = document.getElementById('renameSmallRow');


const inspectBar = document.getElementById('inspectBar');
const inspectAction = document.getElementById('inspectAction');
const resumeBtn = document.getElementById('resumeBtn');

const celebrateLayer = document.getElementById('celebrate');
const celebrateMsg = document.getElementById('celebrateMsg');
const repeatBtn = document.getElementById('repeatBtn');
const nextBtn = document.getElementById('nextBtn');

const toastEl = document.getElementById('toast');
const boardIndexLabel = document.getElementById('boardIndexLabel');
const resultIndexEl = document.getElementById('resultIndex');
const resultKifuText = document.getElementById('resultKifuText');
const resultCopyBtn = document.getElementById('resultCopyBtn');
const resultCommentInput = document.getElementById('resultCommentInput');
const resultLenEl = document.getElementById('resultLen');

const toggleSelfBothEl = document.getElementById('toggleSelfBoth');
const myColorRadios = document.querySelectorAll('input[name="myColor"]');

/* ====== 状態 ====== */
let board = newBoard(), currentPlayer = BLACK;
let expectedMoves = [];
let rangeStart = 1, rangeEnd = 0;
let moveIndex = 0;
let myColor = BLACK;
let training = false;
let sessionMistakes = 0;
let currentKifuId = null;
let inspectMode = false;
let inspectIndex = 0;
let selfBothMode = false;

/* ====== 盤描画 ====== */
function renderAxes(){
  topAxis.innerHTML=""; bottomAxis.innerHTML="";
  COLS.forEach(ch => { const d=document.createElement('div'); d.textContent=ch; topAxis.appendChild(d); });
  COLS.forEach(ch => { const d=document.createElement('div'); d.textContent=ch; bottomAxis.appendChild(d); });
  leftAxis.innerHTML=""; rightAxis.innerHTML="";
  ROWS.forEach(n => { const d=document.createElement('div'); d.textContent=n; leftAxis.appendChild(d); });
  ROWS.forEach(n => { const d=document.createElement('div'); d.textContent=n; rightAxis.appendChild(d); });
}
function rcFromIndex(i){ return [Math.floor(i/8), i%8]; }
function ensureCells(){
  if(boardEl.children.length) return;
  for(let i=0;i<64;i++){
    const cell=document.createElement('div');
    const [r,c]=rcFromIndex(i);
    cell.className='cell';
    cell.dataset.r=r; cell.dataset.c=c;
    cell.dataset.coord = COLS[c] + (r+1);
    cell.title = cell.dataset.coord;
    cell.addEventListener('click', onCellClick);
    boardEl.appendChild(cell);
  }
}
function renderBoard(){
  ensureCells();
  for(let i=0;i<64;i++){ boardEl.children[i].classList.remove('expected'); }
  if(training && toggleHintEl.checked && expectedMoves.length>0 && moveIndex < expectedMoves.length && moveIndex < rangeEnd){
    const token = nextTokenSkippingImplicitPasses(moveIndex, board, currentPlayer);
    if(token && token!=="P" && token!=="PASS"){
      const rc = coordToRC(token);
      if(rc){ const idx = rc[0]*8 + rc[1]; boardEl.children[idx].classList.add('expected'); }
    }
  }
  for(let i=0;i<64;i++){
    const cell=boardEl.children[i];
    const r=parseInt(cell.dataset.r,10), c=parseInt(cell.dataset.c,10);
    cell.innerHTML="";
    const v=board[r][c];
    if(v!==EMPTY){
      const d=document.createElement('div'); d.className='disc ' + (v===BLACK?'black':'white'); cell.appendChild(d);
    }
  }
  boardWrap.classList.toggle('showCoords', toggleMiniCoordEl.checked);
  boardWrap.classList.toggle('hint-on', toggleHintEl.checked);
  updateLegalClickable();
  maybeAutoPassPlayer();
  inspectBar.style.display = inspectMode ? 'inline-block' : 'none';
  inspectAction.style.display = inspectMode ? 'inline-block' : 'none';
  updateBoardIndexLabel();
}

/* --- v6.2+ helpers --- */
function maybeAutoPassPlayer(){
  if(!training || inspectMode) return;
  if(!selfBothMode && currentPlayer !== myColor) return;

  const LM = legalMoves(board, currentPlayer);
  if(LM.length > 0) return;

  const token = expectedMoves[moveIndex];
  if(token === "P" || token === "PASS"){
    currentPlayer = -currentPlayer; 
    moveIndex++; 
    setProgress();
  }else{
    currentPlayer = -currentPlayer;
  }
  setTimeout(()=>{ renderBoard(); stepIfAIShouldPlay(); }, 0);
}

function updateLegalClickable(){
  ensureCells();
  for(let i=0;i<64;i++){ boardEl.children[i].classList.remove('legal'); }
  if(training && (selfBothMode || currentPlayer === myColor)){
    const LM = legalMoves(board, currentPlayer);
    LM.forEach(m => {
      const idx = m.r*8 + m.c;
      boardEl.children[idx].classList.add('legal');
    });
    boardWrap.classList.add('legal-only');
  }else{
    boardWrap.classList.remove('legal-only');
  }
}
function updateBoardIndexLabel(){
  if(!training || !currentKifuId){ boardIndexLabel.style.display='none'; return; }
  const pk = currentPath();
  const baseArr = store.kifuByPath[pk] || [];
  const k = baseArr.find(x=>x.id===currentKifuId);
  if(!k){ boardIndexLabel.style.display='none'; return; }
  if(typeof k._idx !== 'number'){
    const idx0 = baseArr.findIndex(x=>x.id===k.id);
    if(idx0 >= 0) k._idx = idx0;
  }
  const num = (typeof k._idx === 'number') ? (k._idx + 1) : null;
  if(num != null){
    boardIndexLabel.textContent = String(num);
    boardIndexLabel.style.display = 'inline-block';
  }else{
    boardIndexLabel.style.display = 'none';
  }
}
function populateResultPanel(){
  const pk = currentPath();
  const baseArr = store.kifuByPath[pk] || [];
  const k = baseArr.find(x=>x.id===currentKifuId);
  if(!k) return;
  resultKifuText.value = (k.moves||[]).join(" ");
  resultLenEl.textContent = `（${(k.moves||[]).length}手）`;

  if(typeof k._idx !== 'number'){
    const idx0 = baseArr.findIndex(x=>x.id===k.id);
    if(idx0 >= 0) k._idx = idx0;
  }
  const num = (typeof k._idx === 'number') ? (k._idx + 1) : null;
  resultIndexEl.textContent = (num != null) ? String(num) : "—";

  resultCommentInput.value = k.comment || "";
  resultCommentInput.oninput = function(){
    k.comment = resultCommentInput.value;
    saveStore(store);
  };
  resultCopyBtn.onclick = async function(){
    try{
      await navigator.clipboard.writeText(resultKifuText.value);
      showToast("棋譜をコピーしました");
    }catch(e){
      resultKifuText.focus(); resultKifuText.select();
      const ok = document.execCommand('copy');
      showToast(ok? "棋譜をコピーしました" : "コピーに失敗しました");
    }
  };
}

/* ====== 効果音 ====== */
let audioCtx = null;
function playSound(type){
  if(!toggleSoundEl.checked) return;
  try{
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);
    let freq=880, dur=0.12;
    if(type==="ok"){ freq=880; dur=0.12; }
    else if(type==="ng"){ freq=220; dur=0.25; }
    else if(type==="success"){ freq=660; dur=0.14; setTimeout(()=>{ const o2=audioCtx.createOscillator(); const g2=audioCtx.createGain(); o2.connect(g2); g2.connect(audioCtx.destination); o2.frequency.value=990; o2.type="sine"; g2.gain.setValueAtTime(0.0001, audioCtx.currentTime); g2.gain.exponentialRampToValueAtTime(0.15, audioCtx.currentTime+0.01); o2.start(); o2.stop(audioCtx.currentTime+0.12); }, 160); }
    o.frequency.value=freq; o.type="sine";
    g.gain.setValueAtTime(0.0001, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.18, audioCtx.currentTime+0.01);
    o.start(); o.stop(audioCtx.currentTime+dur);
  }catch(e){ /* ignore */ }
}

/* ====== トークナイズ ====== */
function tokenizeKifuString(line){
  const cleaned = String(line).replace(/[\s,;]+/g, '').toUpperCase();
  if(cleaned.length===0) return [];
  const re = /([A-H][1-8]|P(?:ASS)?)/g;
  const tokens = [];
  let m, acc="";
  while((m=re.exec(cleaned))!==null){ tokens.push(m[1]); acc += m[1]; }
  if(acc !== cleaned){
    const spaced = String(line).replace(/[;,]+/g,' ').trim().split(/\s+/).filter(Boolean).map(s=>s.toUpperCase());
    if(spaced.length && spaced.every(x => /^[A-H][1-8]$/.test(x) || /^P(?:ASS)?$/.test(x))){
      return spaced;
    }
    return null;
  }
  return tokens;
}
function canonicalSignature(moves){
  return (moves||[]).filter(t=>!(t==="P" || t==="PASS")).map(t=>t.toUpperCase()).join('');
}

/* ====== 検証（暗黙パス対応） ====== */
function nextTokenSkippingImplicitPasses(i, b, player){
  let tempB = b.map(row=>row.slice()), p = player, idx = i;
  while(true){
    const LM = legalMoves(tempB, p);
    if(LM.length===0){
      const LM2 = legalMoves(tempB, -p);
      if(LM2.length===0) return null;
      p = -p; continue;
    }
    return expectedMoves[idx] || null;
  }
}
function validateMoves(tokens){
  let b = newBoard();
  let player = BLACK;
  let i = 0;
  let consecutivePasses = 0;
  while(i < tokens.length){
    const token = tokens[i];
    const LMcur = legalMoves(b, player);
    if(token==="P" || token==="PASS"){
      if(LMcur.length>0) return { ok:false, error:`${i+1}手目：PASS指定ですが合法手があります` };
      player = -player; i++; consecutivePasses++;
      if(consecutivePasses>=2){
        return { ok:false, error:`${i}手で終局ですが、余分な手が指定されています` };
      }
      continue;
    }
    if(LMcur.length===0){
      player = -player; consecutivePasses++;
      if(consecutivePasses>=2){ return { ok:false, error:`${i}手で終局ですが、余分な手が指定されています` }; }
      continue;
    }
    consecutivePasses = 0;
    const rc = coordToRC(token);
    const match = legalMoves(b, player).find(m=>m.r===rc[0] && m.c===rc[1]);
    if(!match) return { ok:false, error:`${i+1}手目 ${token} は合法手ではありません` };
    applyMove(b, match, player);
    player = -player; i++;
  }
  return { ok:true };
}

/* ====== 現在のパスなど ====== */
function currentBig(){ return bigFolderSelect.value; }
function currentSmall(){ return smallFolderSelect.value || null; }
function currentPath(){ return pathKey(currentBig(), currentSmall()); }
function ensureBig(big){
  if(!store.bigFolders.find(b=>b.name===big)){
    store.bigFolders.push({ name: big, defaultColor: "" });
  }
  if(!store.smallByBig[big]) store.smallByBig[big]=[];
  if(!store.kifuByPath[pathKey(big,null)]) store.kifuByPath[pathKey(big,null)]=[];
  if(!store.queueByPath[pathKey(big,null)]) store.queueByPath[pathKey(big,null)]=[];
}
function ensureSmall(big, sm){
  ensureBig(big);
  if(sm && !store.smallByBig[big].includes(sm)){
    store.smallByBig[big].push(sm);
  }
  const pk = pathKey(big, sm||null);
  if(!store.kifuByPath[pk]) store.kifuByPath[pk]=[];
  if(!store.queueByPath[pk]) store.queueByPath[pk]=[];
}
function getArrayByPath(pk){ return store.kifuByPath[pk] || []; }
function getQueueByPath(pk){ return store.queueByPath[pk] || []; }

/* ====== Big/Small 選択UI ====== */
function refreshBigSelect(){
  bigFolderSelect.innerHTML="";
  store.bigFolders.forEach(b=>{
    const opt=document.createElement('option'); opt.value=b.name; opt.textContent=b.name + (b.defaultColor?`（持色:${b.defaultColor==='BLACK'?'黒':b.defaultColor==='WHITE'?'白':'—'}）`:"");
    bigFolderSelect.appendChild(opt);
  });
  refreshSmallSelect();
  renderReorderUI();
}
function refreshSmallSelect(){
  const big=currentBig();
  const meta = (store.bigFolders||[]).find(b=>b.name===big);
  if(meta && meta.defaultColor){
    const target = meta.defaultColor === 'WHITE' ? 'WHITE' : 'BLACK';
    const radios = document.querySelectorAll('input[name="myColor"]');
    radios.forEach(r => { r.checked = (r.value===target); });
  }
  const list=store.smallByBig[big]||[];
  smallFolderSelect.innerHTML="";
  list.forEach(s=>{ const o=document.createElement('option'); o.value=s; o.textContent=s; smallFolderSelect.appendChild(o); });
  updateCountsAndPath();
  renderReorderUI();
}
function updateCountsAndPath(){
  const pk = currentPath();
  pathViewEl.textContent = pk;
  updateEnabledCount();
  updateQueueView();
  renderSolvedList();
}

function getNewBigColorValue(){
  const r = document.querySelector('input[name="newBigColor"]:checked');
  if (r) return (r.value || "").trim();
  if (typeof newBigFolderColor !== 'undefined' && newBigFolderColor) {
    return (newBigFolderColor.value || "").trim();
  }
  return "";
}

/* ====== Big/Small 追加・削除 ====== */
function addBigFolder(){
  const name=(newBigFolderName.value||"").trim();
  const color=getNewBigColorValue();
  if(!name){ alert("大フォルダ名を入力してください"); return; }
  if(store.bigFolders.find(b=>b.name===name)){ alert("同名の大フォルダが既にあります"); return; }
  store.bigFolders.push({ name, defaultColor: color });
  ensureBig(name); saveStore(store);
  newBigFolderName.value="";
  const r0 = document.querySelector('input[name="newBigColor"][value=""]');
  if (r0) r0.checked = true;
  if (typeof newBigFolderColor !== 'undefined' && newBigFolderColor) newBigFolderColor.value="";
  refreshBigSelect();
}
function deleteBigFolder(){
  const big=currentBig(); if(!big) return;
  if(!confirm(`大フォルダ「${big}」を削除しますか？（中の小フォルダと棋譜も削除）`)) return;
  const keys = Object.keys(store.kifuByPath);
  keys.forEach(k=>{ if(k.startsWith(big+"/")){ delete store.kifuByPath[k]; delete store.queueByPath[k]; } });
  delete store.smallByBig[big];
  store.bigFolders = store.bigFolders.filter(b=>b.name!==big);
  saveStore(store); refreshBigSelect();
}
function addSmallFolder(){
  const sm=(newSmallFolderName.value||"").trim(); const big=currentBig();
  if(!big){ alert("大フォルダを選択してください"); return; }
  if(!sm){ alert("小フォルダ名を入力してください"); return; }
  ensureSmall(big, sm); saveStore(store); newSmallFolderName.value=""; refreshSmallSelect();
}
function deleteSmallFolder(){
  const big=currentBig(); const sm=currentSmall();
  if(!big || !sm){ alert("削除する小フォルダを選択してください"); return; }
  if(!confirm(`小フォルダ「${sm}」を削除しますか？（中の棋譜も削除）`)) return;
  const pk = currentPath();
  delete store.kifuByPath[pk];
  delete store.queueByPath[pk];
  store.smallByBig[big] = (store.smallByBig[big]||[]).filter(x=>x!==sm);
  saveStore(store); refreshSmallSelect();
}

/* ====== 並び替え（大フォルダ／小フォルダ） ====== */
function arrayMove(arr, from, to){
  if(!Array.isArray(arr)) return false;
  if(from === to) return false;
  if(from < 0 || from >= arr.length) return false;
  if(to < 0 || to >= arr.length) return false;
  const item = arr.splice(from,1)[0];
  arr.splice(to,0,item);
  return true;
}
function reorderBigFolder(kind){
  const prevBig = currentBig();
  if(!prevBig) return;
  const arr = store.bigFolders || [];
  const idx = arr.findIndex(b => b.name === prevBig);
  if(idx < 0) return;
  let to = idx;
  if(kind === 'UP') to = idx - 1;
  if(kind === 'DOWN') to = idx + 1;
  if(kind === 'TOP') to = 0;
  if(kind === 'BOTTOM') to = arr.length - 1;
  if(to === idx) return;
  if(to < 0 || to >= arr.length) return;
  if(!arrayMove(arr, idx, to)) return;
  saveStore(store);
  refreshBigSelect();
  bigFolderSelect.value = prevBig;
  refreshSmallSelect();
  showToast('大フォルダの順序を変更しました');
}
function reorderSmallFolder(kind){
  const big = currentBig();
  if(!big) return;
  const list = store.smallByBig[big] || [];
  if(list.length <= 1) return;
  const sm = currentSmall();
  if(!sm){ return; }
  const idx = list.indexOf(sm);
  if(idx < 0) return;
  let to = idx;
  if(kind === 'UP') to = idx - 1;
  if(kind === 'DOWN') to = idx + 1;
  if(kind === 'TOP') to = 0;
  if(kind === 'BOTTOM') to = list.length - 1;
  if(to === idx) return;
  if(to < 0 || to >= list.length) return;
  if(!arrayMove(list, idx, to)) return;
  store.smallByBig[big] = list;
  saveStore(store);
  refreshSmallSelect();
  smallFolderSelect.value = sm;
  updateCountsAndPath();
  showToast('小フォルダの順序を変更しました');
}

/* ====== Drag & Drop 並び替え ====== */
let dragState = null;
function makeReorderItem(name, scope){
  const el = document.createElement('span');
  el.className = 'reorder-item';
  el.draggable = true;
  el.textContent = name;
  el.dataset.name = name;
  el.dataset.scope = scope;

  el.addEventListener('dragstart', (e)=>{
    dragState = { scope, name };
    el.classList.add('dragging');
    try{ e.dataTransfer.effectAllowed='move'; }catch(_){}
  });
  el.addEventListener('dragend', ()=>{
    dragState = null;
    el.classList.remove('dragging');
    clearDropHints(scope);
  });
  el.addEventListener('dragover', (e)=>{
    if(!dragState || dragState.scope!==scope) return;
    e.preventDefault();
    const rect = el.getBoundingClientRect();
    const after = (e.clientX - rect.left) > (rect.width / 2);
    el.classList.toggle('drop-after', after);
    el.classList.toggle('drop-before', !after);
  });
  el.addEventListener('dragleave', ()=>{
    el.classList.remove('drop-before','drop-after');
  });
  el.addEventListener('drop', (e)=>{
    if(!dragState || dragState.scope!==scope) return;
    e.preventDefault();
    const after = el.classList.contains('drop-after');
    commitReorder(scope, dragState.name, el.dataset.name, after);
  });
  return el;
}
function clearDropHints(scope){
  const list = scope==='big' ? bigReorderList : smallReorderList;
  if(!list) return;
  list.querySelectorAll('.drop-before,.drop-after').forEach(n=>n.classList.remove('drop-before','drop-after'));
}
function renderReorderUI(){
  if(bigReorderList){
    bigReorderList.innerHTML='';
    const arr = store.bigFolders || [];
    arr.forEach(b => bigReorderList.appendChild(makeReorderItem(b.name, 'big')));
    bigReorderList.style.display = (arr.length>1)?'flex':'none';
  }
  if(smallReorderList){
    smallReorderList.innerHTML='';
    const big = currentBig();
    const list = store.smallByBig[big] || [];
    list.forEach(s => smallReorderList.appendChild(makeReorderItem(s, 'small')));
    smallReorderList.style.display = (list.length>1)?'flex':'none';
  }
}
function commitReorder(scope, draggedName, targetName, placeAfter){
  if(scope==='big'){
    const arr = store.bigFolders || [];
    const from = arr.findIndex(b=>b.name===draggedName);
    const toBase = arr.findIndex(b=>b.name===targetName);
    if(from<0 || toBase<0) return;
    let to = toBase + (placeAfter?1:0);
    if(from < to) to--;
    if(from === to) return;
    const [item] = arr.splice(from, 1);
    arr.splice(to, 0, item);
    saveStore(store);
    const prev = currentBig();
    refreshBigSelect();
    if(prev) bigFolderSelect.value = prev;
    refreshSmallSelect();
    renderReorderUI();
    showToast('大フォルダの順序を変更しました');
  }else if(scope==='small'){
    const big = currentBig(); if(!big) return;
    const list = store.smallByBig[big] || [];
    const from = list.indexOf(draggedName);
    const toBase = list.indexOf(targetName);
    if(from<0 || toBase<0) return;
    let to = toBase + (placeAfter?1:0);
    if(from < to) to--;
    if(from === to) return;
    const [item] = list.splice(from, 1);
    list.splice(to, 0, item);
    store.smallByBig[big] = list;
    saveStore(store);
    const prev = currentSmall();
    refreshSmallSelect();
    if(prev) smallFolderSelect.value = prev;
    updateCountsAndPath();
    renderReorderUI();
    showToast('小フォルダの順序を変更しました');
  }
}

/* ====== Toast ====== */
function showToast(msg){
  toastEl.textContent = msg;
  toastEl.style.display = 'block';
  setTimeout(()=>{ toastEl.style.display='none'; }, 1400);
}

/* ====== キュー／正解リスト／ユニーク数 ====== */
// クリア判定（手動クリア優先。未設定ならノーミス到達実績で判定）
function isCleared(k){
  if(!k) return false;
  if(typeof k.manualCleared === 'boolean') return k.manualCleared;
  return !!(k.stats && (k.stats.solved||0) > 0);
}


function addToQueue(pk, id, buttonEl){
  const q = store.queueByPath[pk] || (store.queueByPath[pk]=[]);
  q.push(id); saveStore(store); updateQueueView();
  if(buttonEl){
    const old = buttonEl.textContent;
    buttonEl.textContent = "✓ キュー追加";
    buttonEl.disabled = true;
    setTimeout(()=>{ buttonEl.textContent = old; buttonEl.disabled = false; }, 900);
  }
  showToast("キューに追加しました");
}
function clearQueue(pk){
  store.queueByPath[pk] = []; saveStore(store); updateQueueView(); showToast("キューをクリアしました");
}
function updateQueueView(){
  const pk = currentPath();
  const q = getQueueByPath(pk);
  queueView.innerHTML="";
  q.slice(0,14).forEach((id, i)=>{
    const chip=document.createElement('span'); chip.style.border="1px solid #ccc"; chip.style.padding="2px 6px"; chip.style.borderRadius="999px";
    chip.textContent = (i+1)+"#"+id.slice(0,5);
    queueView.appendChild(chip);
  });
  queueCountEl.textContent = q.length;
}
function renderSolvedList(){
  const pk = currentPath();
  const arr = getArrayByPath(pk);
  const numbers = [];
  (arr||[]).forEach((k, idx)=>{
    if (isCleared(k)) numbers.push((typeof k._idx==='number' ? k._idx+1 : idx+1));
  });
  if(!numbers.length){
    solvedListEl.textContent = "（まだ正解に到達した棋譜はありません）";
  }else{
    solvedListEl.textContent = numbers.join(" ");
  }
  // 全フォルダ横断で「クリア済み（チェックON）」の総数を表示
const totalCleared = Object.values(store.kifuByPath || {}).reduce((sum, list) => {
  const arr = Array.isArray(list) ? list : [];
  return sum + arr.filter(k => isCleared(k)).length;
}, 0);
uniqueSolvedEl.textContent = String(totalCleared);
}

/* ====== 並び替え・検索 ====== */
function getSortedArray(pk){
  const arr = (store.kifuByPath[pk]||[]).slice();
  arr.forEach((k, idx)=>{ if(typeof k._idx==="undefined") k._idx=idx; });
  const by = sortByEl.value, dir = sortDirEl.value;
  arr.sort((a,b)=>{
    const sgn = (dir==="ASC"?1:-1);
    if(by==="INDEX"){ return sgn * (a._idx - b._idx); }
    if(by==="NAME"){ return sgn * ((a.name||"").localeCompare(b.name||"")); }
    if(by==="LEN"){ return sgn * ((a.moves?.length||0) - (b.moves?.length||0)); }
    if(by==="SOLVED"){ return sgn * ((a.stats?.solved||0) - (b.stats?.solved||0)); }
    if(by==="MISTAKES"){ return sgn * ((a.stats?.mistakes||0) - (b.stats?.mistakes||0)); }
    return 0;
  });

  const q = (searchInput.value||"").trim();
  if(!q) return arr;
  const keys = q.split(/\s+/).filter(Boolean).map(s=>s.toLowerCase());
  return arr.filter(k=>{
    const hay = [
      (k.moves||[]).join(" "),
      (k.name||""),
      (k.comment||"")
    ].join(" ").toLowerCase();
    return keys.every(key => hay.includes(key));
  });
}
function updateEnabledCount(){
  const pk = currentPath();
  const arr = getArrayByPath(pk);
  const n = arr.filter(k=>k.enabled!==false).length;
  enabledCountEl.textContent = n;
  enabledCountModalEl.textContent = n;
}

/* ====== 棋譜一覧（モーダル） ====== */
function openKifuModal(){
  const pk = currentPath();
  modalPathName.textContent = pk;
  kifuModal.style.display='flex';
  try{
    if (typeof renameBigInput !== 'undefined' && renameBigInput) { renameBigInput.value = currentBig() || ""; }
    if (typeof renameSmallRow !== 'undefined' && renameSmallRow) {
      const sm = currentSmall();
      if (sm) {
        renameSmallRow.style.display = 'flex';
        if (renameSmallInput) renameSmallInput.value = sm;
        if (renameSmallSaveBtn) renameSmallSaveBtn.disabled = false;
      } else {
        renameSmallRow.style.display = 'none';
      }
    }
  }catch(e){}
  renderKifuList();
}
function closeKifuModal(){ kifuModal.style.display='none'; }

function renderKifuList(){
  const pk = currentPath();
  const arr = getSortedArray(pk);
  const frag = document.createDocumentFragment();

  const title = document.createElement('div');
  title.innerHTML = `<b>この小フォルダの棋譜</b>：${arr.length}件`;
  frag.appendChild(title);

  if(arr.length){
    arr.forEach((k, idx) => {
      if(typeof k.enabled === "undefined") k.enabled = true;
      if(!k.stats) k.stats = { attempts:0, solved:0, mistakes:0 };

      const row = document.createElement('div');
      row.className = "klist-row";
      row.dataset.id = k.id;

      const idxSpan = document.createElement('div');
      idxSpan.className = "kindex";
      idxSpan.textContent = ((typeof k._idx === 'number' ? (k._idx + 1) : (idx + 1))) + ".";

      const info = document.createElement('div');
      info.className = "kinfo";

      const movesStr = (k.moves||[]).join(" ");

      const kifuWrap = document.createElement('div');
      kifuWrap.className = "kifu-wrap";

      const kifuLabel = document.createElement('div');
      kifuLabel.className = "label";
      kifuLabel.textContent = "棋譜";

      const kifuInput = document.createElement('textarea');
      kifuInput.className = "kifu-text";
      kifuInput.value = movesStr;
      kifuInput.setAttribute("readonly","readonly");
      kifuInput.rows = 2;
      kifuInput.addEventListener('click', ()=>{
        kifuInput.focus();
        kifuInput.select();
      });

      const kifuBtns = document.createElement('div');
      kifuBtns.className = "kifu-btns";

      const copyBtn = document.createElement('button');
      copyBtn.className = "ghost";
      copyBtn.textContent = "コピー";
      copyBtn.addEventListener('click', async ()=>{
        try{
          await navigator.clipboard.writeText(movesStr);
          showToast("棋譜をコピーしました");
        }catch(e){
          kifuInput.focus(); kifuInput.select();
          const ok = document.execCommand('copy');
          showToast(ok? "棋譜をコピーしました" : "コピーに失敗しました");
        }
      });

      const lenSpan = document.createElement('span');
      lenSpan.className = "small muted";
      lenSpan.textContent = `（${(k.moves||[]).length}手）`;

      kifuBtns.appendChild(copyBtn);
      kifuBtns.appendChild(lenSpan);
      kifuWrap.appendChild(kifuLabel);
      kifuWrap.appendChild(kifuInput);
      kifuWrap.appendChild(kifuBtns);

      info.appendChild(kifuWrap);

      const noteWrap = document.createElement('div');
      noteWrap.className = "kifu-wrap";

      const noteLabel = document.createElement('div');
      noteLabel.className = "label";
      noteLabel.textContent = "備考";

      const noteInput = document.createElement('textarea');
      noteInput.className = "kifu-text note-text";
      noteInput.placeholder = "メモや気づき、対策などを自由に";
      noteInput.rows = 2;
      noteInput.value = (k.comment || "");

      let saveTimer = null;
      function saveDebounced(){
        if(saveTimer) clearTimeout(saveTimer);
        saveTimer = setTimeout(()=>{ saveStore(store); }, 400);
      }
      noteInput.addEventListener('input', ()=>{
        k.comment = noteInput.value;
        saveDebounced();
      });
      noteInput.addEventListener('change', ()=>{
        k.comment = noteInput.value;
        saveStore(store);
      });

      const noteBtns = document.createElement('div');
      noteBtns.className = "kifu-btns";
      const clearNoteBtn = document.createElement('button');
      clearNoteBtn.className = "ghost";
      clearNoteBtn.textContent = "削除";
      clearNoteBtn.addEventListener('click', ()=>{
        noteInput.value = "";
        k.comment = "";
        saveStore(store);
        showToast("備考を削除しました");
      });
      noteBtns.appendChild(clearNoteBtn);

      noteWrap.appendChild(noteLabel);
      noteWrap.appendChild(noteInput);
      noteWrap.appendChild(noteBtns);
      info.appendChild(noteWrap);

      const enableWrap = document.createElement('label');
      enableWrap.className = "switch";
      const enableChk = document.createElement('input');
      enableChk.type = "checkbox";
      enableChk.checked = !!k.enabled;
      enableChk.addEventListener('change', ()=>{
        k.enabled = !!enableChk.checked; saveStore(store); updateEnabledCount();
      });
      const enableTxt = document.createElement('span');
      enableTxt.textContent = "出題オン";
      enableWrap.appendChild(enableChk);
      enableWrap.appendChild(enableTxt);
// --- manual clear (クリア済み) checkbox under 出題オン ---
const controlCol = document.createElement('div');
controlCol.style.display = 'flex';
controlCol.style.flexDirection = 'column';
controlCol.style.gap = '6px';
controlCol.appendChild(enableWrap);

const clearedWrap = document.createElement('label');
clearedWrap.className = "switch";
const clearedChk = document.createElement('input');
clearedChk.type = "checkbox";
clearedChk.checked = isCleared(k);
clearedChk.addEventListener('change', ()=>{
  k.manualCleared = !!clearedChk.checked;
  saveStore(store);
  renderSolvedList();
});
const clearedTxt = document.createElement('span');
clearedTxt.textContent = "クリア済み";
clearedWrap.appendChild(clearedChk);
clearedWrap.appendChild(clearedTxt);
controlCol.appendChild(clearedWrap);


      const queueBtn = document.createElement('button');
      queueBtn.textContent = "キューに追加";
      queueBtn.addEventListener('click', ()=>{
        const q = getQueueByPath(pk);
        if(!q.includes(k.id)){ q.push(k.id); saveStore(store); updateQueueView(); showToast("キューに追加しました"); }
        else showToast("すでにキューにあります");
      });

      const delBtn = document.createElement('button');
      delBtn.className = "danger.ghost".replace('.', ' ');
      delBtn.textContent = "削除";
      delBtn.addEventListener('click', ()=>{
        if(!confirm("この棋譜を削除しますか？")) return;
        let arr2 = (store.kifuByPath[pk]||[]);
        const idx2 = arr2.findIndex(x=>x.id===k.id);
        if(idx2>=0){ arr2.splice(idx2,1); saveStore(store); renderKifuList(); updateEnabledCount(); updateQueueView(); }
      });

      row.appendChild(idxSpan);
      row.appendChild(info);
      row.appendChild(controlCol);
      row.appendChild(queueBtn);
      row.appendChild(delBtn);

      frag.appendChild(row);
    });
  }else{
    const p=document.createElement('div'); p.className="small muted"; p.textContent="（まだ棋譜がありません）"; frag.appendChild(p);
  }
  kifuList.innerHTML=""; kifuList.appendChild(frag);
  updateEnabledCount();
  updateQueueView();
  renderSolvedList();
  ensureBulkButtons();
}


/* ====== フォルダ名の編集（モーダル内） ====== */
function _normalizeFolderName(s){ return String(s||"").trim(); }
function _validateFolderName(s){
  if(!s) return "名前を入力してください";
  if(/[\/\\]/.test(s)) return "スラッシュ（/）やバックスラッシュ（\\）は使えません";
  if(s==="__ROOT__") return "__ROOT__ は使用できません";
  return "";
}
function doRenameBigFolder(){
  try{
    const oldBig = currentBig();
    if(!oldBig){ alert("大フォルダが選択されていません"); return; }
    const prevSmall = currentSmall();
    const newBig = _normalizeFolderName(renameBigInput ? renameBigInput.value : "");
    if(oldBig === newBig){ showToast("変更はありません"); return; }
    const err = _validateFolderName(newBig);
    if(err){ alert("大フォルダ名エラー：" + err); return; }
    if((store.bigFolders||[]).some(b => b.name === newBig)){ alert("同名の大フォルダが既にあります"); return; }

    // bigFolders: rename keeping defaultColor
    const meta = (store.bigFolders||[]).find(b => b.name === oldBig);
    if(!meta){ alert("現在の大フォルダが見つかりません"); return; }
    meta.name = newBig;

    // move smallByBig
    store.smallByBig[newBig] = store.smallByBig[oldBig] || [];
    if(newBig !== oldBig) delete store.smallByBig[oldBig];

    // move kifuByPath & queueByPath keys
    const oldPrefix = oldBig + "/";
    const newPrefix = newBig + "/";
    Object.keys(store.kifuByPath||{}).forEach(k => {
      if(k.startsWith(oldPrefix)){
        const suffix = k.slice(oldPrefix.length);
        store.kifuByPath[newPrefix + suffix] = store.kifuByPath[k];
        delete store.kifuByPath[k];
      }
    });
    Object.keys(store.queueByPath||{}).forEach(k => {
      if(k.startsWith(oldPrefix)){
        const suffix = k.slice(oldPrefix.length);
        store.queueByPath[newPrefix + suffix] = store.queueByPath[k];
        delete store.queueByPath[k];
      }
    });

    saveStore(store);
    const keepSmall = prevSmall && (store.smallByBig[newBig]||[]).includes(prevSmall) ? prevSmall : (store.smallByBig[newBig]||[])[0] || "";
    refreshBigSelect();
    bigFolderSelect.value = newBig;
    refreshSmallSelect();
    if(keepSmall){ smallFolderSelect.value = keepSmall; }
    updateCountsAndPath();
    if(typeof modalPathName !== 'undefined' && modalPathName){ modalPathName.textContent = currentPath(); }
    renderKifuList();
    renderReorderUI();
    showToast("大フォルダ名を変更しました");
  }catch(e){
    console.warn(e);
    alert("大フォルダ名の変更でエラーが発生しました");
  }
}
function doRenameSmallFolder(){
  try{
    const big = currentBig();
    const oldSm = currentSmall();
    if(!big){ alert("大フォルダが選択されていません"); return; }
    if(!oldSm){ alert("小フォルダが選択されていません"); return; }
    const newSm = _normalizeFolderName(renameSmallInput ? renameSmallInput.value : "");
    if(oldSm === newSm){ showToast("変更はありません"); return; }
    const err = _validateFolderName(newSm);
    if(err){ alert("小フォルダ名エラー：" + err); return; }
    const list = store.smallByBig[big] || [];
    if(list.includes(newSm)){ alert("同名の小フォルダが既にあります"); return; }

    // update small list
    const idx = list.indexOf(oldSm);
    if(idx < 0){ alert("小フォルダが見つかりません"); return; }
    list[idx] = newSm;
    store.smallByBig[big] = list;

    // move path keys
    const oldKey = pathKey(big, oldSm);
    const newKey = pathKey(big, newSm);
    store.kifuByPath[newKey] = store.kifuByPath[oldKey] || [];
    store.queueByPath[newKey] = store.queueByPath[oldKey] || [];
    if(newKey !== oldKey){
      delete store.kifuByPath[oldKey];
      delete store.queueByPath[oldKey];
    }

    saveStore(store);
    refreshSmallSelect();
    smallFolderSelect.value = newSm;
    updateCountsAndPath();
    if(typeof modalPathName !== 'undefined' && modalPathName){ modalPathName.textContent = currentPath(); }
    renderKifuList();
    renderReorderUI();
    showToast("小フォルダ名を変更しました");
  }catch(e){
    console.warn(e);
    alert("小フォルダ名の変更でエラーが発生しました");
  }
}

/* ====== 棋譜追加 ====== */
function addKifuGuarded(){
  const big = currentBig();
  const sm  = currentSmall();
  if(!big){ showToast("大フォルダを定義して下さい"); return; }
  if(!sm){ showToast("小フォルダを定義して下さい"); return; }
  addKifuToCurrent();
}
function addKifuToCurrent(){
  const pk = currentPath();
  const lines = kifuInput.value.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  if(!lines.length){ alert("棋譜を1行以上入力してください"); return; }
  const arr = store.kifuByPath[pk] || (store.kifuByPath[pk]=[]);
  let okCount=0, dupCount=0, ngMsgs=[];
  for(const line of lines){
    const tokens = tokenizeKifuString(line);
    if(tokens === null){ ngMsgs.push(`・${line.slice(0,50)}${line.length>50?'…':''} → 形式が不正`); continue; }
    if(tokens.length===0){ ngMsgs.push(`・空行`); continue; }
    if(tokens.length>60){ ngMsgs.push(`・${line.slice(0,20)}… → 60手を超過`); continue; }
    const val = validateMoves(tokens);
    if(!val.ok){ ngMsgs.push(`・${line.slice(0,50)}${line.length>50?'…':''} → ${val.error}`); continue; }
    const sig = canonicalSignature(tokens);
    if(arr.some(k=>k.sig===sig)){ dupCount++; continue; }
    arr.push({ id: Date.now().toString(36)+Math.random().toString(36).slice(2,7),
               moves: tokens, sig, enabled: true, name:"", tags:[], comment:"", addedAt: Date.now(), _idx: arr.length,
               stats: { attempts:0, solved:0, mistakes:0 } });
    okCount++;
  }
  saveStore(store);
  if(okCount) showToast(`${okCount}件の棋譜を追加（重複スキップ：${dupCount}）`);
  if(ngMsgs.length) alert("追加できなかった棋譜があります：\n" + ngMsgs.join("\n"));
  kifuInput.value="";
  updateCountsAndPath();
  if(kifuModal.style.display==='flex') renderKifuList();
}

/* ====== 出題ロジック ====== */
function getArrSortedCurrent(){ return getSortedArray(currentPath()); }
function getEnabledArrCurrent(){ return getArrSortedCurrent().filter(k=>k.enabled!==false); }
function pickKifu(){
  const pk = currentPath();
  const arrSorted = getArrSortedCurrent();
  const enabledArr = getEnabledArrCurrent();
  let picked = null;
  const mode = pickModeEl.value;
  if(mode === "RANDOM"){
    if(enabledArr.length===0){ alert("出題オンの棋譜がありません（チェックを入れてください）"); return null; }
    picked = enabledArr[Math.floor(Math.random()*enabledArr.length)];
  }else if(mode === "NUMBER"){
    const n = parseInt(kifuNumberInput.value,10);
    if(!(n>=1 && n<=arrSorted.length)){ alert(`番号は 1〜${arrSorted.length} の範囲で指定してください`); return null; }
    picked = arrSorted[n-1];
  }else if(mode === "NUMBER_ENABLED"){
    if(enabledArr.length===0){ alert("出題オンの棋譜がありません（チェックを入れてください）"); return null; }
    const n = parseInt(kifuNumberInput.value,10);
    if(!(n>=1 && n<=enabledArr.length)){ alert(`番号は 1〜${enabledArr.length}（出題オンのみ）で指定してください`); return null; }
    picked = enabledArr[n-1];
  }else if(mode === "QUEUE"){
    const q = getQueueByPath(pk);
    while(q.length){
      const id = q.shift();
      const cand = arrSorted.find(k=>k.id===id);
      if(cand){ picked=cand; break; }
    }
    saveStore(store); updateQueueView();
    if(!picked){
      if(enabledArr.length===0){ alert("キューが空です。出題オンの棋譜もありません。"); return null; }
      picked = enabledArr[Math.floor(Math.random()*enabledArr.length)];
      showToast("キューが空のため、ランダムで出題します");
    }
  }else if(mode === "UNSOLVED"){
    const cand = enabledArr.filter(k => !isCleared(k));
    if(cand.length===0){ alert("未クリアの出題オンの棋譜がありません。"); return null; }
    picked = cand[Math.floor(Math.random()*cand.length)];
  }else if(mode === "HARD"){
    if(enabledArr.length===0){ alert("出題オンの棋譜がありません（チェックを入れてください）"); return null; }
    const ranked = enabledArr.slice().sort((a,b)=>{
      const ra = (a.stats?.mistakes||0) / Math.max(1, (a.stats?.attempts||0));
      const rb = (b.stats?.mistakes||0) / Math.max(1, (b.stats?.attempts||0));
      if(rb !== ra) return rb - ra;
      return (b.stats?.mistakes||0) - (a.stats?.mistakes||0);
    });
    picked = ranked[0];
  }
  return picked;
}

/* ====== セッション進行 ====== */
function setStatus(msg){ statusEl.textContent = msg; }
function setProgress(){
  const done = Math.max(0, Math.min(moveIndex - (rangeStart-1), rangeEnd - rangeStart + 1));
  const total = Math.max(0, rangeEnd - rangeStart + 1);
  progressEl.textContent = `${done} / ${total}`;
  mistakesNowEl.textContent = `${sessionMistakes}`;
}
function startTrainingWithKifuId(id){
  const arr = getArrSortedCurrent();
  const picked = arr.find(k=>k.id===id);
  if(!picked){ alert("指定の棋譜が見つかりません"); return; }
  return startTrainingCore(picked);
}
function startTraining(){
  const picked = pickKifu();
  if(!picked) return;
  return startTrainingCore(picked);
}
function startTrainingCore(picked){
  myColor = (document.querySelector('input[name="myColor"]:checked').value === 'BLACK') ? BLACK : WHITE;
  syncSelfBothUI();
  expectedMoves = picked.moves.slice();
  currentKifuId = picked.id;
  updateBoardIndexLabel();
  const rawS = parseInt(startIndexInput.value || "1", 10);
  const rawE = parseInt(endIndexInput.value || String(expectedMoves.length), 10);
  rangeStart = isFinite(rawS) ? Math.max(1, Math.min(rawS, expectedMoves.length)) : 1;
  rangeEnd = isFinite(rawE) ? Math.max(rangeStart, Math.min(rawE, expectedMoves.length)) : expectedMoves.length;

  board = newBoard();
  currentPlayer = BLACK;
  moveIndex = 0;
  training = true;
  sessionMistakes = 0;

  const pk=currentPath();
  const arr = store.kifuByPath[pk] || [];
  const k = arr.find(x=>x.id===currentKifuId);
  if(k){ k.stats = k.stats || { attempts:0, solved:0, mistakes:0 }; k.stats.attempts++; saveStore(store); }

  setStatus(`トレーニング開始：${pk} / ${expectedMoves.length}手（開始=${rangeStart} / 終了=${rangeEnd}）`);
  setPositionByTokenIndex(rangeStart - 1);
  renderBoard();
  setProgress();
  stepIfAIShouldPlay(true);
  hideCelebrate();
}
function setPositionByTokenIndex(idx){
  board = newBoard();
  currentPlayer = BLACK;
  let i = 0;
  let passes=0;
  while(i < idx){
    const token = expectedMoves[i];
    const LM = legalMoves(board, currentPlayer);
    if(token==="P" || token==="PASS"){
      if(LM.length>0){ setStatus(`${i+1}手目：PASS指定ですが合法手があります。棋譜が不正です。`); training=false; break; }
      currentPlayer = -currentPlayer; i++; passes++; if(passes>=2) break;
      continue;
    }
    if(LM.length===0){
      currentPlayer = -currentPlayer; passes++; if(passes>=2) break;
      continue;
    }
    passes=0;
    const rc = coordToRC(token);
    const match = legalMoves(board, currentPlayer).find(m=>m.r===rc[0] && m.c===rc[1]);
    if(!match){ setStatus(`${i+1}手目 ${token} は合法でありません。棋譜が不正です。`); training=false; break; }
    applyMove(board, match, currentPlayer);
    currentPlayer = -currentPlayer; i++;
  }
  moveIndex = i;
}
function stepIfAIShouldPlay(startPhase=false){
  if(!training) return;

  if(selfBothMode){
    if(startPhase){
      setStatus(`両方を自分で打つモード：${moveIndex+1}手目から期待手どおりに進めてください。`);
    }
    checkFinishIfNeeded();
    return;
  }

  const aiColor = -myColor;
  let progressed = false;
  while(training && currentPlayer === aiColor && moveIndex < expectedMoves.length && moveIndex < rangeEnd){
    const token = expectedMoves[moveIndex];
    const LM = legalMoves(board, currentPlayer);
    if(token==="P" || token==="PASS"){
      if(LM.length>0){ setStatus(`棋譜${moveIndex+1}手目はPASS指定ですが合法手があります。棋譜が不正です。`); training=false; return; }
      currentPlayer = -currentPlayer; moveIndex++; progressed = true; setProgress(); continue;
    }
    if(LM.length===0){
      currentPlayer = -currentPlayer; progressed = true; continue;
    }
    const rc = coordToRC(token); if(!rc){ setStatus(`棋譜${moveIndex+1}手目が不正: ${token}`); training=false; return; }
    const match = LM.find(m=>m.r===rc[0] && m.c===rc[1]);
    if(!match){ setStatus(`棋譜${moveIndex+1}手目 ${token} は合法でありません。棋譜が不正です。`); training=false; return; }
    applyMove(board, match, currentPlayer);
    currentPlayer = -currentPlayer; moveIndex++; progressed = true; setProgress(); renderBoard();
    renderReorderUI();
  }
  if(progressed && startPhase && currentPlayer===myColor){
    setStatus(`あなたの番です。期待手どおりに打ってください（${moveIndex+1}手目）。`);
  }
  checkFinishIfNeeded();
}
function onCellClick(e){
  if(inspectMode) return;  // v17-fix: disable click during 確認中
  const cell=this;
  if(boardWrap.classList.contains('legal-only') && !cell.classList.contains('legal')){ return; }
  const r=parseInt(cell.dataset.r,10); const c=parseInt(cell.dataset.c,10); const coord=cell.dataset.coord;
  if(!training || (!selfBothMode && currentPlayer !== myColor)) return;
  if(moveIndex >= expectedMoves.length || moveIndex >= rangeEnd) return;
  if(legalMoves(board, currentPlayer).length===0){
    currentPlayer=-currentPlayer; stepIfAIShouldPlay(); return;
  }
  if(board[r][c] !== EMPTY){ return; }
  const token = expectedMoves[moveIndex]; if(!token) return;
  if(token==="P" || token==="PASS"){
    const LM=legalMoves(board,currentPlayer);
    if(LM.length===0){ currentPlayer=-currentPlayer; moveIndex++; setProgress(); renderBoard(); stepIfAIShouldPlay(); return; }
    sessionMistakes++; playSound("ng"); flashX(cell); setStatus("この手番はPASS指定ではありません。"); setProgress(); return;
  }
  if(coord !== token){
    sessionMistakes++; playSound("ng"); flashX(cell); setStatus(`× 不正解。期待手は ${token} です。もう一度どうぞ。`); setProgress(); return;
  }
  const LM = legalMoves(board, currentPlayer);
  const match = LM.find(m=>m.r===r && m.c===c);
  if(!match){
    sessionMistakes++; playSound("ng"); flashX(cell); setStatus(`その手（${coord}）は合法手ではありません。棋譜が不整合の可能性があります。`); setProgress(); return;
  }
  applyMove(board, match, currentPlayer); playSound("ok");
  currentPlayer = -currentPlayer; moveIndex++; setProgress(); renderBoard(); stepIfAIShouldPlay();
}
function checkFinishIfNeeded(){
  if(!training) return;
  if(moveIndex >= expectedMoves.length || moveIndex >= rangeEnd){
    training=false;
    const pk = currentPath();
    const arr = store.kifuByPath[pk] || [];
    const k = arr.find(x=>x.id===currentKifuId);
    if(k){
      k.stats.mistakes += sessionMistakes;
      const firstSolvedBefore = (k.stats.solved>0);
      if(sessionMistakes===0){ k.stats.solved++; k.manualCleared = true; }
      saveStore(store);
      if(!firstSolvedBefore && sessionMistakes===0){
        store.learnedOnceIds = Array.from(new Set([...(store.learnedOnceIds||[]), k.id]));
        saveStore(store);
      }
      renderSolvedList();
      if (kifuModal && kifuModal.style.display==='flex') { try{ renderKifuList(); }catch(e){} }
    }
    playSound("success");
    const total = rangeEnd - rangeStart + 1;
    setStatus(`暗記成功！範囲 ${rangeStart}〜${rangeEnd}（全${total}手）を再現しました。${sessionMistakes===0?'（ミスなし）':'（誤答 '+sessionMistakes+' 回）'}`);
    showCelebrate(total, sessionMistakes);
  }
}
function flashX(cell){ cell.classList.add('xmark'); setTimeout(()=>cell.classList.remove('xmark'),600); }

/* ====== 祝福演出 ====== */
function showCelebrate(total, mistakes){
  populateResultPanel();
  celebrateMsg.textContent = `再現手数：${total}　誤答：${mistakes} 回`;
  celebrateLayer.style.display = 'flex';
  const N=60;
  const frag=document.createDocumentFragment();
  for(let i=0;i<N;i++){
    const d=document.createElement('div');
    d.className='confetti';
    d.style.setProperty('--x', Math.random()*380 + 'px');
    d.style.setProperty('--h', Math.floor(Math.random()*360));
    d.style.setProperty('--r', Math.floor(Math.random()*360) + 'deg');
    d.style.left = (Math.random()* (boardWrap.clientWidth-20)) + 'px';
    d.style.top = '-20px';
    frag.appendChild(d);
  }
  celebrateLayer.querySelectorAll('.confetti').forEach(n=>n.remove());
  celebrateLayer.appendChild(frag);
}
function hideCelebrate(){ celebrateLayer.style.display='none'; }
repeatBtn.addEventListener('click', ()=>{ hideCelebrate(); if(currentKifuId) startTrainingWithKifuId(currentKifuId); });
nextBtn.addEventListener('click', ()=>{ hideCelebrate(); startTraining(); });

/* ====== Inspect（←/→） ====== */
function enterInspect(){
  if(!training) return;
  inspectMode = true;
  inspectIndex = moveIndex;
  inspectBar.style.display = 'inline-block';
  inspectAction.style.display = 'inline-block';
}
function exitInspectResume(){
  if(!inspectMode) return;
  setPositionByTokenIndex(inspectIndex);
  inspectMode = false;
  inspectBar.style.display = 'none';
  inspectAction.style.display = 'none';
  training = true;
  renderBoard(); setProgress();
  stepIfAIShouldPlay(true);
}
resumeBtn.addEventListener('click', exitInspectResume);
window.addEventListener('keydown', (e)=>{
  if(!training) return;
  const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
  if(tag==='input' || tag==='textarea' || tag==='select') return;
  if(e.key==="ArrowLeft" || e.key==="ArrowRight"){
    e.preventDefault();
    if(!inspectMode) enterInspect();
    if(e.key==="ArrowLeft"){
      inspectIndex = Math.max(rangeStart-1, inspectIndex - 1);
    }else if(e.key==="ArrowRight"){
      inspectIndex = Math.min(rangeEnd, inspectIndex + 1);
    }
    setPositionByTokenIndex(inspectIndex);
    renderBoard();
    setStatus(`確認中：${inspectIndex+1}手目の局面（範囲 ${rangeStart}〜${rangeEnd}）`);
  }
});

/* ====== 両方を自分で打つ：UI同期 ====== */
function syncSelfBothUI(){
  selfBothMode = !!(toggleSelfBothEl && toggleSelfBothEl.checked);
  if (myColorRadios && myColorRadios.forEach) {
    myColorRadios.forEach(r => { r.disabled = selfBothMode; });
  }
  updateLegalClickable();
}

/* ====== 全データ初期化 ====== */
function resetAllData(){
  if(!confirm("本アプリの全データ（大/小フォルダ・棋譜・キュー・統計・学習済み数）を初期化してよろしいですか？\n※ この操作は取り消せません。")) return;
  try {
    localStorage.removeItem(STORE_KEY_V6);
    (LEGACY_KEYS||[]).forEach(k => { try{ localStorage.removeItem(k); }catch(e){} });
  } catch(e) { /* ignore */ }
  store = defaultStore();
  saveStore(store);

  if(kifuModal) kifuModal.style.display='none';
  training = false;
  sessionMistakes = 0;
  expectedMoves = [];
  rangeStart = 1;
  rangeEnd = 0;
  moveIndex = 0;
  board = newBoard();
  currentPlayer = BLACK;
  currentKifuId = null;
  inspectMode = false;
  inspectIndex = 0;
  selfBothMode = false;

  if(kifuInput) kifuInput.value = "";
  if(newBigFolderName) newBigFolderName.value = "";
  if(newBigFolderColor) newBigFolderColor.value = "";
  if(newSmallFolderName) newSmallFolderName.value = "";
  if(toggleHintEl) toggleHintEl.checked = false;
  if(toggleMiniCoordEl) toggleMiniCoordEl.checked = false;
  if(toggleSoundEl) toggleSoundEl.checked = true;
  if(toggleSelfBothEl) toggleSelfBothEl.checked = false;
  if(myColorRadios && myColorRadios.forEach){
    myColorRadios.forEach(r => { r.disabled = false; r.checked = (r.value === 'BLACK'); });
  }

  renderAxes(); ensureCells();
  refreshBigSelect();
  updateCountsAndPath();
  renderSolvedList();
  updateQueueView();
  hideCelebrate();
  setStatus("初期化しました。大/小フォルダを選び、棋譜を登録して開始してください。");
  setProgress();
  renderBoard();
  showToast("アプリを初期化しました");
}

/* ====== 初期化とイベント ====== */
function init(){
  fitBoardToViewport();
  toggleHintEl.checked = false;
  // 並び替え 初期状態：表示順（追加順）／昇順／検索空白
  if (typeof sortByEl !== 'undefined' && sortByEl) sortByEl.value = 'INDEX';
  if (typeof sortDirEl !== 'undefined' && sortDirEl) sortDirEl.value = 'ASC';
  if (typeof searchInput !== 'undefined' && searchInput) searchInput.value = '';
  toggleMiniCoordEl.checked = false;
  (store.bigFolders||[]).forEach(b=> ensureBig(b.name));
  saveStore(store);
  refreshBigSelect();
  renderAxes(); ensureCells();
  if (toggleSelfBothEl) syncSelfBothUI();
  setStatus("大/小フォルダを選び、棋譜を登録して開始してください。");
  setProgress(); renderBoard();
}
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init, { once: true });
} else {
  init();
}
bigFolderSelect.addEventListener('change', refreshSmallSelect);
if (typeof newBigFolderName !== 'undefined' && newBigFolderName) {
  newBigFolderName.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') { e.preventDefault(); addBigFolder(); }
  });
}
addBigFolderBtn.addEventListener('click', addBigFolder);
deleteBigFolderBtn.addEventListener('click', deleteBigFolder);

addSmallFolderBtn.addEventListener('click', addSmallFolder);
deleteSmallFolderBtn.addEventListener('click', deleteSmallFolder);
smallFolderSelect.addEventListener('change', updateCountsAndPath);

if (bigUpBtn) bigUpBtn.addEventListener('click', ()=> reorderBigFolder('UP'));
if (bigDownBtn) bigDownBtn.addEventListener('click', ()=> reorderBigFolder('DOWN'));
if (bigTopBtn) bigTopBtn.addEventListener('click', ()=> reorderBigFolder('TOP'));
if (bigBottomBtn) bigBottomBtn.addEventListener('click', ()=> reorderBigFolder('BOTTOM'));
if (smallUpBtn) smallUpBtn.addEventListener('click', ()=> reorderSmallFolder('UP'));
if (smallDownBtn) smallDownBtn.addEventListener('click', ()=> reorderSmallFolder('DOWN'));
if (smallTopBtn) smallTopBtn.addEventListener('click', ()=> reorderSmallFolder('TOP'));
if (smallBottomBtn) smallBottomBtn.addEventListener('click', ()=> reorderSmallFolder('BOTTOM'));

openListBtn.addEventListener('click', openKifuModal);
closeModalBtn.addEventListener('click', closeKifuModal);


if (renameBigSaveBtn) renameBigSaveBtn.addEventListener('click', doRenameBigFolder);
if (renameSmallSaveBtn) renameSmallSaveBtn.addEventListener('click', doRenameSmallFolder);
if (renameBigInput) renameBigInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); doRenameBigFolder(); } });
if (renameSmallInput) renameSmallInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); doRenameSmallFolder(); } });


addKifuBtn.addEventListener('click', addKifuGuarded);
clearKifuInputBtn.addEventListener('click', ()=> kifuInput.value="" );

sortByEl.addEventListener('change', renderKifuList);
sortDirEl.addEventListener('change', renderKifuList);
searchInput.addEventListener('input', renderKifuList);
clearSearchBtn.addEventListener('click', ()=>{
  // 初期設定：表示順（追加順）／昇順／検索空白
  sortByEl.value = 'INDEX';
  sortDirEl.value = 'ASC';
  searchInput.value = '';
  renderKifuList();
});

startBtn.addEventListener('click', startTraining);
resetBtn.addEventListener('click', ()=>{ training=false; sessionMistakes=0; expectedMoves=[]; rangeStart=1; rangeEnd=0; moveIndex=0; board=newBoard(); currentPlayer=BLACK; hideCelebrate(); setStatus("盤面を初期化しました。"); setProgress(); renderBoard(); });

toggleHintEl.addEventListener('change', ()=> renderBoard());
toggleMiniCoordEl.addEventListener('change', ()=> renderBoard());

if (toggleSelfBothEl) {
  toggleSelfBothEl.addEventListener('change', ()=>{
    syncSelfBothUI();
    if (training) {
      setStatus(selfBothMode 
        ? `両方を自分で打つモード：${moveIndex+1}手目から再開してください。`
        : `通常モードに戻りました。`);
      renderBoard();
    }
  });
}

clearQueueBtn.addEventListener('click', ()=> clearQueue(currentPath()));
peekQueueBtn.addEventListener('click', ()=>{
  const pk=currentPath(); const q=getQueueByPath(pk);
  if(!q.length){ alert("キューは空です。"); return; }
  const arr=getArrSortedCurrent();
  const id=q[0]; const k=arr.find(x=>x.id===id);
  if(!k){ alert("キュー先頭の棋譜は存在しません（削除された可能性）。"); return; }
  alert(`キュー先頭（次に出題）：\n${(k.name?`「${k.name}」\n`:"")}${k.moves.join(" ")}\n（${k.moves.length}手）`);
});

exportBtn.addEventListener('click', ()=>{
  const blob = new Blob([JSON.stringify(store,null,2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download="reversi_trainer_store_v6.json";
  document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url), 1000);
});
importBtn.addEventListener('click', ()=> importFile.click());
if(initAllBtn){ initAllBtn.addEventListener('click', resetAllData); }
importFile.addEventListener('change', ()=>{
  const file=importFile.files[0]; if(!file) return;
  const reader=new FileReader();
  reader.onload=()=>{
    try{
      const obj=JSON.parse(reader.result);
      if(!obj || !Array.isArray(obj.bigFolders) || typeof obj.kifuByPath!=="object") throw new Error("形式が不正です");
      if(!obj.smallByBig) obj.smallByBig={};
      if(!obj.queueByPath) obj.queueByPath={};
      if(!obj.learnedOnceIds) obj.learnedOnceIds=[];
      store=obj; saveStore(store); refreshBigSelect(); updateCountsAndPath(); alert("インポートしました");
    }catch(err){ alert("インポート失敗：" + err.message); }
  };
  reader.readAsText(file,"utf-8");
});

/* ====== v6.1 Additions ====== */
function ensureBulkButtons(){
  const footerRow = kifuModal.querySelector('.footer .row');
  if(!footerRow) return;

  if(!footerRow.querySelector('#enableAllBtn')){
    const enableBtn = document.createElement('button');
    enableBtn.id = 'enableAllBtn';
    enableBtn.className = 'ghost';
    enableBtn.textContent = '出題オンをすべて入れる';
    enableBtn.addEventListener('click', ()=> bulkEnable(true));
    footerRow.insertBefore(enableBtn, footerRow.firstChild);
  }
  if(!footerRow.querySelector('#disableAllBtn')){
    const disableBtn = document.createElement('button');
    disableBtn.id = 'disableAllBtn';
    disableBtn.className = 'ghost';
    disableBtn.textContent = '出題オンを一括で外す';
    disableBtn.addEventListener('click', ()=> bulkEnable(false));
    footerRow.insertBefore(disableBtn, footerRow.firstChild);
  }
}
function bulkEnable(flag){
  const pk = currentPath();
  const arr = store.kifuByPath[pk] || [];
  if(!arr.length){ showToast("対象の棋譜がありません"); return; }
  const msg = flag ? "この小フォルダ内の全棋譜を 出題オン にします。よろしいですか？"
                   : "この小フォルダ内の全棋譜の 出題オン を外します。よろしいですか？";
  if(!confirm(msg)) return;
  arr.forEach(k => { k.enabled = !!flag; });
  saveStore(store);
  renderKifuList();
  updateEnabledCount();
  showToast(flag ? "すべて出題オンにしました" : "すべて出題オフにしました");
}
if (typeof searchInput !== 'undefined' && searchInput) {
  searchInput.placeholder = "棋譜／備考／名前で検索（空白区切りAND）";
}
(function(){
  const btn = document.getElementById('clearStatsBtn');
  if(btn && !btn.dataset.patched){
    btn.dataset.patched = "1";
    btn.addEventListener('click', ()=>{
      const pk = currentPath();
      const arr = store.kifuByPath[pk] || [];
      if(!arr.length){ alert("この小フォルダには棋譜がありません。"); return; }
      if(!confirm("この小フォルダ内の統計（attempts/solved/mistakes）をすべて0にリセットします。よろしいですか？")) return;
      arr.forEach(k => { k.stats = { attempts:0, solved:0, mistakes:0 }; });
      saveStore(store);
      renderKifuList();
      showToast("統計をリセットしました");
    });
  }
})();
</script>
<!-- ===== Collapsible chip lists for 大/小フォルダ（初期は折りたたみ） ===== -->
<script>
(function(){
  var uiBigOpen = localStorage.getItem(STORE_PREFIX + 'ui_bigReorderOpen') === '1';
  var uiSmallOpen = localStorage.getItem(STORE_PREFIX + 'ui_smallReorderOpen') === '1';

  function applyReorderVisibility(){
    try{
      var bigBtn = document.getElementById('toggleBigReorderBtn');
      var smallBtn = document.getElementById('toggleSmallReorderBtn');
      var bigList = document.getElementById('bigReorderList');
      var smallList = document.getElementById('smallReorderList');
      if(bigBtn && bigList){
        var canShowBig = (store.bigFolders||[]).length > 1;
        bigList.style.display = (uiBigOpen && canShowBig) ? 'flex' : 'none';
        bigBtn.textContent = uiBigOpen ? '大フォルダリストを非表示' : '大フォルダを並べ替える';
        bigBtn.style.display = canShowBig ? 'inline-block' : 'none';
      }
      if(smallBtn && smallList){
        var big = (typeof currentBig === 'function') ? currentBig() : (window.bigFolderSelect ? bigFolderSelect.value : '');
        var list = (store.smallByBig && big) ? (store.smallByBig[big]||[]) : [];
        var canShowSmall = list.length > 1;
        smallList.style.display = (uiSmallOpen && canShowSmall) ? 'flex' : 'none';
        smallBtn.textContent = uiSmallOpen ? '小フォルダリストを非表示' : '小フォルダを並べ替える';
        smallBtn.style.display = canShowSmall ? 'inline-block' : 'none';
      }
    }catch(e){ /* ignore */ }
  }

  var _origRenderReorderUI = window.renderReorderUI;
  window.renderReorderUI = function(){
    if(typeof _origRenderReorderUI === 'function'){ _origRenderReorderUI(); }
    applyReorderVisibility();
  };

  window.addEventListener('load', function(){
    var bigBtn = document.getElementById('toggleBigReorderBtn');
    var smallBtn = document.getElementById('toggleSmallReorderBtn');
    if(bigBtn){
      bigBtn.addEventListener('click', function(){
        uiBigOpen = !uiBigOpen;
        localStorage.setItem(STORE_PREFIX + 'ui_bigReorderOpen', uiBigOpen ? '1' : '0');
        applyReorderVisibility();
      });
    }
    if(smallBtn){
      smallBtn.addEventListener('click', function(){
        uiSmallOpen = !uiSmallOpen;
        localStorage.setItem(STORE_PREFIX + 'ui_smallReorderOpen', uiSmallOpen ? '1' : '0');
        applyReorderVisibility();
      });
    }
    applyReorderVisibility();
  });
})();
</script>
<style>

/* ===== v8 addons: theme, chips, overlays, reorder handle ===== */
:root{
  --fg: #111;
  --bg: #ffffff;
  --card-bg: #ffffff;
  --card-border: #e7e7e7;
  --muted: #666;
  --chip-bg: #eef3ff;
  --chip-br: #c8d7ff;
  --chip-fg: #174199;
  --overlay-bg: rgba(0,0,0,0.55);
}
body{ background: var(--bg); color: var(--fg); }
.card{ background: var(--card-bg); border-color: var(--card-border); }
.muted, .small{ color: var(--muted); }

body.theme-dark{
  --fg: #e7ebf3;
  --bg: #0f1216;
  --card-bg: #151a1f;
  --card-border: #2a2f3a;
  --muted: #a9b2c3;
  --chip-bg: #1a2638;
  --chip-br: #2a3a58;
  --chip-fg: #b1c6ff;
}
.axis{ color: #f0f0f0; }

/* count overlay on board */
.count-overlay{
  position:absolute; right:10px; bottom:10px; z-index:6;
  background: rgba(0,0,0,0.55); color:#fff; padding:3px 8px; border-radius:8px;
  font-size:.88rem; font-variant-numeric: tabular-nums; pointer-events:none;
}

/* tag chips */
.chips{ display:flex; gap:6px; flex-wrap:wrap; }
.chip{ display:inline-flex; align-items:center; gap:6px; padding:3px 8px; border-radius:999px;
       border:1px solid var(--chip-br); background: var(--chip-bg); color: var(--chip-fg); font-size:.82rem; }
.chip .x{ cursor:pointer; user-select:none; }

/* draggable rows highlight */
.klist-row.dragging{ opacity:.65; }
.klist-row.drop-before{ box-shadow: inset 0 3px 0 #8ab4ff; outline:2px dashed #8ab4ff; outline-offset:-6px; }
.klist-row.drop-after{ box-shadow: inset 0 -3px 0 #8ab4ff; outline:2px dashed #8ab4ff; outline-offset:-6px; }

/* inline help link style */
.inline-help{ font-size:.82rem; text-decoration:underline; cursor:pointer; }

</style>
<script>

/* ===== v8 Addons by ChatGPT (2025-10-19) ===== */
(function(){
  const OPT = (k, d) => { try{ const v = localStorage.getItem(STORE_PREFIX + 'opt_' + k); return v==null?d:JSON.parse(v);}catch(_){ return d; } };
  const SETOPT = (k, v) => { try{ localStorage.setItem(STORE_PREFIX + 'opt_' + k, JSON.stringify(v)); }catch(_){ } };
  const now = () => Date.now();
  const dayMs = 24*60*60*1000;

  /* --- Title bump --- */
  try{
    // [refactor] removed version bump
    // [refactor] removed version bump
  }catch(_){}

  /* --- Theme toggle --- */
  const themeModeInit = OPT('themeMode', 'auto'); // 'auto' | 'light' | 'dark'
  function applyTheme(mode){
    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    if(mode==='auto') document.body.classList.toggle('theme-dark', prefersDark);
    else document.body.classList.toggle('theme-dark', mode==='dark');
  }
  applyTheme(themeModeInit);
  if(window.matchMedia){
    try{
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', ()=>{
        if(OPT('themeMode','auto')==='auto') applyTheme('auto');
      });
    }catch(_){}
  }

  /* --- Inject extra controls into 設定 card --- */
  function el(tag, attrs={}, kids=[]){
    const n = document.createElement(tag);
    Object.entries(attrs).forEach(([k,v])=>{
      if(k==='class') n.className = v;
      else if(k==='text') n.textContent = v;
      else if(k==='html') n.innerHTML = v;
      else n.setAttribute(k, v);
    });
    kids.forEach(k => n.appendChild(k));
    return n;
  }

  const settingsCard = (function(){
    const cards = document.querySelectorAll('.dockGrid .card');
    return cards && cards[0] ? cards[0] : null;
  })();
  if(settingsCard){
    // theme
    const themeField = el('div', {class:'field row wrap'});
    themeField.appendChild(el('label', {text:'テーマ：'}));
    const themeSel = el('select', {id:'themeModeSel'});
    [['auto','自動（OS設定に追従）'],['light','ライト'],['dark','ダーク']].forEach(([v,txt])=>{
      const o=el('option',{}); o.value=v; o.textContent=txt; if(v===themeModeInit) o.selected=true; themeSel.appendChild(o);
    });
    themeSel.addEventListener('change', ()=>{ SETOPT('themeMode', themeSel.value); applyTheme(themeSel.value); });
    themeField.appendChild(themeSel);

    // board size
    const sizeField = el('div', {class:'field row wrap'});
    sizeField.appendChild(el('label',{text:'盤サイズ：'}));
    const sizeRange = el('input', {type:'range', min:'34', max:'72', step:'1', id:'cellSizeRange'});
    const sizeLock = el('label', {class:'small'} , [el('input',{type:'checkbox', id:'lockCellSizeChk'}), document.createTextNode(' サイズ固定（ウィンドウに合わせない）')]);
    const sizeInit = OPT('cellSize', null);
    const lockInit = OPT('lockCell', false);
    if(sizeInit) sizeRange.value = String(sizeInit);
    sizeField.appendChild(sizeRange);
    sizeField.appendChild(sizeLock);
    settingsCard.appendChild(themeField);
    settingsCard.appendChild(sizeField);

    // auto-next + vibrate
    const autoField = el('div', {class:'field row wrap'});
    const autoChk = el('input', {type:'checkbox', id:'autoNextChk'});
    autoChk.checked = !!OPT('autoNext', false);
    const autoLbl = el('label', {class:'small'}, [autoChk, document.createTextNode(' 成功後に自動で次へ')]);
    const secInput = el('input', {type:'number', id:'autoNextSec', min:'0.5', step:'0.1', placeholder:'秒'});
    secInput.value = String(OPT('autoNextSec', 1.6));
    autoField.appendChild(autoLbl);
    autoField.appendChild(el('span',{class:'small', text:' 待ち時間（秒）：'}));
    autoField.appendChild(secInput);

    const vibrChk = el('input', {type:'checkbox', id:'vibrateChk'});
    vibrChk.checked = !!OPT('vibrate', false);
    const vibrLbl = el('label', {class:'small'}, [vibrChk, document.createTextNode(' ミス時に振動（対応端末）')]);
    autoField.appendChild(el('span',{style:'width:10px;display:inline-block;'}));
    autoField.appendChild(vibrLbl);

    // hotkey help
    const hkBtn = el('span', {class:'inline-help', text:'ショートカット一覧'});
    hkBtn.addEventListener('click', ()=>{
      alert([
        'ショートカット：',
        '  N：次の問題を出題',
        '  R：今の問題をもう一度',
        '  L：期待手ハイライトの切替',
        '  M：マス内座標の切替',
        '  S：効果音の切替',
        '  O：両方を自分で打つの切替',
        '  K：棋譜一覧を開く',
        '  Esc：祝福画面／一覧を閉じる',
        '  ← / →：確認モードで1手戻る／進む（既存機能）',
      ].join('\n'));
    });
    autoField.appendChild(el('span',{style:'width:10px;display:inline-block;'}));
    autoField.appendChild(hkBtn);

    settingsCard.appendChild(autoField);

    // SRS
    const srsField = el('div', {class:'field row wrap'});
    const srsChk = el('input', {type:'checkbox', id:'enableSrsChk'});
    srsChk.checked = !!OPT('srsEnabled', true);
    const srsLbl = el('label', {class:'small'}, [srsChk, document.createTextNode(' SRS（間隔反復）を有効化')]);
    const srsBtn = el('button', {class:'ghost', id:'srsInitBtn', text:'SRS初期化（この小フォルダ）'});
    const dueView = el('span', {class:'small', id:'srsDueView', text:'今日のSRS期限：—'});
    srsField.appendChild(srsLbl);
    srsField.appendChild(srsBtn);
    srsField.appendChild(dueView);
    settingsCard.appendChild(srsField);

    // Insert SRS pick mode
    try{
      const already = Array.from(pickModeEl.options).some(o => o.value==='SRS_DUE');
      if(!already){
        const opt = document.createElement('option'); opt.value='SRS_DUE'; opt.textContent='SRS（期限順）';
        pickModeEl.appendChild(opt);
      }
    }catch(_){}

    // Persist handlers
    sizeRange.addEventListener('input', ()=>{
      const v = parseInt(sizeRange.value,10);
      document.documentElement.style.setProperty('--cell', v + 'px');
      SETOPT('cellSize', v);
    });
    const lockCb = sizeLock.querySelector('input');
    lockCb.checked = !!lockInit;
    lockCb.addEventListener('change', ()=>{
      SETOPT('lockCell', !!lockCb.checked);
      window.fitBoardToViewport(); // re-apply
    });
    autoChk.addEventListener('change', ()=> SETOPT('autoNext', !!autoChk.checked));
    secInput.addEventListener('change', ()=> SETOPT('autoNextSec', parseFloat(secInput.value||'1.6')||1.6));
    vibrChk.addEventListener('change', ()=> SETOPT('vibrate', !!vibrChk.checked));
    srsChk.addEventListener('change', ()=> SETOPT('srsEnabled', !!srsChk.checked));
    srsBtn.addEventListener('click', ()=>{
      const pk = currentPath();
      const arr = store.kifuByPath[pk] || [];
      const t0 = Date.now();
      arr.forEach(k => { ensureSrs(k, t0); });
      saveStore(store);
      updateSrsDueCount();
      showToast('SRSフィールドを初期化しました');
      try{ renderKifuList(); }catch(_){}
    });

    // expose elements for other functions
    window._v8 = window._v8 || {};
    _v8.ui = { themeSel, sizeRange, lockCb, autoChk, secInput, vibrChk, srsChk, dueView };
  }

  /* Respect size lock when viewport fits */
  if(typeof window.fitBoardToViewport === 'function'){
    const origFit = window.fitBoardToViewport;
    window.fitBoardToViewport = function(){
      if(OPT('lockCell', false) && OPT('cellSize', null)){
        const v = OPT('cellSize', 56);
        document.documentElement.style.setProperty('--cell', v + 'px');
        return;
      }
      origFit();
      // sync slider if present
      try{
        const v = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'))||56;
        if(_v8 && _v8.ui && _v8.ui.sizeRange) _v8.ui.sizeRange.value = String(v);
      }catch(_){}
    }
    // initial apply
    if(OPT('lockCell', false) && OPT('cellSize', null)){
      document.documentElement.style.setProperty('--cell', OPT('cellSize',56) + 'px');
    }
  }

  /* --- Count overlay on board --- */
  (function(){
    const elWrap = document.getElementById('boardWrap');
    if(!elWrap) return;
    const overlay = document.createElement('div');
    overlay.className = 'count-overlay';
    overlay.id = 'countOverlay';
    elWrap.appendChild(overlay);
    function update(){
      try{
        let b=0,w=0;
        for(let r=0;r<8;r++) for(let c=0;c<8;c++){
          if(board[r][c]===1) b++; else if(board[r][c]===-1) w++;
        }
        overlay.textContent = `黒 〇 ${b}　| 白 ● ${w}　| 手番：${currentPlayer===1?'黒':'白'}`;
      }catch(_){}
    }
    if(typeof window.renderBoard === 'function'){
      const orig = window.renderBoard;
      window.renderBoard = function(){
        orig(); update();
      };
      // initial
      update();
    }else{
      update();
    }
  })();

  /* --- Vibration on mistakes --- */
  if(typeof window.playSound === 'function'){
    const orig = window.playSound;
    window.playSound = function(type){
      orig(type);
      if(type==='ng' && OPT('vibrate', false) && navigator.vibrate){
        try{ navigator.vibrate(120); }catch(_){}
      }
    };
  }

  /* --- Auto-next on celebrate & SRS update --- */
  const SRS_INTERVALS = [0,1,2,4,7,15]; // days by level (index=level)
  function ensureSrs(k, baseNow){
    if(!k) return;
    if(typeof k.srsLevel!=='number' || !(k.srsLevel>=1)) k.srsLevel = 1;
    if(typeof k.srsDue!=='number' || !isFinite(k.srsDue)) k.srsDue = baseNow || Date.now();
  }
  function srsUpdateOnFinish(k, mistakes){
    if(!_v8 || !_v8.ui || !_v8.ui.srsChk || !_v8.ui.srsChk.checked) return;
    ensureSrs(k);
    if(mistakes===0){
      k.srsLevel = Math.min(k.srsLevel + 1, 5);
    }else{
      k.srsLevel = 1;
    }
    const days = SRS_INTERVALS[k.srsLevel];
    k.srsDue = Date.now() + days*dayMs;
  }
  function updateSrsDueCount(){
    try{
      const pk = currentPath();
      const arr = getEnabledArrCurrent();
      const due = (arr||[]).filter(k => (k.srsDue||0) <= Date.now()).length;
      if(_v8 && _v8.ui && _v8.ui.dueView) _v8.ui.dueView.textContent = `今日のSRS期限：${due}件`;
    }catch(_){}
  }
  window.updateSrsDueCount = updateSrsDueCount;

  let autoNextTimer = null;
  function cancelAutoNext(){
    if(autoNextTimer){ clearInterval(autoNextTimer._interval); clearTimeout(autoNextTimer._timeout); autoNextTimer=null; }
  }
  if(typeof window.showCelebrate === 'function'){
    const origShow = window.showCelebrate;
    window.showCelebrate = function(total, mistakes){
      origShow(total, mistakes);
      // SRS
      try{
        const pk = currentPath();
        const arr = store.kifuByPath[pk] || [];
        const k = arr.find(x => x.id===currentKifuId);
        if(k){ srsUpdateOnFinish(k, mistakes); saveStore(store); updateSrsDueCount(); }
      }catch(_){}
      // Auto-next
      try{
        cancelAutoNext();
        const auto = OPT('autoNext', false);
        const delay = Math.max(0.5, parseFloat(OPT('autoNextSec', 1.6)||1.6));
        if(auto && mistakes===0){
          let remain = delay;
          const baseMsg = document.getElementById('celebrateMsg')?.textContent || '';
          const msgEl = document.getElementById('celebrateMsg');
          function tick(){
            if(!msgEl) return;
            msgEl.textContent = `${baseMsg}　（${remain.toFixed(1)}秒後に次へ）`;
            remain = Math.max(0, remain - 0.1);
          }
          tick();
          autoNextTimer = {
            _interval: setInterval(tick, 100),
            _timeout: setTimeout(()=>{ try{ document.getElementById('nextBtn').click(); }catch(_){} cancelAutoNext(); }, delay*1000)
          };
        }
      }catch(_){}
    };
  }
  // cancel on user actions
  ['repeatBtn','nextBtn','resumeBtn','closeModalBtn','startBtn','resetBtn'].forEach(id=>{
    const n = document.getElementById(id);
    if(n) n.addEventListener('click', cancelAutoNext, {capture:true});
  });
  window.addEventListener('keydown', e=>{ if(e.key==='Escape') cancelAutoNext(); }, {capture:true});

  // Update due count on init / path changes
  if(typeof window.updateCountsAndPath === 'function'){
    const orig = window.updateCountsAndPath;
    window.updateCountsAndPath = function(){
      orig(); updateSrsDueCount();
    };
  }else{
    updateSrsDueCount();
  }

  /* --- Pick by SRS mode --- */
  if(typeof window.pickKifu === 'function'){
    const origPick = window.pickKifu;
    window.pickKifu = function(){
      const mode = pickModeEl.value;
      if(mode==='SRS_DUE'){
        const pk = currentPath();
        const enabledArr = getEnabledArrCurrent();
        const nowT = Date.now();
        const due = enabledArr.filter(k => (k.srsDue||0) <= nowT);
        if(due.length){
          // earliest due, and if tie use most mistakes
          due.sort((a,b)=> (a.srsDue||0)-(b.srsDue||0) || ((b.stats?.mistakes||0) - (a.stats?.mistakes||0)));
          return due[0];
        }else if(enabledArr.length){
          enabledArr.sort((a,b)=> (a.srsDue||Infinity)-(b.srsDue||Infinity));
          showToast('本日期限のSRSはありません。最も近いものを出題します');
          return enabledArr[0];
        }else{
          alert('出題オンの棋譜がありません（SRS）');
          return null;
        }
      }
      return origPick();
    };
  }

  /* --- Keyboard shortcuts --- */
  window.addEventListener('keydown', (e)=>{
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
    if(tag==='input' || tag==='textarea' || tag==='select') return;
    if(e.key==='n' || e.key==='N'){ e.preventDefault(); try{ startTraining(); }catch(_){ } }
    else if(e.key==='r' || e.key==='R'){ e.preventDefault(); try{ if(currentKifuId) startTrainingWithKifuId(currentKifuId); }catch(_){} }
    else if(e.key==='l' || e.key==='L'){ e.preventDefault(); try{ toggleHintEl.checked = !toggleHintEl.checked; renderBoard(); }catch(_){} }
    else if(e.key==='m' || e.key==='M'){ e.preventDefault(); try{ toggleMiniCoordEl.checked = !toggleMiniCoordEl.checked; renderBoard(); }catch(_){} }
    else if(e.key==='s' || e.key==='S'){ e.preventDefault(); try{ toggleSoundEl.checked = !toggleSoundEl.checked; }catch(_){} }
    else if(e.key==='o' || e.key==='O'){ e.preventDefault(); try{ toggleSelfBothEl.checked = !toggleSelfBothEl.checked; toggleSelfBothEl.dispatchEvent(new Event('change')); }catch(_){} }
    else if(e.key==='k' || e.key==='K'){ e.preventDefault(); try{ openKifuModal(); }catch(_){} }
    else if(e.key==='Escape'){ try{ hideCelebrate(); closeKifuModal(); }catch(_){} }
  });

  /* --- Extend kifu modal rows: Name + Tags + SRS info & DnD reorder --- */
  function aggregateAllTagsForPath(pk){
    const arr = store.kifuByPath[pk] || [];
    const set = new Set();
    arr.forEach(k => (k.tags||[]).forEach(t => set.add(String(t||'').trim())));
    return Array.from(set).filter(Boolean).sort((a,b)=> a.localeCompare(b));
  }
  function enhanceKifuRows(){
    const pk = currentPath();
    const allTags = aggregateAllTagsForPath(pk);
    const rows = document.querySelectorAll('#kifuList .klist-row');
    rows.forEach(row => {
      if(row.dataset.v8enh==='1') return;
      row.dataset.v8enh = '1';
      const id = row.dataset.id;
      const arr = store.kifuByPath[pk] || [];
      const k = arr.find(x => x.id===id);
      if(!k) return;
      if(!Array.isArray(k.tags)) k.tags = [];

      const info = row.querySelector('.kinfo');
      // Name field
      const nameWrap = document.createElement('div');
      nameWrap.className = 'kifu-wrap';
      const nameLabel = document.createElement('div'); nameLabel.className='label'; nameLabel.textContent = '名前';
      const nameInput = document.createElement('input'); nameInput.type='text'; nameInput.placeholder='問題名（任意）'; nameInput.value = k.name || '';
      nameInput.addEventListener('change', ()=>{ k.name = nameInput.value.trim(); saveStore(store); });
      const nameBtns = document.createElement('div'); nameBtns.className='kifu-btns';
      const nameClr = document.createElement('button'); nameClr.className='ghost'; nameClr.textContent='クリア';
      nameClr.addEventListener('click', ()=>{ nameInput.value=''; k.name=''; saveStore(store); showToast('名前をクリアしました'); });
      nameBtns.appendChild(nameClr);
      nameWrap.appendChild(nameLabel); nameWrap.appendChild(nameInput); nameWrap.appendChild(nameBtns);
      info.appendChild(nameWrap);

      // Tags field
      const tagWrap = document.createElement('div'); tagWrap.className='kifu-wrap';
      const tagLabel = document.createElement('div'); tagLabel.className='label'; tagLabel.textContent='タグ';
      const chipBox = document.createElement('div'); chipBox.className='chips';
      const tagInput = document.createElement('input'); tagInput.type='text'; tagInput.placeholder='タグを追加（Enterで確定／空白・カンマ区切り）';
      const tagBtns = document.createElement('div'); tagBtns.className='kifu-btns';

      const addBtn = document.createElement('button'); addBtn.className='ghost'; addBtn.textContent='追加';
      function renderChips(){
        chipBox.innerHTML='';
        (k.tags||[]).forEach((t, idx)=>{
          const chip = document.createElement('span'); chip.className='chip';
          const x = document.createElement('span'); x.className='x'; x.textContent='×';
          x.addEventListener('click', ()=>{ k.tags.splice(idx,1); saveStore(store); renderChips(); });
          chip.appendChild(document.createTextNode('#'+t));
          chip.appendChild(x);
          chipBox.appendChild(chip);
        });
      }
      function addTagsFromInput(){
        const raw = tagInput.value||'';
        const parts = raw.split(/[,\s]+/).map(s=>s.trim()).filter(Boolean);
        if(!parts.length) return;
        const set = new Set(k.tags||[]);
        parts.forEach(p => set.add(p));
        k.tags = Array.from(set);
        tagInput.value='';
        saveStore(store);
        renderChips();
      }
      addBtn.addEventListener('click', addTagsFromInput);
      tagInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); addTagsFromInput(); } });
      const clearBtn = document.createElement('button'); clearBtn.className='ghost'; clearBtn.textContent='全削除';
      clearBtn.addEventListener('click', ()=>{ k.tags=[]; saveStore(store); renderChips(); });

      tagBtns.appendChild(addBtn);
      tagBtns.appendChild(clearBtn);
      tagWrap.appendChild(tagLabel);
      const rightCol = document.createElement('div');
      const sugg = document.createElement('div'); sugg.className='small muted'; 
      if(allTags.length) sugg.textContent = '候補：' + allTags.map(t=>'#'+t).join(' ');
      rightCol.appendChild(chipBox);
      rightCol.appendChild(tagInput);
      rightCol.appendChild(sugg);
      tagWrap.appendChild(rightCol);
      tagWrap.appendChild(tagBtns);
      info.appendChild(tagWrap);

      // SRS info (small)
      const srsInfo = document.createElement('div'); srsInfo.className='small muted';
      function refreshSrsInfo(){
        const due = (k.srsDue? new Date(k.srsDue): null);
        const dueStr = due ? `${due.getFullYear()}-${String(due.getMonth()+1).padStart(2,'0')}-${String(due.getDate()).padStart(2,'0')}` : '—';
        srsInfo.textContent = `SRS：L${k.srsLevel||1} ／ next=${dueStr}`;
        if(due && k.srsDue <= Date.now()){ srsInfo.style.color = '#b00020'; } else { srsInfo.style.color = ''; }
      }
      refreshSrsInfo();
      info.appendChild(srsInfo);

      // DnD reorder (only when sort=INDEX & filters off)
      row.draggable = true;
      row.addEventListener('dragstart', (e)=>{
        row.classList.add('dragging'); e.dataTransfer.effectAllowed='move'; e.dataTransfer.setData('text/plain', id);
      });
      row.addEventListener('dragend', ()=>{
        row.classList.remove('dragging'); document.querySelectorAll('#kifuList .klist-row').forEach(r=>r.classList.remove('drop-before','drop-after'));
      });
      row.addEventListener('dragover', (e)=>{
        const condOK = document.getElementById('sortBy')?.value==='INDEX'
                    && document.getElementById('sortDir')?.value==='ASC'
                    && (document.getElementById('searchInput')?.value||'').trim()===''
                    && (!window._v8TagFilter || window._v8TagFilter.words.length===0);
        if(!condOK) return;
        e.preventDefault();
        const rect = row.getBoundingClientRect();
        const after = (e.clientY - rect.top) > (rect.height/2);
        row.classList.toggle('drop-after', after);
        row.classList.toggle('drop-before', !after);
      });
      row.addEventListener('drop', (e)=>{
        const condOK = document.getElementById('sortBy')?.value==='INDEX'
                    && document.getElementById('sortDir')?.value==='ASC'
                    && (document.getElementById('searchInput')?.value||'').trim()===''
                    && (!window._v8TagFilter || window._v8TagFilter.words.length===0);
        if(!condOK) return;
        const dragId = e.dataTransfer.getData('text/plain');
        const targetId = id;
        const after = row.classList.contains('drop-after');
        commitKifuReorder(dragId, targetId, after);
      });
    });
  }
  function commitKifuReorder(dragId, targetId, placeAfter){
    const pk = currentPath();
    const baseArr = store.kifuByPath[pk] || [];
    const from = baseArr.findIndex(k=>k.id===dragId);
    const toBase = baseArr.findIndex(k=>k.id===targetId);
    if(from<0 || toBase<0) return;
    let to = toBase + (placeAfter?1:0);
    if(from < to) to--;
    if(from === to) return;
    const [item] = baseArr.splice(from, 1);
    baseArr.splice(to, 0, item);
    baseArr.forEach((k, i)=> k._idx = i);
    saveStore(store);
    try{ renderKifuList(); }catch(_){}
    showToast('表示順（追加順）を並べ替えました');
  }

  // patch renderKifuList to enhance after original
  if(typeof window.renderKifuList === 'function'){
    const orig = window.renderKifuList;
    window.renderKifuList = function(){
      orig();
      try{ enhanceKifuRows(); }catch(_){}
    };
  }

  /* --- Tag filter UI in modal header --- */
  (function(){
    const hdr = document.querySelector('#kifuModal .klist-controls');
    if(!hdr) return;
    const wrap = document.createElement('span');
    wrap.style.display = 'inline-flex'; wrap.style.alignItems='center'; wrap.style.gap='6px'; wrap.style.flexWrap='wrap';
    wrap.style.marginLeft = '8px';
    const lbl = document.createElement('label'); lbl.textContent='タグ：';
    const input = document.createElement('input'); input.id='tagFilterInput'; input.placeholder='例) 攻め 定石'; input.style.minWidth='160px';
    const orWrap = document.createElement('label'); orWrap.className='small';
    const orChk = document.createElement('input'); orChk.type='checkbox'; orChk.id='tagOrMode';
    orWrap.appendChild(orChk); orWrap.appendChild(document.createTextNode(' ORで絞り込み'));
    const clear = document.createElement('button'); clear.className='ghost'; clear.textContent='タグ解除';

    hdr.appendChild(lbl); hdr.appendChild(input); hdr.appendChild(orWrap); hdr.appendChild(clear);

    const st = { words: [], or: false };
    window._v8TagFilter = st;

    function apply(){
      st.words = (input.value||'').split(/\s+/).map(s=>s.trim().toLowerCase()).filter(Boolean);
      st.or = !!orChk.checked;
      renderKifuList();
    }
    input.addEventListener('input', apply);
    orChk.addEventListener('change', apply);
    clear.addEventListener('click', ()=>{ input.value=''; orChk.checked=false; apply(); });

    // override getSortedArray to append tag filter
    if(typeof window.getSortedArray === 'function'){
      const orig = window.getSortedArray;
      window.getSortedArray = function(pk){
        let arr = orig(pk);
        try{
          const words = st.words;
          if(words.length){
            arr = arr.filter(k => {
              const tags = (k.tags||[]).map(t => String(t||'').toLowerCase());
              if(!tags.length) return false;
              if(st.or) return words.some(w => tags.includes(w));
              return words.every(w => tags.includes(w));
            });
          }
        }catch(_){}
        return arr;
      };
    }
  })();

  /* --- Allow editing Big folder default color in modal --- */
  (function(){
    const row = document.getElementById('renameBigRow');
    if(!row) return;
    const g = document.createElement('div');
    g.className = 'row wrap';
    g.style.marginTop = '6px';
    const metaLbl = document.createElement('label'); metaLbl.textContent = '持色（既定）：';
    g.appendChild(metaLbl);
    [['','指定なし'],['BLACK','黒'],['WHITE','白']].forEach(([val,txt])=>{
      const lab = document.createElement('label'); lab.className='small';
      const r = document.createElement('input'); r.type='radio'; r.name='editBigColor'; r.value=val;
      lab.appendChild(r); lab.appendChild(document.createTextNode(' '+txt)); g.appendChild(lab);
    });
    row.appendChild(g);

    function sync(){
      const big = currentBig(); if(!big) return;
      const meta = (store.bigFolders||[]).find(b=>b.name===big);
      const v = meta && meta.defaultColor ? meta.defaultColor : '';
      const radios = row.querySelectorAll('input[name="editBigColor"]');
      radios.forEach(r => r.checked = (r.value===v));
    }
    function save(){
      const big = currentBig(); if(!big) return;
      const meta = (store.bigFolders||[]).find(b=>b.name===big);
      if(!meta) return;
      const r = row.querySelector('input[name="editBigColor"]:checked');
      meta.defaultColor = r ? (r.value||'') : '';
      saveStore(store);
      showToast('持色（既定）を更新しました');
      refreshSmallSelect();
    }
    row.addEventListener('change', (e)=>{
      const t = e.target;
      if(t && t.name==='editBigColor'){ save(); }
    });
    // sync on open modal
    if(typeof window.openKifuModal === 'function'){
      const orig = window.openKifuModal;
      window.openKifuModal = function(){
        orig();
        sync();
      };
    }
  })();

})(); // end v8 addon IIFE

</script>
<script>
/* ===== v9 Addons by ChatGPT (2025-10-19) ===== */
(function(){
  // local opt store helpers (independent from v8 scope)
  const OPT = (k, d) => { try{ const v = localStorage.getItem(STORE_PREFIX + 'opt9_' + k); return v==null?d:JSON.parse(v);}catch(_){ return d; } };
  const SETOPT = (k, v) => { try{ localStorage.setItem(STORE_PREFIX + 'opt9_' + k, JSON.stringify(v)); }catch(_){ } };

  // --- Bump title to v9
  try{
    // [refactor] removed version bump
    // [refactor] removed version bump
  }catch(_){}

  // --- Small DOM helpers
  
  // local DOM helper (v9 scope)
  function el(tag, attrs={}, kids=[]){
    const n = document.createElement(tag);
    if(attrs && typeof attrs === 'object'){
      try{
        Object.entries(attrs).forEach(([k,v])=>{
          if(k==='class') n.className = v;
          else if(k==='text') n.textContent = v;
          else if(k==='html') n.innerHTML = v;
          else n.setAttribute(k, v);
        });
      }catch(_){}
    }
    (kids||[]).forEach(k => { try{ n.appendChild(k); }catch(_){ } });
    return n;
  }

  

  // ---------- UI injections ----------
  // ② 設定カードを取得（dockGridの最初のcard）
  const settingsCard = (function(){
    const cards = document.querySelectorAll('.dockGrid .card');
    return cards && cards[0] ? cards[0] : null;
  })();

  // Heatmap toggle + Symmetry + Random Range
  if(settingsCard){
    // Heatmap
    const heatField = el('div', {class:'field row wrap'});
    const heatChk = el('input', {type:'checkbox', id:'heatChk'});
    heatChk.checked = !!OPT('heatOn', false);
    const heatLbl = el('label', {class:'small'}, [heatChk, document.createTextNode(' 誤答ヒートマップ（現棋譜／手番別）を表示')]);
    heatField.appendChild(heatLbl);

    // Symmetry
    const symSel = el('select', {id:'symmetrySel'});
    [['NONE','対称変換なし'],['HFLIP','左右反転'],['VFLIP','上下反転'],['ROT180','回転180°'],['RANDOM','ランダム']].forEach(([v,t])=>{
      const o=el('option'); o.value=v; o.textContent=t;
      if(v===OPT('symMode','NONE')) o.selected=true;
      symSel.appendChild(o);
    });
    const symLbl = el('label', {text:' 対称変換：'});
    heatField.appendChild(symLbl);
    heatField.appendChild(symSel);

        settingsCard.appendChild(heatField);

// Persist
    heatChk.addEventListener('change', ()=>{ SETOPT('heatOn', !!heatChk.checked); updateHeatOverlay(); });
    symSel.addEventListener('change', ()=> SETOPT('symMode', symSel.value));
    }

  // ③ キューカードに機能追加
  (function(){
    const cards = document.querySelectorAll('.dockGrid .card');
    const queueCard = cards && cards[1] ? cards[1] : null;
    if(!queueCard) return;
    const field = queueCard.querySelector('.field');
    if(!field) return;

    const row = el('div', {class:'row wrap'});
    const dedupBtn = el('button', {class:'ghost', id:'queueDedupBtn', text:'キュー重複を削除'});
    const shuffleBtn = el('button', {class:'ghost', id:'queueShuffleBtn', text:'キューをシャッフル'});
    row.appendChild(dedupBtn);
    row.appendChild(shuffleBtn);
    field.parentNode.insertBefore(row, field.nextSibling);

    dedupBtn.addEventListener('click', ()=>{
      try{
        const pk = currentPath();
        const q = getQueueByPath(pk).slice();
        const seen = new Set(); const out = [];
        q.forEach(id=>{ if(!seen.has(id)){ seen.add(id); out.push(id); } });
        store.queueByPath[pk] = out; saveStore(store); updateQueueView();
        showToast('キューの重複を削除しました');
      }catch(e){ alert('処理中にエラーが発生しました'); }
    });
    shuffleBtn.addEventListener('click', ()=>{
      try{
        const pk = currentPath();
        const q = getQueueByPath(pk).slice();
        for(let i=q.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [q[i],q[j]]=[q[j],q[i]]; }
        store.queueByPath[pk] = q; saveStore(store); updateQueueView();
        showToast('キューをシャッフルしました');
      }catch(e){ alert('処理中にエラーが発生しました'); }
    });
  })();

  // ① 入出力カードに「この小フォルダのみエクスポート」を追加
  (function(){
    const exportBtn = document.getElementById('exportBtn');
    if(!exportBtn) return;
    const wrapField = exportBtn.closest('.field.row.wrap') || exportBtn.parentNode;
    const btn = el('button', {class:'ghost', id:'exportFolderBtn', text:'エクスポート（この小フォルダのみ）'});
    wrapField.insertBefore(btn, exportBtn.nextSibling);
    btn.addEventListener('click', ()=>{
      const pk = currentPath();
      const payload = {
        type: 'reversi_trainer_folder_export_v1',
        exportedAt: new Date().toISOString(),
        path: pk,
        big: currentBig(),
        small: currentSmall(),
        kifu: (store.kifuByPath[pk]||[]),
        queue: (store.queueByPath[pk]||[])
      };
      const blob = new Blob([JSON.stringify(payload,null,2)], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download = (pk.replaceAll('/','__') || 'folder') + '_export.json';
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 1000);
    });
  })();

  // ---------- Heatmap & mistake logging ----------
  function getCurrentKifuObj(){
    const pk = currentPath();
    const arr = store.kifuByPath[pk] || [];
    return arr.find(x => x.id===currentKifuId) || null;
  }
  function ensureHeatLayer(){
    const cells = document.querySelectorAll('#board .cell');
    cells.forEach(cell => {
      if(!cell.querySelector('.heat')){
        const h = document.createElement('div'); h.className = 'heat';
        const t = document.createElement('div'); t.className = 'cnt';
        h.appendChild(t);
        cell.appendChild(h);
      }
    });
  }
  function updateHeatOverlay(){
    try{
      ensureHeatLayer();
      const wrap = document.getElementById('boardWrap');
      const on = !!OPT('heatOn', false);
      if(wrap) wrap.classList.toggle('heat-on', on);
      if(!on) return;
      const k = getCurrentKifuObj();
      const turnKey = (typeof moveIndex==='number') ? String(moveIndex + 1) : null;
      const map = (k && k.mistakeByTurn && turnKey && k.mistakeByTurn[turnKey]) ? k.mistakeByTurn[turnKey] : {};
      let maxv = 0;
      Object.values(map).forEach(v => { if(v>maxv) maxv = v; });
      const cells = document.querySelectorAll('#board .cell');
      cells.forEach(cell => {
        const coord = cell.getAttribute('data-coord');
        const v = map[coord] || 0;
        const heat = cell.querySelector('.heat');
        if(!heat) return;
        const t = heat.querySelector('.cnt');
        if(v<=0){ heat.style.background = 'transparent'; t.textContent=''; return; }
        const alpha = Math.min(0.15 + 0.35*(v/(maxv||1)), 0.5);
        heat.style.background = 'rgba(220, 32, 32, ' + alpha.toFixed(3) + ')';
        t.textContent = String(v);
      });
    }catch(_){}
  }
  // hook renderBoard to update overlay
  if(typeof window.renderBoard === 'function'){
    const orig = window.renderBoard;
    window.renderBoard = function(){
      orig();
      updateHeatOverlay();
    };
  }

  // hook flashX to log mistakes per coordinate
  if(typeof window.flashX === 'function'){
    const origFX = window.flashX;
    window.flashX = function(cell){
      try{
        if(training && currentKifuId){
          const coord = cell && cell.getAttribute ? cell.getAttribute('data-coord') : null;
          const k = getCurrentKifuObj();
          if(coord && k){
            k.mistakeCounts = k.mistakeCounts || {};
            k.mistakeCounts[coord] = (k.mistakeCounts[coord]||0) + 1;
// per-turn logging for current kifu and turn
k.mistakeByTurn = k.mistakeByTurn || {};
var _turnNum = (typeof moveIndex==='number') ? (moveIndex + 1) : null;
if(_turnNum != null){
  var _key = String(_turnNum);
  var _tm = k.mistakeByTurn[_key] || {};
  _tm[coord] = (_tm[coord]||0) + 1;
  k.mistakeByTurn[_key] = _tm;
}

            saveStore(store);
          }
        }
      }catch(_){}
      origFX(cell);
    };
  }

  // ---------- Symmetry transform & Random range & Timer ----------
  function transformCoord(coord, mode){
    const m = String(coord).trim().toUpperCase().match(/^([A-H])([1-8])$/);
    if(!m) return coord;
    const cols = 'ABCDEFGH';
    let c = cols.indexOf(m[1]);
    let r = parseInt(m[2],10)-1;
    if(mode==='HFLIP' || mode==='ROT180'){ c = 7 - c; }
    if(mode==='VFLIP' || mode==='ROT180'){ r = 7 - r; }
    return cols[c] + String(r+1);
  }
  function transformMoves(moves, mode){
    if(!mode || mode==='NONE') return moves.slice();
    return (moves||[]).map(t => (t==='P' || t==='PASS') ? t : transformCoord(t, mode));
  }
  function pickSymMode(){
    const m = OPT('symMode','NONE');
    if(m==='RANDOM'){
      const cand = ['HFLIP','VFLIP','ROT180'];
      return cand[Math.floor(Math.random()*cand.length)];
    }
    return m;
  }
  window._v9 = window._v9 || {};
  _v9.timerStart = 0;

  if(typeof window.startTrainingCore === 'function'){
    const orig = window.startTrainingCore;
    window.startTrainingCore = function(picked){
      try{
        // symmetry
        const mode = pickSymMode();
        if(mode && mode!=='NONE'){
          const clone = Object.assign({}, picked);
          clone.moves = transformMoves(picked.moves, mode);
          picked = clone;
          setTimeout(()=>{ try{ setStatus(`対称変換：${({HFLIP:'左右反転',VFLIP:'上下反転',ROT180:'回転180°'})[mode]||mode}`); }catch(_){ } }, 10);
        }
      }catch(_){}
      _v9.timerStart = Date.now();
      return orig(picked);
    };
  }

  // hook showCelebrate to append time info and persist best/avg
  if(typeof window.showCelebrate === 'function'){
    const origSC = window.showCelebrate;
    window.showCelebrate = function(total, mistakes){
      origSC(total, mistakes);
      try{
        if(!_v9.timerStart) return;
        const ms = Math.max(0, Date.now() - _v9.timerStart);
        const sec = (ms/1000).toFixed(2);
        const infoBox = document.getElementById('resultInfo');
        if(infoBox){
          const f = document.createElement('div');
          f.className = 'field';
          const lab = document.createElement('label'); lab.className='small'; lab.textContent = '経過時間';
          const p = document.createElement('div'); p.className='small muted'; p.textContent = `${sec} 秒`;
          f.appendChild(lab); f.appendChild(p);
          infoBox.appendChild(f);
        }
        // persist per-kifu time stats
        const pk = currentPath();
        const arr = store.kifuByPath[pk] || [];
        const k = arr.find(x=>x.id===currentKifuId);
        if(k){
          k.stats = k.stats || { attempts:0, solved:0, mistakes:0 };
          k.stats.time = k.stats.time || { bestMs:null, totalMs:0, count:0, lastMs:0, avgMs:0 };
          k.stats.time.lastMs = ms;
          if(mistakes===0){
            k.stats.time.count += 1;
            k.stats.time.totalMs += ms;
            if(k.stats.time.bestMs==null || ms < k.stats.time.bestMs) k.stats.time.bestMs = ms;
            k.stats.time.avgMs = k.stats.time.totalMs / Math.max(1, k.stats.time.count);
          }
          saveStore(store);
        }
      }catch(_){}
    };
  }

  // augment modal rows with stats chips (attempts/solved/mistakes/best time)
  function augmentStatsInModal(){
    try{
      const pk = currentPath();
      const arr = store.kifuByPath[pk] || [];
      document.querySelectorAll('#kifuList .klist-row').forEach(row => {
        if(row.dataset.v9stats==='1') return;
        const id = row.getAttribute('data-id');
        const k = arr.find(x=>x.id===id);
        if(!k) return;
        const info = row.querySelector('.kinfo');
        if(!info) return;
        const line = document.createElement('div');
        line.className = 'chips';
        const ch = (txt)=>{ const c=document.createElement('span'); c.className='chip'; c.textContent=txt; return c; };
        const t = k.stats||{}; const tm = (t.time||{});
        line.appendChild(ch(`▶ ${t.attempts||0}`));
        line.appendChild(ch(`✓ ${t.solved||0}`));
        line.appendChild(ch(`× ${t.mistakes||0}`));
        if(tm.bestMs!=null) line.appendChild(ch(`⏱ ${(tm.bestMs/1000).toFixed(2)}s`));
        info.appendChild(line);
        row.dataset.v9stats = '1';
      });
    }catch(_){}
  }
  if(typeof window.renderKifuList === 'function'){
    const orig = window.renderKifuList;
    window.renderKifuList = function(){
      orig();
      try{ augmentStatsInModal(); }catch(_){}
    };
  }

  // ---------- PNG download of board ----------
  (function(){
    const boardCard = document.querySelector('.rightDock .card');
    if(!boardCard) return;
    const bar = boardCard.querySelector('.row-just');
    if(!bar) return;
    const btn = el('button', {class:'ghost', id:'pngBtn', text:'盤面をPNG保存'});
    bar.appendChild(btn);
    btn.addEventListener('click', ()=>{
      try{
        const cell = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell')) || 56;
        const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 2;
        const N = 8;
        const size = N*cell + (N-1)*gap;
        const cvs = document.createElement('canvas');
        cvs.width = cvs.height = size;
        const ctx = cvs.getContext('2d');
        // board
        ctx.fillStyle = '#0a5a2a'; ctx.fillRect(0,0,size,size);
        for(let r=0;r<N;r++){
          for(let c=0;c<N;c++){
            const x = c*(cell+gap);
            const y = r*(cell+gap);
            ctx.fillStyle = '#1e7a3b';
            const rad = 6;
            // rounded rect
            const w=cell,h=cell;
            ctx.beginPath();
            ctx.moveTo(x+rad, y);
            ctx.arcTo(x+w, y, x+w, y+h, rad);
            ctx.arcTo(x+w, y+h, x, y+h, rad);
            ctx.arcTo(x, y+h, x, y, rad);
            ctx.arcTo(x, y, x+w, y, rad);
            ctx.closePath();
            ctx.fill();
          }
        }
        // discs from 'board' array
        for(let r=0;r<N;r++){
          for(let c=0;c<N;c++){
            const v = (window.board && board[r]) ? board[r][c] : 0;
            if(!v) continue;
            const x = c*(cell+gap) + cell/2;
            const y = r*(cell+gap) + cell/2;
            const radius = cell*0.41;
            ctx.beginPath(); ctx.arc(x,y,radius,0,Math.PI*2);
            ctx.fillStyle = (v===1) ? '#111' : '#eee';
            ctx.fill();
            // simple highlight
            ctx.globalAlpha = 0.15;
            ctx.beginPath(); ctx.arc(x - radius*0.35, y - radius*0.35, radius*0.65, 0, Math.PI*2);
            ctx.fillStyle = '#fff'; ctx.fill();
            ctx.globalAlpha = 1;
          }
        }
        const url = cvs.toDataURL('image/png');
        const a = document.createElement('a'); a.href=url;
        const dt = new Date();
        const y = dt.getFullYear(), m = String(dt.getMonth()+1).padStart(2,'0'), d=String(dt.getDate()).padStart(2,'0');
        const hh = String(dt.getHours()).padStart(2,'0'), mm=String(dt.getMinutes()).padStart(2,'0'), ss=String(dt.getSeconds()).padStart(2,'0');
        a.download = `reversi_board_${y}${m}${d}_${hh}${mm}${ss}.png`;
        document.body.appendChild(a); a.click(); a.remove();
      }catch(e){ alert('PNGの作成に失敗しました'); }
    });
  })();

  // ensure heat overlay present once DOM is ready
  document.addEventListener('DOMContentLoaded', ()=>{ setTimeout(updateHeatOverlay, 50); });

})(); // end v9
</script>
<!-- ===== v10 Addons by ChatGPT (2025-10-19) ===== -->
<style>
/* v10: timer overlay, recorder overlay, dropzone */
.timer-overlay{
  position:absolute; left:10px; top:10px; z-index:7;
  background: rgba(0,0,0,0.55); color:#fff; padding:4px 8px; border-radius:8px;
  font-size:.90rem; font-variant-numeric: tabular-nums; pointer-events:none;
}
.rec-layer{
  position:absolute; inset:0; background: rgba(0,0,0,.45);
  display:none; align-items:center; justify-content:center; z-index:20;
}
.rec-layer .panel{
  background: rgba(255,255,255,0.98); color:#111;
  width:min(600px,92vw); max-height:86vh; overflow:auto;
  border-radius:16px; padding:16px; box-shadow:0 10px 40px rgba(0,0,0,.35);
}
body.theme-dark .rec-layer .panel{ background: rgba(21,26,31,0.98); color:#e7ebf3; }
.rec-layer .panel h3{ margin:0 0 8px; font-size:1.12rem; }
.rec-layer .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
.rec-layer .field{ display:grid; gap:6px; margin:8px 0; }
.rec-layer input[type="text"], .rec-layer textarea, .rec-layer input[type="number"]{
  width:100%; font-size:.95rem; padding:6px 8px; border:1px solid #d6d6d6; border-radius:6px;
  background: var(--card-bg); color: var(--fg);
}
.rec-layer .actions{ display:flex; gap:8px; justify-content:flex-end; flex-wrap:wrap; }
.dropzone{
  border:2px dashed #b9c2ff; border-radius:12px; padding:10px; text-align:center;
  background:#fbfcff; color:#174199; font-size:.9rem;
}
.dropzone.drag{ background:#eef3ff; }
.small.mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Roboto Mono", monospace; }
</style>
<script>
(function(){
  const OPT = (k, d) => { try{ const v = localStorage.getItem(STORE_PREFIX + 'opt10_' + k); return v==null?d:JSON.parse(v);}catch(_){ return d; } };
  const SETOPT = (k, v) => { try{ localStorage.setItem(STORE_PREFIX + 'opt10_' + k, JSON.stringify(v)); }catch(_){ } };

  // ---- Version bump ----
  try{
    // [refactor] removed version bump
    // [refactor] removed version bump
  }catch(_){}

  // ---- Topbar: global SRS due count ----
  (function(){
    try{
      const topbar = document.querySelector('.topbar');
      if(topbar && !document.getElementById('globalSrsDue')){
        const span = document.createElement('span');
        span.className = 'stat';
        span.innerHTML = 'SRS期限（全体）：<b id="globalSrsDue">0</b>';
        topbar.appendChild(span);
      }
      function compute(){
        try{
          const now = Date.now();
          let cnt = 0;
          const all = store && store.kifuByPath ? store.kifuByPath : {};
          Object.values(all).forEach(arr=>{
            (arr||[]).forEach(k=>{
              if(k && k.enabled!==false && typeof k.srsDue==='number' && k.srsDue <= now) cnt++;
            });
          });
          const el = document.getElementById('globalSrsDue'); if(el) el.textContent = String(cnt);
        }catch(_){}
      }
      // wrap saveStore to recompute
      if(typeof window.saveStore === 'function' && !window._v10_save_wrapped){
        const orig = window.saveStore;
        window.saveStore = function(obj){ try{ orig(obj); }finally{ try{ compute(); }catch(_){} } };
        window._v10_save_wrapped = true;
      }
      compute();
      // also recompute on path updates
      if(typeof window.updateCountsAndPath === 'function'){
        const origU = window.updateCountsAndPath;
        window.updateCountsAndPath = function(){ origU(); compute(); };
      }
      window._v10_computeGlobalSrsDue = compute;
    }catch(_){}
  })();

  // ---- Enhance count overlay: add legal-move count & empty ----
  (function(){
    function updatePlus(){
      try{
        let b=0,w=0,empty=0;
        for(let r=0;r<8;r++) for(let c=0;c<8;c++){
          if(board[r][c]===1) b++; else if(board[r][c]===-1) w++; else empty++;
        }
        const LM = legalMoves(board, currentPlayer);
        const el = document.getElementById('countOverlay');
        if(el){
          el.textContent = `黒 〇 ${b}　| 白 ● ${w}　| 手番：${currentPlayer===1?'黒':'白'}　| 合法手：${LM.length}　| 空：${empty}`;
        }
      }catch(_){}
    }
    if(typeof window.renderBoard === 'function'){
      const orig = window.renderBoard;
      window.renderBoard = function(){ orig(); updatePlus(); };
    }else{
      updatePlus();
    }
  })();

  // ---- Settings card reference ----
  const settingsCard = (function(){
    const cards = document.querySelectorAll('.dockGrid .card');
    return cards && cards[0] ? cards[0] : null;
  })();

  // ---- Time Attack countdown ----
  const timer = { id: null, end: 0, overlay:null };
  (function(){
    const wrap = document.getElementById('boardWrap');
    if(wrap && !document.getElementById('timerOverlay')){
      const o = document.createElement('div'); o.id='timerOverlay'; o.className='timer-overlay'; o.style.display='none';
      wrap.appendChild(o); timer.overlay = o;
    }
    if(settingsCard){
      const field = document.createElement('div'); field.className='field row wrap';
      const chk = document.createElement('input'); chk.type='checkbox'; chk.id='countdownEnable';
      chk.checked = !!OPT('countdownEnable', false);
      const lbl = document.createElement('label'); lbl.className='small';
      lbl.appendChild(chk); lbl.appendChild(document.createTextNode(' タイムアタック（カウントダウン）'));
      const sec = document.createElement('input'); sec.type='number'; sec.id='countdownSecIn'; sec.min='1'; sec.step='1';
      sec.placeholder = '秒'; sec.value = String(OPT('countdownSec', 30));
      field.appendChild(lbl);
      field.appendChild(document.createTextNode(' 秒：'));
      field.appendChild(sec);
      settingsCard.appendChild(field);
      chk.addEventListener('change', ()=> SETOPT('countdownEnable', !!chk.checked));
      sec.addEventListener('change', ()=> SETOPT('countdownSec', Math.max(1, parseInt(sec.value||'30',10))));
    }
    function stop(){
      if(timer.id){ clearInterval(timer.id); timer.id=null; }
      if(timer.overlay){ timer.overlay.style.display='none'; }
    }
    function start(sec){
      stop();
      if(!timer.overlay) return;
      timer.end = Date.now() + Math.max(1, sec)*1000;
      timer.overlay.style.display='block';
      function tick(){
        const remain = Math.max(0, timer.end - Date.now());
        const s = (remain/1000);
        timer.overlay.textContent = '⏱ 残り ' + s.toFixed(1) + ' 秒';
        if(remain<=0){
          try{ if(typeof playSound==='function') playSound('ng'); }catch(_){}
          clearInterval(timer.id); timer.id=null;
          timer.overlay.textContent = '⏱ 時間切れ';
          setTimeout(()=>{ if(timer.overlay) timer.overlay.style.display='none'; }, 1500);
        }
      }
      tick();
      timer.id = setInterval(tick, 100);
    }
    // hook startTrainingCore and showCelebrate/resetBtn to manage timer
    if(typeof window.startTrainingCore === 'function'){
      const orig = window.startTrainingCore;
      window.startTrainingCore = function(picked){
        const out = orig(picked);
        try{
          if(OPT('countdownEnable', false)){
            const sec = Math.max(1, OPT('countdownSec', 30));
            start(sec);
          }else{
            stop();
          }
        }catch(_){}
        return out;
      };
    }
    ['resetBtn','repeatBtn','nextBtn','resumeBtn'].forEach(id=>{
      const n = document.getElementById(id);
      if(n) n.addEventListener('click', stop, {capture:true});
    });
    if(typeof window.showCelebrate==='function'){
      const orig = window.showCelebrate;
      window.showCelebrate = function(total, mistakes){ try{ stop(); }catch(_){ } return orig(total, mistakes); };
    }
  })();

  // ---- Recorder: create kifu by playing on board ----
  (function(){
    const wrap = document.getElementById('boardWrap');
    if(!wrap) return;

    // Add button in settings card
    if(settingsCard){
      const field = document.createElement('div'); field.className='field row wrap';
      const btn = document.createElement('button'); btn.id='openRecorderBtn'; btn.className='ghost'; btn.textContent='棋譜作成モード（録画）';
      field.appendChild(btn); settingsCard.appendChild(field);
      btn.addEventListener('click', open);
    }

    // overlay
    const layer = document.createElement('div'); layer.className='rec-layer'; layer.id='recLayer';
    layer.innerHTML = [
      '<div class="panel">',
      '<h3>棋譜作成モード</h3>',
      '<div class="small muted">盤面をクリックして手を記録。合法手のみ保存されます。パスは必要時のみ許可。</div>',
      '<div class="field"><label class="small">現在の記録</label><textarea id="recMovesView" rows="2" class="mono" readonly></textarea><div class="small muted" id="recMeta">—</div></div>',
      '<div class="field"><div class="row wrap">',
      '<button id="recPassBtn" class="ghost">PASS</button>',
      '<button id="recUndoBtn" class="ghost">一手戻す</button>',
      '<button id="recClearBtn" class="ghost">全消去</button>',
      '</div></div>',
      '<div class="field"><label class="small">名前（任意）</label><input id="recName" type="text" placeholder="問題名"></div>',
      '<div class="field"><label class="small">備考（任意）</label><textarea id="recNote" rows="2" placeholder="メモや気づき"></textarea></div>',
      '<div class="actions">',
      '<button id="recSaveBtn" class="primary">保存して追加</button>',
      '<button id="recCloseBtn">閉じる</button>',
      '</div>',
      '</div>'
    ].join('');
    wrap.appendChild(layer);

    let recActive=false, backup=null, recMoves=[];
    function cloneBoard(b){ return b.map(row=>row.slice()); }

    function refresh(){
      try{
        const view = document.getElementById('recMovesView');
        if(view) view.value = (recMoves||[]).join(' ');
        const LM = legalMoves(board, currentPlayer);
        const meta = document.getElementById('recMeta');
        if(meta) meta.textContent = `手番：${currentPlayer===1?'黒':'白'}　合法手：${LM.length}`;
        // mark legals
        try{
          const cells = document.querySelectorAll('#board .cell');
          for(let i=0;i<64;i++) cells[i].classList.remove('legal');
          LM.forEach(m => {
            const idx = m.r*8 + m.c; const cell = cells[idx];
            if(cell) cell.classList.add('legal');
          });
          wrap.classList.add('legal-only'); // enable hover outlines
        }catch(_){}
      }catch(_){}
    }

    function open(){
      if(recActive) return;
      // backup globals
      backup = {
        board: cloneBoard(board),
        currentPlayer: currentPlayer,
        training: training,
        expectedMoves: (expectedMoves||[]).slice(),
        moveIndex: moveIndex,
        inspectMode: inspectMode
      };
      // enter record state
      recActive = true; recMoves = [];
      training = false; inspectMode = false;
      board = newBoard(); currentPlayer = 1;
      renderBoard(); refresh();
      layer.style.display = 'flex';
      document.addEventListener('click', capture, true);
    }
    function close(){
      if(!recActive) return;
      document.removeEventListener('click', capture, true);
      wrap.classList.remove('legal-only');
      layer.style.display = 'none';
      // restore
      board = backup.board; currentPlayer = backup.currentPlayer; training = backup.training;
      expectedMoves = backup.expectedMoves; moveIndex = backup.moveIndex; inspectMode = backup.inspectMode;
      recActive = false; renderBoard();
    }

    function capture(e){
      if(!recActive) return;
      const cell = e.target.closest && e.target.closest('.cell');
      if(!cell) return;
      e.preventDefault(); e.stopImmediatePropagation();
      const r = parseInt(cell.dataset.r,10), c = parseInt(cell.dataset.c,10);
      const LM = legalMoves(board, currentPlayer);
      const match = LM.find(m => m.r===r && m.c===c);
      if(!match){ showToast('その手は合法ではありません'); return; }
      applyMove(board, match, currentPlayer);
      recMoves.push(cell.dataset.coord);
      currentPlayer = -currentPlayer;
      renderBoard(); refresh();
    }
    function recPass(){
      if(!recActive) return;
      const LM = legalMoves(board, currentPlayer);
      if(LM.length>0){ showToast('合法手があるためPASSできません'); return; }
      recMoves.push('P');
      currentPlayer = -currentPlayer;
      renderBoard(); refresh();
    }
    function recUndo(){
      if(!recActive || !recMoves.length) return;
      recMoves.pop();
      // rebuild from scratch
      board = newBoard(); currentPlayer = 1;
      for(const t of recMoves){
        if(t==='P' || t==='PASS'){
          const LM = legalMoves(board, currentPlayer);
          if(LM.length>0){ showToast('この記録は不整合の可能性があります（PASS無効）'); break; }
          currentPlayer = -currentPlayer; continue;
        }
        const rc = coordToRC(t);
        const LM = legalMoves(board, currentPlayer);
        const match = LM.find(m=>m.r===rc[0] && m.c===rc[1]);
        if(!match){ showToast('この記録は不整合の可能性があります'); break; }
        applyMove(board, match, currentPlayer);
        currentPlayer = -currentPlayer;
      }
      renderBoard(); refresh();
    }
    function recClear(){
      recMoves = []; board = newBoard(); currentPlayer = 1; renderBoard(); refresh();
    }
    function recSave(){
      try{
        if(!recMoves.length){ alert('1手以上を記録してください'); return; }
        const tokens = recMoves.slice();
        const val = validateMoves(tokens);
        if(!val.ok){ alert('記録の検証に失敗：' + val.error); return; }
        const pk = currentPath();
        const arr = store.kifuByPath[pk] || (store.kifuByPath[pk]=[]);
        const sig = canonicalSignature(tokens);
        if(arr.some(k=>k.sig===sig)){ alert('同一棋譜が既に存在します'); return; }
        const name = (document.getElementById('recName')?.value||'').trim();
        const note = (document.getElementById('recNote')?.value||'').trim();
        arr.push({
          id: Date.now().toString(36)+Math.random().toString(36).slice(2,7),
          moves: tokens, sig, enabled:true, name, tags:[], comment:note, addedAt: Date.now(),
          _idx: arr.length, stats:{ attempts:0, solved:0, mistakes:0 }
        });
        saveStore(store);
        updateCountsAndPath();
        showToast('棋譜を追加しました');
        try{ if(document.getElementById('kifuModal')?.style.display==='flex') renderKifuList(); }catch(_){}
        close();
      }catch(e){
        alert('保存に失敗しました');
      }
    }

    layer.querySelector('#recPassBtn').addEventListener('click', recPass);
    layer.querySelector('#recUndoBtn').addEventListener('click', recUndo);
    layer.querySelector('#recClearBtn').addEventListener('click', recClear);
    layer.querySelector('#recSaveBtn').addEventListener('click', recSave);
    layer.querySelector('#recCloseBtn').addEventListener('click', close);
    window._v10_recorder = { open, close };
  })();

  // ---- Symmetry: add 90°/270°/diagonals and RANDOM+ ----
  (function(){
    try{
      const sel = document.getElementById('symmetrySel');
      const opts = [
        ['ROT90','回転90°'], ['ROT270','回転270°'],
        ['DIAG','主対角線（転置）'], ['ADIAG','副対角線']
      ];
      if(sel){
        const existing = new Set(Array.from(sel.options).map(o=>o.value));
        opts.forEach(([v,t])=>{
          if(!existing.has(v)){
            const o = document.createElement('option'); o.value=v; o.textContent=t; sel.appendChild(o);
          }
        });
        if(!existing.has('RANDOM_PLUS')){
          const o = document.createElement('option'); o.value='RANDOM_PLUS'; o.textContent='ランダム（全対称）';
          sel.appendChild(o);
        }
      }
      function transformCoordPlus(coord, mode){
        const m = String(coord).trim().toUpperCase().match(/^([A-H])([1-8])$/);
        if(!m) return coord;
        const cols = 'ABCDEFGH';
        let c = cols.indexOf(m[1]), r = parseInt(m[2],10)-1;
        if(mode==='ROT90'){ const nc = 7 - r, nr = c; c = nc; r = nr; }
        else if(mode==='ROT270'){ const nc = r, nr = 7 - c; c = nc; r = nr; }
        else if(mode==='DIAG'){ const nc = r, nr = c; c = nc; r = nr; }
        else if(mode==='ADIAG'){ const nc = 7 - r, nr = 7 - c; c = nc; r = nr; }
        else return coord;
        return cols[c] + String(r+1);
      }
      function transformMovesPlus(moves, mode){
        return (moves||[]).map(t => (t==='P'||t==='PASS') ? t : transformCoordPlus(t, mode));
      }
      function pick(mode){
        if(mode==='RANDOM_PLUS'){
          const cand = ['HFLIP','VFLIP','ROT180','ROT90','ROT270','DIAG','ADIAG'];
          return cand[Math.floor(Math.random()*cand.length)];
        }
        return mode;
      }
      if(typeof window.startTrainingCore === 'function'){
        const orig = window.startTrainingCore;
        window.startTrainingCore = function(picked){
          let mode = OPT('symMode','NONE');
          mode = pick(mode);
          if(['ROT90','ROT270','DIAG','ADIAG'].includes(mode)){
            // prevent v9 symmetry from applying by temporarily setting to NONE
            const prev = OPT('symMode','NONE');
            try{
              SETOPT('symMode','NONE');
              const clone = Object.assign({}, picked);
              clone.moves = transformMovesPlus(picked.moves, mode);
              setTimeout(()=>{ try{ setStatus(`対称変換：${({'ROT90':'回転90°','ROT270':'回転270°','DIAG':'主対角線','ADIAG':'副対角線'})[mode]}`); }catch(_){ } }, 10);
              const out = orig(clone);
              return out;
            }finally{
              SETOPT('symMode', prev);
            }
          }
          return orig(picked);
        };
      }
    }catch(_){}
  })();

  // ---- Kifu modal: bulk operations for filtered set ----
  (function(){
    function inject(){
      try{
        const hdr = document.querySelector('#kifuModal .klist-controls');
        if(!hdr || document.getElementById('bulkOps')) return;
        const box = document.createElement('span'); box.id='bulkOps';
        box.style.display='inline-flex'; box.style.gap='6px'; box.style.flexWrap='wrap'; box.style.marginLeft='8px';
        function mk(text, fn){
          const b = document.createElement('button'); b.className='ghost tiny'; b.textContent=text;
          b.addEventListener('click', fn); return b;
        }
        const btnOn  = mk('表示中→出題オン', ()=> bulkEnableFiltered(true));
        const btnOff = mk('表示中→出題オフ', ()=> bulkEnableFiltered(false));
        const btnQAdd = mk('表示中→キュー追加', ()=> bulkQueueFiltered(true));
        const btnQDel = mk('表示中→キュー削除', ()=> bulkQueueFiltered(false));
        box.appendChild(btnOn); box.appendChild(btnOff); box.appendChild(btnQAdd); box.appendChild(btnQDel);
        hdr.appendChild(box);
      }catch(_){}
    }
    function currentFiltered(){
      const pk = currentPath();
      const arr = getSortedArray(pk); // already applies search & tag filter
      return { pk, arr };
    }
    function bulkEnableFiltered(flag){
      const { pk, arr } = currentFiltered();
      if(!arr.length){ alert('対象がありません'); return; }
      arr.forEach(k => { k.enabled = !!flag; });
      saveStore(store); renderKifuList(); updateEnabledCount(); showToast(flag?'出題オンを適用':'出題オフを適用');
    }
    function bulkQueueFiltered(add){
      const { pk, arr } = currentFiltered();
      if(!arr.length){ alert('対象がありません'); return; }
      const q = getQueueByPath(pk).slice();
      if(add){
        const set = new Set(q);
        arr.forEach(k => set.add(k.id));
        store.queueByPath[pk] = Array.from(set);
      }else{
        const ids = new Set(arr.map(k=>k.id));
        store.queueByPath[pk] = q.filter(id => !ids.has(id));
      }
      saveStore(store); updateQueueView(); showToast(add?'キューに追加しました':'キューから削除しました');
    }
    if(typeof window.openKifuModal === 'function'){
      const orig = window.openKifuModal;
      window.openKifuModal = function(){ orig(); setTimeout(inject, 0); };
    }else{
      inject();
    }
  })();

  // ---- Drag & Drop import area on I/O card + CSV log export ----
  (function(){
    const ioCard = (function(){
      const cards = document.querySelectorAll('.panel > .card');
      return cards && cards[0] ? cards[0] : null;
    })();
    if(!ioCard) return;
    // Dropzone
    const field = ioCard.querySelector('.field.row.wrap:last-of-type') || ioCard;
    const dz = document.createElement('div'); dz.className='dropzone'; dz.id='jsonDropZone';
    dz.textContent = 'JSONをここにドラッグ＆ドロップ（全体バックアップ／小フォルダエクスポート／単純な棋譜配列に対応）';
    field.parentNode.insertBefore(dz, field.nextSibling);

    ;['dragenter','dragover'].forEach(ev=>{
      dz.addEventListener(ev, (e)=>{ e.preventDefault(); dz.classList.add('drag'); });
    });
    ;['dragleave','drop'].forEach(ev=>{
      dz.addEventListener(ev, (e)=>{ if(ev==='drop') return; e.preventDefault(); dz.classList.remove('drag'); });
    });
    dz.addEventListener('drop', (e)=>{
      e.preventDefault(); dz.classList.remove('drag');
      const file = e.dataTransfer.files && e.dataTransfer.files[0];
      if(!file){ showToast('ファイルが見つかりません'); return; }
      const reader = new FileReader();
      reader.onload = ()=>{
        try{
          const txt = reader.result;
          const obj = JSON.parse(txt);
          // type A: full store
          if(obj && Array.isArray(obj.bigFolders) && obj.kifuByPath){
            if(confirm('全体バックアップ形式です。現在の全データを置き換えますか？')){
              store = obj; saveStore(store);
              refreshBigSelect(); updateCountsAndPath(); renderKifuList?.(); showToast('全体データをインポートしました');
            }
            return;
          }
          // type B: folder export
          if(obj && obj.type==='reversi_trainer_folder_export_v1' && obj.kifu){
            const pk = currentPath();
            const arr = store.kifuByPath[pk] || (store.kifuByPath[pk]=[]);
            let ok=0, dup=0;
            obj.kifu.forEach(k=>{
              const tokens = (k.moves||[]).slice();
              const val = validateMoves(tokens);
              if(!val.ok) return;
              const sig = canonicalSignature(tokens);
              if(arr.some(x=>x.sig===sig)){ dup++; return; }
              arr.push({ id: Date.now().toString(36)+Math.random().toString(36).slice(2,7),
                         moves: tokens, sig, enabled: true, name: k.name||'', tags: (k.tags||[]), comment:(k.comment||''), addedAt: Date.now(), _idx: arr.length,
                         stats: { attempts:0, solved:0, mistakes:0 } });
              ok++;
            });
            saveStore(store); updateCountsAndPath(); renderKifuList?.();
            alert(`この小フォルダにインポートしました：追加 ${ok} 件／重複 ${dup} 件`);
            return;
          }
          // type C: simple array of strings or moves per line
          if(Array.isArray(obj)){
            const pk = currentPath();
            const arr = store.kifuByPath[pk] || (store.kifuByPath[pk]=[]);
            let ok=0, dup=0, ng=0;
            obj.forEach(line=>{
              const tokens = tokenizeKifuString(String(line));
              if(!tokens){ ng++; return; }
              const val = validateMoves(tokens);
              if(!val.ok){ ng++; return; }
              const sig = canonicalSignature(tokens);
              if(arr.some(x=>x.sig===sig)){ dup++; return; }
              arr.push({ id: Date.now().toString(36)+Math.random().toString(36).slice(2,7),
                         moves: tokens, sig, enabled: true, name:'', tags:[], comment:'', addedAt: Date.now(), _idx: arr.length,
                         stats: { attempts:0, solved:0, mistakes:0 } });
              ok++;
            });
            saveStore(store); updateCountsAndPath(); renderKifuList?.();
            alert(`この小フォルダに追加：追加 ${ok}／重複 ${dup}／NG ${ng}`);
            return;
          }
          alert('未対応のJSON形式です');
        }catch(err){
          alert('JSONの解析に失敗しました');
        }
      };
      reader.readAsText(file, 'utf-8');
    });

    // CSV log export buttons
    const logRow = document.createElement('div'); logRow.className='row wrap'; logRow.style.marginTop='8px';
    const logBtn = document.createElement('button'); logBtn.className='ghost'; logBtn.id='exportLogBtn'; logBtn.textContent='試行ログをCSV出力';
    const clrBtn = document.createElement('button'); clrBtn.className='ghost'; clrBtn.id='clearLogBtn'; clrBtn.textContent='試行ログを消去';
    logRow.appendChild(logBtn); logRow.appendChild(clrBtn);
    field.parentNode.insertBefore(logRow, dz.nextSibling);

    function getLogs(){ try{ return JSON.parse(localStorage.getItem(STORE_PREFIX+'opt10_logs')||'[]'); }catch(_){ return []; } }
    function setLogs(a){ try{ localStorage.setItem(STORE_PREFIX+'opt10_logs', JSON.stringify(a)); }catch(_){ } }

    function toCSV(rows){
      const header = ['timestamp','big','small','path','kifu_index','kifu_id','kifu_name','kifu_len','range_start','range_end','mistakes','time_ms','solved','tags'];
      const esc = s => ('"'+String(s).replace(/"/g,'""')+'"');
      const lines = [header.join(',')];
      rows.forEach(r=>{
        lines.push([
          r.timestamp, r.big, r.small, r.path, r.kifu_index, r.kifu_id, r.kifu_name, r.kifu_len,
          r.range_start, r.range_end, r.mistakes, r.time_ms, r.solved ? 1 : 0, (r.tags||[]).join('|')
        ].map(esc).join(','));
      });
      return lines.join('\n');
    }

    logBtn.addEventListener('click', ()=>{
      const rows = getLogs();
      if(!rows.length){ alert('ログがありません'); return; }
      const blob = new Blob([toCSV(rows)], {type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url;
      const dt = new Date(); const y=dt.getFullYear(), m=String(dt.getMonth()+1).padStart(2,'0'), d=String(dt.getDate()).padStart(2,'0');
      a.download = `reversi_trainer_logs_${y}${m}${d}.csv`;
      document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url), 1000);
    });
    clrBtn.addEventListener('click', ()=>{
      if(confirm('試行ログをすべて削除しますか？')){ setLogs([]); showToast('ログを消去しました'); }
    });

    // hook showCelebrate to push a row
    if(typeof window.showCelebrate === 'function'){
      const orig = window.showCelebrate;
      window.showCelebrate = function(total, mistakes){
        const out = orig(total, mistakes);
        try{
          const pk = currentPath();
          const parts = pk.split('/');
          const arr = store.kifuByPath[pk] || [];
          const k = arr.find(x=>x.id===currentKifuId);
          const idx = (typeof k?._idx==='number') ? (k._idx+1) : (arr.findIndex(x=>x.id===currentKifuId)+1);
          const timeMs = (window._v9 && _v9.timerStart) ? Math.max(0, Date.now() - _v9.timerStart) : null;
          const row = {
            timestamp: new Date().toISOString(),
            big: parts[0]||'',
            small: parts[1] && parts[1]!=='__ROOT__' ? parts[1] : '',
            path: pk,
            kifu_index: idx||'',
            kifu_id: currentKifuId||'',
            kifu_name: (k&&k.name)||'',
            kifu_len: (k&&k.moves&&k.moves.length)||'',
            range_start: (typeof window.rangeStart!=='undefined') ? window.rangeStart : '',
            range_end: (typeof window.rangeEnd!=='undefined') ? window.rangeEnd : '',
            mistakes: mistakes,
            time_ms: timeMs,
            solved: mistakes===0,
            tags: (k&&k.tags)||[]
          };
          const logs = getLogs(); logs.push(row); setLogs(logs);
        }catch(_){}
        return out;
      };
    }
  })();

})(); // end v10
</script>
<!-- ===== v11 Addons by ChatGPT (2025-10-19) ===== -->
<style>
/* v11: rotation, mcq, keyboard overlay */
#boardWrap.rot180 { transform: rotate(180deg); }
#boardWrap.rot180 .axis, 
#boardWrap.rot180 .corner-label, 
#boardWrap.rot180 .count-overlay,
#boardWrap.rot180 .inspect-bar,
#boardWrap.rot180 .inspect-action,
#boardWrap.rot180 .timer-overlay { transform: rotate(180deg); }

body.theme-dark .kbd-overlay{
  position:absolute; left:10px; bottom:10px; z-index:7;
  background:rgba(0,0,0,.55); color:#fff; padding:2px 6px; border-radius:6px; font-variant-numeric:tabular-nums; display:none;
}
</style>
<script>
(function(){
  // Local option helpers (v11 namespace)
  const OPT = (k, d) => { try{ const v = localStorage.getItem(STORE_PREFIX + 'opt11_' + k); return v==null?d:JSON.parse(v);}catch(_){ return d; } };
  const SETOPT = (k, v) => { try{ localStorage.setItem(STORE_PREFIX + 'opt11_' + k, JSON.stringify(v)); }catch(_){ } };

  // ---- Version bump ----
  try{
    // [refactor] removed version bump
    // [refactor] removed version bump
  }catch(_){}

  // ---- Settings card reference ----
  const settingsCard = (function(){
    const cards = document.querySelectorAll('.dockGrid .card');
    return cards && cards[0] ? cards[0] : null;
  })();

  // ---- Inject new settings (white-view / speech / MCQ / global heat) ----
  if(settingsCard){
    const field = document.createElement('div'); field.className='field row wrap';

    // White viewpoint
    const whiteChk = document.createElement('input'); whiteChk.type='checkbox'; whiteChk.id='whiteViewChk';
    whiteChk.checked = !!OPT('whiteView', false);
    const whiteLbl = document.createElement('label'); whiteLbl.className='small';
    whiteLbl.appendChild(whiteChk); whiteLbl.appendChild(document.createTextNode(' 白番視点で盤を180°回転'));
    field.appendChild(whiteLbl);

    // Speech
    const speechChk = document.createElement('input'); speechChk.type='checkbox'; speechChk.id='speechChk';
    speechChk.checked = !!OPT('speech', false);
    const speechLbl = document.createElement('label'); speechLbl.className='small';
    speechLbl.appendChild(speechChk); speechLbl.appendChild(document.createTextNode(' 読み上げ（正誤/正解手）'));
    field.appendChild(document.createTextNode('　'));
    field.appendChild(speechLbl);

    // Tips
    const tip = document.createElement('span'); tip.className='small muted';
    tip.textContent = '（ショートカット：T=白視点／V=読み上げ／A〜H→1〜8=座標入力）';
    field.appendChild(document.createTextNode('　'));
    field.appendChild(tip);

    settingsCard.appendChild(field);

    // Persist + apply
    whiteChk.addEventListener('change', ()=>{ SETOPT('whiteView', !!whiteChk.checked); applyWhiteView(); });
    speechChk.addEventListener('change', ()=> SETOPT('speech', !!speechChk.checked));
    mcqChk.addEventListener('change', ()=>{ SETOPT('mcq', !!mcqChk.checked); updateMCQ(); });
    gheatChk.addEventListener('change', ()=>{ SETOPT('globalHeat', !!gheatChk.checked); updateGlobalHeatUI(); drawGlobalHeat(); });
  }

  // ---- White viewpoint rotation ----
  function applyWhiteView(){
    const wrap = document.getElementById('boardWrap');
    if(!wrap) return;
    wrap.classList.toggle('rot180', !!OPT('whiteView', false));
  }
  applyWhiteView();

  // ---- Speech helpers ----
  function speakJa(text){
    if(!OPT('speech', false)) return;
    try{
      if(!('speechSynthesis' in window)) return;
      const u = new SpeechSynthesisUtterance(String(text||'')); u.lang = 'ja-JP';
      try{ speechSynthesis.cancel(); }catch(_){}
      speechSynthesis.speak(u);
    }catch(_){}
  }

  // Patch playSound to also speak
  if(typeof window.playSound === 'function' && !window._v11_playSound_patched){
    const orig = window.playSound;
    window.playSound = function(type){
      try{
        orig(type);
        if(type==='ng'){
          const token = (window.expectedMoves && window.expectedMoves[window.moveIndex]) || null;
          if(token && token!=='P' && token!=='PASS'){ speakJa('違います。正解は ' + token); }
          else { speakJa('違います'); }
        }else if(type==='ok'){ speakJa('正解'); }
        else if(type==='success'){ speakJa('クリア'); }
      }catch(_){}
    };
    window._v11_playSound_patched = true;
  }

  // Keyboard shortcuts for MCQ and toggles + coordinate input
  (function(){
    const wrap = document.getElementById('boardWrap');
    if(wrap && !document.getElementById('kbdOverlay')){
      const o = document.createElement('div'); o.id='kbdOverlay'; o.className='kbd-overlay'; o.style.display='none';
      wrap.appendChild(o);
    }
    let buf = '';
    function resetBuf(){ buf=''; const o=document.getElementById('kbdOverlay'); if(o) o.style.display='none'; }

    window.addEventListener('keydown', (e)=>{
      const tag = (e.target && e.target.tagName ? e.target.tagName.toLowerCase() : '');
      if(tag==='input' || tag==='textarea' || tag==='select') return;

      // Toggles
      if(e.key==='t' || e.key==='T'){ const v=!OPT('whiteView', false); SETOPT('whiteView', v); applyWhiteView(); e.preventDefault(); e.stopPropagation(); if(e.stopImmediatePropagation) e.stopImmediatePropagation(); return; }
      if(e.key==='v' || e.key==='V'){ const v=!OPT('speech', false); SETOPT('speech', v); speakJa(v?'読み上げオン':'読み上げオフ'); e.preventDefault(); e.stopPropagation(); if(e.stopImmediatePropagation) e.stopImmediatePropagation(); return; }
      // Coordinate typing A-H then 1-8
      if(/^[a-hA-H]$/.test(e.key)){
        buf = e.key.toUpperCase();
        const o = document.getElementById('kbdOverlay'); if(o){ o.textContent = '入力: ' + buf + ' _'; o.style.display='inline-block'; }
        e.preventDefault(); e.stopPropagation(); if(e.stopImmediatePropagation) e.stopImmediatePropagation(); return;
      }
      if(/^[1-8]$/.test(e.key) && buf){
        const coord = buf + e.key;
        const o = document.getElementById('kbdOverlay'); if(o){ o.textContent = '入力: ' + coord; }
        const cell = document.querySelector('.cell[data-coord="'+coord+'"]');
        setTimeout(resetBuf, 600);
        if(cell){ e.preventDefault(); e.stopPropagation(); if(e.stopImmediatePropagation) e.stopImmediatePropagation(); cell.click(); }
        return;
      }
      if(e.key==='Escape'){ resetBuf(); e.preventDefault(); e.stopPropagation(); if(e.stopImmediatePropagation) e.stopImmediatePropagation(); return; }
      if(e.key==='Backspace'){ resetBuf(); return; }
    }, {capture:true});
  })();

  // ---- Global mistake heatmap (aggregate across all problems) ----
  function getGlobalMap(){ try{ return JSON.parse(localStorage.getItem(STORE_PREFIX+'opt11_globalMistake')||'{}'); }catch(_){ return {}; } }
  function setGlobalMap(m){ try{ localStorage.setItem(STORE_PREFIX+'opt11_globalMistake', JSON.stringify(m)); }catch(_){ } }

  // Intercept flashX to also add to global map
  if(typeof window.flashX === 'function' && !window._v11_flash_patched){
    const orig = window.flashX;
    window.flashX = function(cell){
      try{
        const coord = cell && cell.getAttribute ? cell.getAttribute('data-coord') : null;
        if(coord){
          // use mistakes from current kifu at the current turn only
      const k = (typeof getCurrentKifuObj==='function') ? getCurrentKifuObj() : null;
      const turnNum = (typeof moveIndex==='number') ? (moveIndex + 1) : null;
      const g = getGlobalMap() || {};
const key = (turnNum != null) ? ('turn:'+String(turnNum)) : 'ALL';
g[key] = g[key] || {};
g[key][coord] = (g[key][coord]||0) + 1;
g['ALL'] = g['ALL'] || {};
g['ALL'][coord] = (g['ALL'][coord]||0) + 1;
setGlobalMap(g);
        }
      }catch(_){}
      orig(cell);
    };
    window._v11_flash_patched = true;
  }

  function ensureHeatLayerV11(){
    document.querySelectorAll('#board .cell').forEach(cell=>{
      if(!cell.querySelector('.heat')){
        const h=document.createElement('div'); h.className='heat';
        const t=document.createElement('div'); t.className='cnt';
        h.appendChild(t); cell.appendChild(h);
      }
    });
  }

  function getHeatOnV9(){ try{ return JSON.parse(localStorage.getItem(STORE_PREFIX+'opt9_heatOn')||'false'); }catch(_){ return false; } }

  function updateGlobalHeatUI(){
    const wrap = document.getElementById('boardWrap'); if(!wrap) return;
    const on = !!OPT('globalHeat', false);
    if(on) wrap.classList.add('heat-on');
    else if(!getHeatOnV9()) wrap.classList.remove('heat-on');
  }

  function drawGlobalHeat(){
    try{
      if(!OPT('globalHeat', false)) return;
      // If local per-kifu heat is on, give it priority and skip global draw.
      if(getHeatOnV9 && getHeatOnV9()) return;
      ensureHeatLayerV11();
      // aggregate across all problems; prefer current turn slice
const turnNum = (typeof moveIndex==='number') ? (moveIndex + 1) : null;
const g = getGlobalMap() || {};
const key = (turnNum != null) ? ('turn:' + String(turnNum)) : null;
      const map = (key && g[key]) ? g[key] : {};
      let maxv = 0; Object.values(map).forEach(v=>{ if(v>maxv) maxv=v; });
      const cells = document.querySelectorAll('#board .cell');
      cells.forEach(cell=>{
        const coord = cell.getAttribute('data-coord');
        const v = map[coord]||0;
        const heat = cell.querySelector('.heat');
        if(!heat) return;
        const t = heat.querySelector('.cnt');
        if(v<=0){ heat.style.background='transparent'; t.textContent=''; return; }
        const alpha = Math.min(0.15 + 0.35*(v/(maxv||1)), 0.5);
        heat.style.background = 'rgba(220,32,32,' + alpha.toFixed(3) + ')';
        t.textContent = String(v);
      });
    }catch(_){}
  }

  // ---- Queue: drag & drop reorder chips ----
  if(typeof window.updateQueueView === 'function' && !window._v11_queue_patched){
    const orig = window.updateQueueView;
    window.updateQueueView = function(){
      orig();
      try{
        const view = document.getElementById('queueView'); if(!view) return;
        const pk = currentPath();
        Array.from(view.children).forEach((chip, idx)=>{
          chip.setAttribute('draggable','true');
          chip.dataset.idx = String(idx);
          chip.addEventListener('dragstart', (e)=>{ e.dataTransfer.effectAllowed='move'; e.dataTransfer.setData('text/plain', chip.dataset.idx); chip.classList.add('dragging'); });
          chip.addEventListener('dragend', ()=> chip.classList.remove('dragging'));
          chip.addEventListener('dragover', (e)=>{ e.preventDefault(); chip.style.outline='2px dashed #8ab4ff'; });
          chip.addEventListener('dragleave', ()=>{ chip.style.outline=''; });
          chip.addEventListener('drop', (e)=>{
            e.preventDefault(); chip.style.outline='';
            const from = parseInt(e.dataTransfer.getData('text/plain'),10);
            const to = parseInt(chip.dataset.idx,10);
            const q = getQueueByPath(pk);
            if(isFinite(from) && isFinite(to) && q && q.length){
              const item = q.splice(from,1)[0]; q.splice(to,0,item);
              saveStore(store); updateQueueView(); showToast('キューを並べ替えました');
            }
          });
        });
      }catch(_){}
    };
    window._v11_queue_patched = true;
  }

  // ---- Stats modal + Anki TSV export ----
  (function(){
    const topbar = document.querySelector('.topbar');
    if(topbar && !document.getElementById('openStatsBtn')){
      const b = document.createElement('button'); b.id='openStatsBtn'; b.className='ghost'; b.textContent='統計';
      b.style.marginLeft = '6px';
      b.addEventListener('click', openStats);
      topbar.appendChild(b);
    }

    if(!document.getElementById('statsModal')){
      const modal = document.createElement('div'); modal.className='modal'; modal.id='statsModal';
      modal.innerHTML = [
        '<div class="window">',
        '<header><h3>統計（<span id="statsPath">—</span>）</h3>',
        '<button class="ghost" id="statsCloseBtn">閉じる</button></header>',
        '<div class="body"><div id="statsBody" class="field"></div></div>',
        '<div class="footer"><div class="row">',
        '<button class="ghost" id="exportAnkiBtn">Anki用TSV（この小フォルダ）</button>',
        '<button class="ghost" id="exportStatsBtn">統計CSV（この小フォルダ）</button>',
        '</div></div>',
        '</div>'
      ].join('');
      document.body.appendChild(modal);
      modal.querySelector('#statsCloseBtn').addEventListener('click', ()=> modal.style.display='none');
      modal.addEventListener('click', (e)=>{ if(e.target===modal) modal.style.display='none'; });
      document.getElementById('exportAnkiBtn').addEventListener('click', exportAnkiTSV);
      document.getElementById('exportStatsBtn').addEventListener('click', exportStatsCSV);
    }

    function openStats(){
      try{
        const pk = currentPath();
        const arr = store.kifuByPath[pk] || [];
        const body = document.getElementById('statsBody');
        document.getElementById('statsPath').textContent = pk;

        const total = arr.length;
        const enabled = arr.filter(k=>k.enabled!==false).length;
        const cleared = arr.filter(k=> (typeof k.manualCleared==='boolean' ? k.manualCleared : (k.stats && (k.stats.solved||0)>0))).length;
        const attempts = arr.reduce((s,k)=> s + (k.stats?.attempts||0), 0);
        const solved = arr.reduce((s,k)=> s + (k.stats?.solved||0), 0);
        const mistakes = arr.reduce((s,k)=> s + (k.stats?.mistakes||0), 0);
        const bestTimes = arr.map(k=> k.stats?.time?.bestMs).filter(v=> typeof v==='number' && isFinite(v));
        const avgBest = bestTimes.length ? (bestTimes.reduce((a,b)=>a+b,0)/bestTimes.length) : null;

        function div(html){ const n=document.createElement('div'); n.innerHTML=html; return n; }

        body.innerHTML='';
        body.appendChild(div('<b>概要</b>'));
        body.appendChild(div('問題数：' + total + '（出題オン：' + enabled + '／クリア：' + cleared + '）'));
        body.appendChild(div('試行：' + attempts + '　正解：' + solved + '　誤答：' + mistakes + '　正解率：' + (attempts? ((solved/attempts*100).toFixed(1)+'%') : '—')));
        body.appendChild(div('平均ベストタイム：' + (avgBest!=null ? (avgBest/1000).toFixed(2)+' 秒' : '—')));

        // hardest top5
        const cand = arr.filter(k=> (k.stats?.attempts||0)>0);
        cand.sort((a,b)=>{
          const ra = (a.stats.mistakes||0)/Math.max(1,(a.stats.attempts||0));
          const rb = (b.stats.mistakes||0)/Math.max(1,(b.stats.attempts||0));
          if(rb!==ra) return rb - ra;
          return (b.stats.mistakes||0)-(a.stats.mistakes||0);
        });
        const top = cand.slice(0,5);
        if(top.length){
          const list = document.createElement('div'); list.className='field';
          list.appendChild(div('<b>要復習（誤答率順 Top 5）</b>'));
          top.forEach((k,i)=>{
            const name = (k.name||'（無名）');
            const rate = ((k.stats.mistakes||0)/Math.max(1,(k.stats.attempts||0))*100).toFixed(0);
            const len = (k.moves||[]).length;
            const tm = k.stats?.time?.bestMs;
            const row = document.createElement('div'); row.className='small';
            row.textContent = (i+1) + '. ' + name + '（' + len + '手）｜誤答率 ' + rate + '%｜試行 ' + (k.stats.attempts||0) + '｜ベスト ' + (tm!=null?(tm/1000).toFixed(2)+'s':'—');
            list.appendChild(row);
          });
          body.appendChild(list);
        }

        document.getElementById('statsModal').style.display='flex';
      }catch(_){}
    }

    function exportAnkiTSV(){
      // Basic-friendly TSV with 4 fields: Name, Moves, Tags, Note
      try{
        const pk = currentPath();
        const arr = store.kifuByPath[pk] || [];
        const rows = arr.map(k=>[
          k.name || '',
          (k.moves||[]).join(' '),
          (k.tags||[]).join(' '),
          k.comment || ''
        ]);
        const lines = rows.map(cols => cols.map(s => String(s).replace(/\t/g, ' ').replace(/\r?\n/g, ' / ')).join('\t'));
        const tsv = lines.join('\n');
        const blob = new Blob([tsv], {type:'text/tab-separated-values'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href=url; a.download = (pk.replaceAll('/','__')||'folder') + '_anki.tsv';
        document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url), 1000);
      }catch(e){ alert('TSV出力に失敗しました'); }
    }

    function exportStatsCSV(){
      try{
        const pk = currentPath();
        const arr = store.kifuByPath[pk] || [];
        const header = ['id','name','len','enabled','attempts','solved','mistakes','best_ms','avg_ms','tags'];
        const lines = [header.join(',')];
        arr.forEach(k=>{
          const tm = k.stats?.time || {};
          const cols = [
            k.id,
            (k.name||'').replace(/"/g,'""'),
            (k.moves||[]).length,
            (k.enabled!==false)?1:0,
            k.stats?.attempts||0,
            k.stats?.solved||0,
            k.stats?.mistakes||0,
            (typeof tm.bestMs==='number'?tm.bestMs:''),
            (typeof tm.avgMs==='number'?Math.round(tm.avgMs):''),
            (k.tags||[]).join('|').replace(/"/g,'""')
          ];
          lines.push(cols.map(x => '"' + String(x) + '"').join(','));
        });
        const csv = lines.join('\n');
        const blob = new Blob([csv], {type:'text/csv'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href=url; a.download = (pk.replaceAll('/','__')||'folder') + '_stats.csv';
        document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url), 1000);
      }catch(e){ alert('CSV出力に失敗しました'); }
    }
  })();

})(); // end v11
</script>
<!-- ===== v12 Addons by ChatGPT (2025-10-19) ===== -->
<style>
/* v12: voice overlay */
.voice-overlay{
  position:absolute; left:10px; top:44px; z-index:7;
  background:rgba(0,0,0,.55); color:#fff; padding:2px 6px; border-radius:6px;
  font-variant-numeric:tabular-nums; display:none;
}
</style>
<script>
(function(){
  const OPT = (k, d) => { try{ const v = localStorage.getItem(STORE_PREFIX + 'opt12_' + k); return v==null?d:JSON.parse(v);}catch(_){ return d; } };
  const SETOPT = (k, v) => { try{ localStorage.setItem(STORE_PREFIX + 'opt12_' + k, JSON.stringify(v)); }catch(_){ } };
  const dayMs = 24*60*60*1000;

  // ---- Version bump ----
  try{
    // [refactor] removed version bump
    // [refactor] removed version bump
  }catch(_){}

  // ---- Topbar: 今日のメニュー & 音声入力 ----
  (function(){
    const topbar = document.querySelector('.topbar');
    if(!topbar) return;
    if(!document.getElementById('todayBtn')){
      const b = document.createElement('button'); b.id='todayBtn'; b.className='ghost'; b.textContent='今日のメニュー';
      b.addEventListener('click', buildTodayPlaylist);
      topbar.appendChild(b);
    }
    if(!document.getElementById('voiceBtn')){
      const b = document.createElement('button'); b.id='voiceBtn'; b.className='ghost'; b.textContent='🎤 音声入力 OFF';
      b.addEventListener('click', toggleVoice);
      topbar.appendChild(b);
    }
  })();

  function buildTodayPlaylist(){
    try{
      const pk = currentPath();
      const enabledArr = (typeof getEnabledArrCurrent==='function') ? getEnabledArrCurrent() : (store.kifuByPath[pk]||[]).filter(k=>k.enabled!==false);
      if(!enabledArr.length){ alert('出題オンの棋譜がありません'); return; }
      const N = parseInt(prompt('今日のメニューの件数（既定：20）', String(OPT('todayN', 20)))||'0', 10) || OPT('todayN', 20);
      SETOPT('todayN', N);
      const nowT = Date.now();
      const idSet = new Set(); const out = [];
      const due = enabledArr.filter(k => (k.srsDue||0) <= nowT).sort((a,b)=> (a.srsDue||0) - (b.srsDue||0));
      const unsolved = enabledArr.filter(k => !isCleared(k));
      const hard = enabledArr.slice().sort((a,b)=>{
        const ra=(a.stats?.mistakes||0)/Math.max(1,(a.stats?.attempts||0));
        const rb=(b.stats?.mistakes||0)/Math.max(1,(b.stats?.attempts||0));
        if(rb!==ra) return rb-ra;
        return (b.stats?.mistakes||0)-(a.stats?.mistakes||0);
      });
      function pushList(list){
        for(const k of list){
          if(out.length>=N) break;
          if(k && !idSet.has(k.id)){ idSet.add(k.id); out.push(k.id); }
        }
      }
      pushList(due); pushList(unsolved); pushList(hard);
      if(!out.length){ alert('対象が見つかりませんでした'); return; }
      store.queueByPath[pk] = out; saveStore(store); updateQueueView();
      try{ const sel = document.getElementById('pickMode'); if(sel) sel.value='QUEUE'; }catch(_){}
      showToast('今日のメニューをキューに作成しました（' + out.length + '件）');
    }catch(e){ alert('今日のメニュー作成でエラーが発生しました'); }
  }

  // ---- 音声入力（ja-JP） ----
  let _rec = null, _voiceOn = false, _voiceTimer = null;
  function toggleVoice(){ if(_voiceOn) stopVoice(); else startVoice(); }
  function startVoice(){
    try{
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if(!SR){ alert('このブラウザは音声認識に対応していません'); return; }
      stopVoice();
      _rec = new SR(); _rec.lang='ja-JP'; _rec.continuous=true; _rec.interimResults=false;
      _rec.onresult = (ev)=>{
        for(let i=ev.resultIndex;i<ev.results.length;i++){
          const tx = (ev.results[i] && ev.results[i][0] && ev.results[i][0].transcript) ? ev.results[i][0].transcript.trim() : '';
          if(!tx) continue;
          const coord = parseSpeechToCoord(tx);
          if(coord){
            const cell = document.querySelector('.cell[data-coord="'+coord+'"]');
            if(cell){ cell.click(); showVoice(tx + ' → ' + coord); }
            else { showVoice(tx + ' → ?'); }
          }else{
            showVoice(tx);
          }
        }
      };
      _rec.onerror = ()=>{};
      _rec.onend = ()=>{ if(_voiceOn){ try{ _rec.start(); }catch(_){ _voiceOn=false; updateVoiceBtn(); } } };
      _rec.start(); _voiceOn = true; updateVoiceBtn();
    }catch(e){ alert('音声入力の開始に失敗しました'); }
  }
  function stopVoice(){
    try{ if(_rec){ try{ _rec.onend=null; _rec.stop(); }catch(_){ } } }catch(_){}
    _rec = null; _voiceOn = false; updateVoiceBtn(); hideVoice();
    if(_voiceTimer){ clearTimeout(_voiceTimer); _voiceTimer=null; }
  }
  function updateVoiceBtn(){ const b=document.getElementById('voiceBtn'); if(b) b.textContent = _voiceOn ? '🎤 音声入力 ON' : '🎤 音声入力 OFF'; }
  function showVoice(txt){
    let o=document.getElementById('voiceOverlay');
    if(!o){ o=document.createElement('div'); o.id='voiceOverlay'; o.className='voice-overlay'; const wrap=document.getElementById('boardWrap'); if(wrap) wrap.appendChild(o); }
    o.textContent = '🎤 ' + String(txt||''); o.style.display='inline-block';
    if(_voiceTimer) clearTimeout(_voiceTimer);
    _voiceTimer = setTimeout(()=>{ if(o) o.style.display='none'; }, 1600);
  }
  function hideVoice(){ const o=document.getElementById('voiceOverlay'); if(o) o.style.display='none'; }
  window.addEventListener('beforeunload', stopVoice, {capture:true});

  function parseSpeechToCoord(text){
    const t = String(text||'').trim().toUpperCase();
    const direct = t.match(/([A-H])[^\d]*([1-8])/);
    if(direct){ return direct[1] + direct[2]; }
    // Japanese numerals and letter names
    const mapNum = {'イチ':'1','一':'1','１':'1','1':'1','ニ':'2','二':'2','２':'2','2':'2','サン':'3','三':'3','３':'3','3':'3','ヨン':'4','シ':'4','四':'4','４':'4','4':'4','ゴ':'5','五':'5','５':'5','5':'5','ロク':'6','六':'6','６':'6','6':'6','ナナ':'7','シチ':'7','七':'7','７':'7','7':'7','ハチ':'8','八':'8','８':'8','8':'8'};
    const mapLetter = {'エー':'A','エイ':'A','Ａ':'A','A':'A','ビー':'B','ビィ':'B','Ｂ':'B','B':'B','シー':'C','スィー':'C','Ｃ':'C','C':'C','ディー':'D','デー':'D','Ｄ':'D','D':'D','イー':'E','Ｅ':'E','E':'E','エフ':'F','Ｆ':'F','F':'F','ジー':'G','Ｇ':'G','G':'G','エイチ':'H','エッチ':'H','Ｈ':'H','H':'H'};
    const parts = t.split(/[\s、。・,，\.]+/).filter(Boolean);
    let L=null,N=null;
    for(const p of parts){
      if(L==null){
        const m = p.match(/[A-HＡ-Ｈ]/);
        if(m){ L = String(m[0]).replace('Ａ','A').replace('Ｂ','B').replace('Ｃ','C').replace('Ｄ','D').replace('Ｅ','E').replace('Ｆ','F').replace('Ｇ','G').replace('Ｈ','H'); }
        if(!L){
          for(const k in mapLetter){ if(p.includes(k)){ L = mapLetter[k]; break; } }
        }
      }
      if(N==null){
        const m2 = p.match(/[1-8１-８]/);
        if(m2){ N = String(m2[0]).replace('１','1').replace('２','2').replace('３','3').replace('４','4').replace('５','5').replace('６','6').replace('７','7').replace('８','8'); }
        if(!N){
          for(const k in mapNum){ if(p.includes(k)){ N = mapNum[k]; break; } }
        }
      }
    }
    if(L && N) return L + N;
    return null;
  }

  // ---- キュー：誤答復習キュー作成 ----
  (function(){
    try{
      const cards = document.querySelectorAll('.dockGrid .card');
      const queueCard = cards && cards[1] ? cards[1] : null;
      if(!queueCard) return;
      if(!document.getElementById('reviewCreateBtn')){
        const row = document.createElement('div'); row.className='row wrap';
        const btn = document.createElement('button'); btn.id='reviewCreateBtn'; btn.className='ghost'; btn.textContent='誤答復習キュー作成';
        row.appendChild(btn);
        queueCard.appendChild(row);
        btn.addEventListener('click', ()=>{
          try{
            const pk = currentPath();
            const enabledArr = (typeof getEnabledArrCurrent==='function') ? getEnabledArrCurrent() : (store.kifuByPath[pk]||[]).filter(k=>k.enabled!==false);
            if(!enabledArr.length){ alert('出題オンの棋譜がありません'); return; }
            const N = parseInt(prompt('上位いくつ入れますか？（既定：20）', String(OPT('reviewN', 20)))||'0', 10) || OPT('reviewN', 20);
            SETOPT('reviewN', N);
            const ranked = enabledArr.filter(k => (k.stats?.mistakes||0)>0).sort((a,b)=>{
              const ra=(a.stats?.mistakes||0)/Math.max(1,(a.stats?.attempts||0));
              const rb=(b.stats?.mistakes||0)/Math.max(1,(b.stats?.attempts||0));
              if(rb!==ra) return rb-ra;
              return (b.stats?.mistakes||0)-(a.stats?.mistakes||0);
            });
            const ids = ranked.slice(0, N).map(k=>k.id);
            if(!ids.length){ alert('誤答のある問題がありません'); return; }
            store.queueByPath[pk] = ids; saveStore(store); updateQueueView();
            try{ const sel=document.getElementById('pickMode'); if(sel) sel.value='QUEUE'; }catch(_){}
            showToast('誤答復習キューを作成しました（' + ids.length + '件）');
          }catch(e){ alert('処理中にエラーが発生しました'); }
        });
      }
    }catch(_){}
  })();

  // ---- KIFU一覧：タグ一括 & 表示中エクスポート ----
  (function(){
    function ensureButtons(){
      const hdr = document.querySelector('#kifuModal .klist-controls');
      if(!hdr) return;
      let box = document.getElementById('bulkOps');
      if(!box){
        box = document.createElement('span'); box.id='bulkOps';
        box.style.display='inline-flex'; box.style.gap='6px'; box.style.flexWrap='wrap'; box.style.marginLeft='8px';
        hdr.appendChild(box);
      }
      function addBtn(id, text, handler){
        if(document.getElementById(id)) return;
        const b = document.createElement('button'); b.id=id; b.className='ghost tiny'; b.textContent=text;
        b.addEventListener('click', handler); box.appendChild(b);
      }
      function currentFiltered(){ const pk=currentPath(); const arr=getSortedArray(pk); return { pk, arr }; }
      addBtn('bulkTagAddBtn', '表示中→タグ追加', ()=>{
        const raw = prompt('追加するタグ（空白/カンマ区切り）', '');
        if(!raw) return;
        const tags = raw.split(/[,\s]+/).map(s=>s.trim()).filter(Boolean);
        const { pk, arr } = currentFiltered();
        arr.forEach(k=>{ const set = new Set(k.tags||[]); tags.forEach(t=>set.add(t)); k.tags=Array.from(set); });
        saveStore(store); try{ renderKifuList(); }catch(_){}
        showToast('タグを追加しました');
      });
      addBtn('bulkTagDelBtn', '表示中→タグ削除', ()=>{
        const raw = prompt('削除するタグ（空白/カンマ区切り）', '');
        if(!raw) return;
        const del = new Set(raw.split(/[,\s]+/).map(s=>s.trim()).filter(Boolean));
        const { pk, arr } = currentFiltered();
        arr.forEach(k=>{ k.tags=(k.tags||[]).filter(t=>!del.has(t)); });
        saveStore(store); try{ renderKifuList(); }catch(_){}
        showToast('タグを削除しました');
      });
      addBtn('exportFilteredBtn', 'エクスポート（表示中）', ()=>{
        const { pk, arr } = currentFiltered();
        if(!arr.length){ alert('対象がありません'); return; }
        const payload = {
          type:'reversi_trainer_filtered_export_v1',
          exportedAt: new Date().toISOString(),
          path: pk,
          filter: {
            text: (document.getElementById('searchInput')?.value||''),
            tags: (window._v8TagFilter?.words||[]),
            or: (window._v8TagFilter?.or||false)
          },
          kifu: arr,
          queue: getQueueByPath(pk)
        };
        const blob = new Blob([JSON.stringify(payload,null,2)], {type:'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href=url; a.download=(pk.replaceAll('/','__')||'folder')+'_filtered_export.json';
        document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url), 1000);
      });
    }
    if(typeof window.openKifuModal==='function'){
      const orig = window.openKifuModal;
      window.openKifuModal = function(){ orig(); setTimeout(ensureButtons, 0); };
    }else{
      ensureButtons();
    }
  })();

  // ---- SRS評価（SM-2方式の0-5ボタン） ----
  (function(){
    function updateSrsSM2(k, q){
      try{
        k.srsEF = (typeof k.srsEF==='number' && isFinite(k.srsEF)) ? k.srsEF : 2.5;
        k.srsReps = (k.srsReps|0);
        k.srsIntervalDays = (k.srsIntervalDays|0) || 0;
        if(q < 3){
          k.srsReps = 0;
          k.srsIntervalDays = 1;
        }else{
          if(k.srsReps === 0){ k.srsIntervalDays = 1; }
          else if(k.srsReps === 1){ k.srsIntervalDays = 6; }
          else { k.srsIntervalDays = Math.max(1, Math.round(k.srsIntervalDays * k.srsEF)); }
          k.srsReps += 1;
          k.srsEF = k.srsEF + (0.1 - (5 - q)*(0.08 + (5 - q)*0.02));
          if(k.srsEF < 1.3) k.srsEF = 1.3;
        }
        k.srsDue = Date.now() + Math.max(1, k.srsIntervalDays)*dayMs;
        k.srsAlgo = 'SM2';
      }catch(_){}
    }
    if(typeof window.showCelebrate==='function' && !window._v12_srs_patched){
      const orig = window.showCelebrate;
      window.showCelebrate = function(total, mistakes){
        const out = orig(total, mistakes);
        try{
          const box = document.getElementById('resultInfo');
          if(!box) return out;
          let row = document.getElementById('srsRatingRow');
          if(row) row.remove();
          row = document.createElement('div'); row.className='field'; row.id='srsRatingRow';
          const lab = document.createElement('label'); lab.className='small'; lab.textContent='SRS評価（0=忘れた〜5=余裕）';
          const btns = document.createElement('div'); btns.className='row wrap';
          for(let q=0;q<=5;q++){
            const b=document.createElement('button'); b.className='ghost tiny'; b.textContent=String(q);
            b.addEventListener('click', ()=>{
              try{
                const pk=currentPath(); const arr=store.kifuByPath[pk]||[]; const k=arr.find(x=>x.id===currentKifuId); if(!k) return;
                updateSrsSM2(k, q); saveStore(store);
                showToast('SRSを更新しました（評価 ' + q + '）');
                try{ if(window.updateSrsDueCount) window.updateSrsDueCount(); if(window._v10_computeGlobalSrsDue) window._v10_computeGlobalSrsDue(); }catch(_){}
              }catch(_){}
            });
            btns.appendChild(b);
          }
          row.appendChild(lab); row.appendChild(btns);
          box.appendChild(row);
        }catch(_){}
        return out;
      };
      window._v12_srs_patched = true;
    }
  })();

})(); // end v12
</script>
<!-- ===== v13 Addons by ChatGPT (2025-10-19) ===== -->
<style>
/* v13: focus mode and small UI tweaks */
body.focus-only .grid > .panel:first-child{ display:none; }
body.focus-only .dockGrid{ display:none; }
body.focus-only #boardWrap{ box-shadow: 0 0 0 3px #8ab4ff inset; }
.topbar .ghost.tiny{ font-size: 0.80rem; padding: 2px 8px; }
</style>
<script>
(function(){
  try{
    // [refactor] removed version bump
    // [refactor] removed version bump
  }catch(_){}

  const topbar = document.querySelector('.topbar');
  if(topbar){
    function mkBtn(id, text){ if(document.getElementById(id)) return document.getElementById(id); const b=document.createElement('button'); b.id=id; b.className='ghost tiny'; b.textContent=text; topbar.appendChild(b); return b; }
    const focusBtn = mkBtn('focusBtn','集中モード'); focusBtn.addEventListener('click', ()=>{ document.body.classList.toggle('focus-only'); focusBtn.textContent = document.body.classList.contains('focus-only') ? '通常表示' : '集中モード'; });
    const dupBtn = mkBtn('dupBtn','重複チェック'); dupBtn.addEventListener('click', showDupReport);
    const shareBtn = mkBtn('shareBtn','共有（今の問題）'); shareBtn.addEventListener('click', shareCurrentKifu);
    if(!document.getElementById('streakStat')){
      const span = document.createElement('span'); span.className = 'stat'; span.id='streakStat'; span.innerHTML='🔥 連続：<b id="streakDays">0</b>日｜本日：<b id="todaySolved">0</b>';
      topbar.appendChild(span); updateStreak();
    }
  }

  
  function dateKey(d){ const y=d.getFullYear(); const m=String(d.getMonth()+1).padStart(2,'0'); const dd=String(d.getDate()).padStart(2,'0'); return y+'-'+m+'-'+dd; }
  function updateStreak(){
    try{
      const logs = getLogs().filter(r => r && r.solved);
      const map = {}; logs.forEach(r => { if(r.timestamp){ const day = String(r.timestamp).slice(0,10); map[day] = (map[day]||0) + 1; } });
      const today = new Date(); const todayKey = dateKey(today);
      const todayCnt = map[todayKey]||0;
      let streak = 0;
      for(let i=0;i<3650;i++){
        const d = new Date(); d.setDate(today.getDate()-i);
        const k = dateKey(d);
        if(map[k]>0) streak++; else break;
      }
      const el1=document.getElementById('streakDays'); const el2=document.getElementById('todaySolved');
      if(el1) el1.textContent=String(streak);
      if(el2) el2.textContent=String(todayCnt);
    }catch(_){}
  }
  window._v13_updateStreak = updateStreak;

  function undoOne(){
    try{
      if(!window.training) return;
      const newIdx = Math.max((window.rangeStart||1)-1, (window.moveIndex||0)-1);
      if(newIdx === window.moveIndex) return;
      window.setPositionByTokenIndex(newIdx);
      window.training = true;
      window.setStatus('1手戻しました（' + (newIdx+1) + '手目）');
      window.renderBoard(); window.setProgress();
    }catch(_){}
  }
  window.addEventListener('keydown', (e)=>{
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
    if(tag==='input' || tag==='textarea' || tag==='select') return;
    if(e.key==='u' || e.key==='U'){ e.preventDefault(); undoOne(); }
    else if(e.key==='Backspace'){ try{ if(!window._kbdBuf){ e.preventDefault(); undoOne(); } }catch(_){ e.preventDefault(); undoOne(); } }
    else if(e.key==='p' || e.key==='P'){ try{ manualPass(); }catch(_){} }
  }, {capture:true});

  (function(){
    const cards = document.querySelectorAll('.dockGrid .card');
    const settingsCard = cards && cards[0] ? cards[0] : null;
    if(settingsCard && !document.getElementById('passBtn')){
      const row = document.createElement('div'); row.className='row wrap';
      const b = document.createElement('button'); b.id='passBtn'; b.className='ghost'; b.textContent='PASS';
      b.title = '合法手がない時のみ有効';
      b.addEventListener('click', manualPass);
      row.appendChild(b); settingsCard.appendChild(row);
    }
  })();
  function manualPass(){
    try{
      if(!window.training) return showToast('トレーニング中ではありません');
      const LM = legalMoves(board, currentPlayer);
      if(LM.length>0){ showToast('合法手があるためPASSできません'); return; }
      const token = (window.expectedMoves && window.expectedMoves[window.moveIndex]) || null;
      if(token!=='P' && token!=='PASS'){ showToast('この手番はPASS指定ではありません'); return; }
      window.currentPlayer = -window.currentPlayer; window.moveIndex++;
      window.setProgress(); window.renderBoard(); window.stepIfAIShouldPlay();
    }catch(_){}
  }

  function showDupReport(){
    try{
      const sigMap = {}; const pathMap = {};
      Object.entries(store.kifuByPath||{}).forEach(([pk, arr])=>{
        (arr||[]).forEach((k, idx)=>{
          const sig = k.sig || (k.moves?canonicalSignature(k.moves):'');
          if(!sig) return;
          if(!sigMap[sig]){ sigMap[sig] = []; }
          sigMap[sig].push({pk, id:k.id, name:k.name||'', idx: (typeof k._idx==='number'?(k._idx+1):(idx+1))});
        });
      });
      const dups = Object.entries(sigMap).filter(([, list])=> list.length>1);
      if(!dups.length){ alert('重複は見つかりませんでした'); return; }
      let msg = '重複が見つかりました：' + dups.length + '組\n\n';
      dups.slice(0,50).forEach(([sig, list], i)=>{
        msg += '--- #' + (i+1) + ' ---\n';
        list.forEach(x=>{ msg += '  '+x.pk+'  #'+x.idx+'  '+(x.name||'（無名）')+'\n'; });
        if(i===49 && dups.length>50) msg += '… ('+(dups.length-50)+' 組 省略)\n';
      });
      msg += '\n※ 同一小フォルダ内の重複を整理できます。';
      if(confirm(msg + '\n\n表示中の小フォルダ内で、後ろにある重複を削除しますか？')){
        const pk = currentPath();
        const arr = store.kifuByPath[pk] || [];
        const seen = new Set();
        for(let i=0;i<arr.length;i++){
          const sig = arr[i].sig; if(!sig){ continue; }
          if(seen.has(sig)){ arr.splice(i,1); i--; }
          else { seen.add(sig); }
        }
        arr.forEach((k,i)=> k._idx = i);
        saveStore(store); updateCountsAndPath(); try{ renderKifuList(); }catch(_){}
        alert('重複を整理しました');
      }
    }catch(e){ alert('重複チェックでエラーが発生しました'); }
  }

  async function shareCurrentKifu(){
    try{
      const pk = currentPath();
      const arr = store.kifuByPath[pk] || [];
      const k = arr.find(x=>x.id===currentKifuId);
      if(!k){ alert('現在の問題がありません'); return; }
      const payload = { type:'reversi_trainer_share_v1', path: pk, kifu: k };
      const txt = JSON.stringify(payload, null, 2);
      await navigator.clipboard.writeText(txt);
      showToast('クリップボードに共有JSONをコピーしました');
    }catch(e){ alert('共有に失敗しました'); }
  }

  if(typeof window.showCelebrate === 'function' && !window._v13_celebrate_patched){
    const orig = window.showCelebrate;
    window.showCelebrate = function(total, mistakes){
      const out = orig(total, mistakes);
      try{ updateStreak(); }catch(_){}
      return out;
    };
    window._v13_celebrate_patched = true;
  }

})(); // end v13
</script>
<!-- ===== v14 Addons by ChatGPT (2025-10-19) ===== -->
<style>
/* v14: XP/Level, Achievements, Daily Missions, Share Card */
.stat.xp { background:#fff8e1; border-color:#ffe0a3; }
.xpwrap{ display:inline-flex; align-items:center; gap:8px; }
.xpbar{ width:120px; height:6px; border-radius:999px; background:#f0f0f0; overflow:hidden; box-shadow:inset 0 0 0 1px rgba(0,0,0,0.06); }
.xpbar .fill{ height:100%; width:0%; background:linear-gradient(90deg,#ffd54f,#ffb300); transition:width .4s ease; }
.modal .grid-achi{ display:grid; grid-template-columns:repeat(auto-fill,minmax(200px,1fr)); gap:10px; }
.achi-card{ border:1px solid #eee; border-radius:10px; padding:10px; background:#fff; display:grid; gap:4px; }
body.theme-dark .achi-card{ background:#151a1f; border-color:#2a2f3a; }
.achi-card.locked{ opacity:.55; }
.achi-title{ font-weight:700; }
.achi-desc{ font-size:.9rem; color:#666; }
body.theme-dark .achi-desc{ color:#a9b2c3; }

/* Daily mission modal */
.mission-progress{ display:grid; gap:8px; }
.mission-row{ display:grid; grid-template-columns: 140px 1fr auto; gap:10px; align-items:center; }
.mbar{ height:8px; border-radius:999px; background:#e8f0ff; overflow:hidden; border:1px solid #d0defc; }
.mbar .fill{ height:100%; width:0%; background:linear-gradient(90deg,#8ab4ff,#2563eb); transition:width .3s ease; }
.badge{ display:inline-block; padding:2px 6px; border-radius:999px; font-size:.8rem; border:1px solid #ddd; background:#fafafa; }
body.theme-dark .badge{ background:#1a2028; border-color:#2a2f3a; }

/* Share-card toast */
.share-tip{ font-size:.86rem; color:#666; }
body.theme-dark .share-tip{ color:#a9b2c3; }
</style>
<script>
(function(){
  // ========= Helpers =========
  if(typeof window.showToast!=='function'){ window.showToast = function(msg){ try{ console.log('[toast]', msg); }catch(_){ } }; }
  const K = (k)=> STORE_PREFIX + 'opt14_' + k;
  const JGET = (k,d)=>{ try{ const v=localStorage.getItem(K(k)); return v==null?d:JSON.parse(v);}catch(_){ return d; } };
  const JSET = (k,v)=>{ try{ localStorage.setItem(K(k), JSON.stringify(v)); }catch(_){ } };
  const now = ()=> Date.now();
  const fmt2 = (n)=> String(n).padStart(2,'0');
  function todayKey(){
    const d = new Date();
    return d.getFullYear()+'-'+fmt2(d.getMonth()+1)+'-'+fmt2(d.getDate());
  }

  // ========= XP / Level =========
  const xpState = JGET('xpState', { level:1, xp:0, next:120 });
  function xpToNext(lv){ return Math.round(120 + 80*Math.pow(1.12, Math.max(0, lv-1))); }
  function ensureXpState(){
    if(typeof xpState.level!=='number' || !isFinite(xpState.level)) xpState.level = 1;
    if(typeof xpState.xp!=='number' || !isFinite(xpState.xp)) xpState.xp = 0;
    if(typeof xpState.next!=='number' || !isFinite(xpState.next)) xpState.next = xpToNext(xpState.level);
  }
  ensureXpState();

  // UI: topbar badge + progress
  (function ensureTopbarXP(){
    const topbar = document.querySelector('.topbar');
    if(!topbar) return;
    if(!document.getElementById('xpStat')){
      const span = document.createElement('span'); span.className='stat xp'; span.id='xpStat';
      span.innerHTML = '<span class="xpwrap">🎮 Lv <b id="lvNum">1</b> <span class="xpbar"><span id="xpFill" class="fill"></span></span> <span class="small" id="xpText">0/120</span></span>';
      topbar.appendChild(span);
    }
    if(!document.getElementById('achiBtn')){
      const b = document.createElement('button'); b.className='ghost tiny'; b.id='achiBtn'; b.textContent='実績';
      b.addEventListener('click', openAchievements); topbar.appendChild(b);
    }
    if(!document.getElementById('missionBtn')){
      const b = document.createElement('button'); b.className='ghost tiny'; b.id='missionBtn'; b.textContent='ミッション';
      b.addEventListener('click', openMission); topbar.appendChild(b);
    }
    updateXpUI();
  })();

  function updateXpUI(){
    try{
      const lv = document.getElementById('lvNum');
      const fill = document.getElementById('xpFill');
      const text = document.getElementById('xpText');
      if(lv) lv.textContent = String(xpState.level);
      if(text) text.textContent = (Math.round(xpState.xp)) + '/' + xpState.next;
      if(fill) fill.style.width = Math.min(100, 100*xpState.xp/Math.max(1,xpState.next)) + '%';
    }catch(_){}
  }

  function grantXP(amount, reason){
    try{
      amount = Math.max(1, Math.round(amount));
      xpState.xp += amount;
      let leveled = false;
      while(xpState.xp >= xpState.next){
        xpState.xp -= xpState.next;
        xpState.level += 1;
        xpState.next = xpToNext(xpState.level);
        leveled = true;
      }
      JSET('xpState', xpState);
      updateXpUI();
      showToast('XP +' + amount + (reason? ('｜' + reason):''));
      if(leveled){
        try{ speakJa && speakJa('レベルアップ'); }catch(_){}
        try{
          const cele = document.getElementById('celebrate');
          if(cele){
            const msg = document.getElementById('celebrateMsg');
            const base = msg ? msg.textContent : '';
            if(msg) msg.textContent = base + '｜🎉 Lv.' + xpState.level + ' !';
          }
        }catch(_){}
      }
      window._v14_lastXpGain = amount;
    }catch(_){}
  }

  // ========= Achievements =========
  const ACH = {
    FIRST_CLEAR: { title:'初クリア', desc:'はじめてミスなしでクリア', icon:'🌱' },
    TEN_NO_MISS:{ title:'完璧主義', desc:'ミスなしクリアを累計10回', icon:'🎯' },
    SPEEDSTER:  { title:'スピードスター', desc:'12手以上の範囲を15秒以内でクリア', icon:'⚡' },
    MARATHON:   { title:'ロングラン', desc:'40手以上をミスなしでクリア', icon:'🏁' },
    NIGHT_OWL:  { title:'夜更かし', desc:'23:00〜05:00にミスなしでクリア', icon:'🌙' },
    STREAK_7:   { title:'7日ストリーク', desc:'7日連続でクリア達成', icon:'🔥' },
    DUE_MASTER: { title:'SRS消化職人', desc:'SRS期限の問題を1日に10件クリア', icon:'📆' },
  };
  function getAch(){ return JGET('ach', {}); }
  function setAch(m){ JSET('ach', m||{}); }
  function unlock(id){
    const m = getAch();
    if(m[id]) return false;
    m[id] = { at: new Date().toISOString() };
    setAch(m);
    showToast('実績解除：' + (ACH[id]?.title||id));
    try{ speakJa && speakJa('実績解除'); }catch(_){}
    return true;
  }
  function countPerfectClears(){
    try{
      const logs = JSON.parse(localStorage.getItem(STORE_PREFIX+'opt10_logs')||'[]');
      return logs.filter(r => r && r.solved && (r.mistakes|0)===0).length;
    }catch(_){ return 0; }
  }
  function computeStreak(){
    try{
      const logs = JSON.parse(localStorage.getItem(STORE_PREFIX+'opt10_logs')||'[]');
      const solvedDays = new Set();
      (logs||[]).forEach(r => { if(r && r.solved && r.timestamp){ solvedDays.add(String(r.timestamp).slice(0,10)); } });
      const d = new Date(); let streak = 0;
      for(let i=0;i<3650;i++){
        const t = new Date(d); t.setDate(d.getDate()-i);
        const key = t.getFullYear()+'-'+fmt2(t.getMonth()+1)+'-'+fmt2(t.getDate());
        if(solvedDays.has(key)) streak++; else break;
      }
      return streak;
    }catch(_){ return 0; }
  }

  // Modal for achievements
  function ensureAchModal(){
    if(document.getElementById('achModal')) return;
    const modal = document.createElement('div'); modal.className='modal'; modal.id='achModal';
    modal.innerHTML = '<div class="window">\
      <header><h3>実績</h3><button class="ghost" id="achCloseBtn">閉じる</button></header>\
      <div class="body"><div id="achBody" class="grid-achi"></div></div>\
      <div class="footer"><span class="small muted">ミスなし・速度・ストリークなどで解除されます。</span></div>\
    </div>';
    document.body.appendChild(modal);
    modal.addEventListener('click', (e)=>{ if(e.target===modal) modal.style.display='none'; });
    modal.querySelector('#achCloseBtn').addEventListener('click', ()=> modal.style.display='none');
  }
  function openAchievements(){
    ensureAchModal();
    const modal = document.getElementById('achModal');
    const body = document.getElementById('achBody');
    const owned = getAch();
    body.innerHTML='';
    Object.keys(ACH).forEach(id=>{
      const a = ACH[id];
      const card = document.createElement('div'); card.className='achi-card' + (owned[id]?'':' locked');
      const t = document.createElement('div'); t.className='achi-title'; t.textContent = (a.icon||'🏆') + ' ' + a.title;
      const d = document.createElement('div'); d.className='achi-desc'; d.textContent = a.desc + (owned[id]? ('｜解除日：' + (owned[id].at||'')) : '');
      card.appendChild(t); card.appendChild(d); body.appendChild(card);
    });
    modal.style.display='flex';
  }

  // ========= Daily Missions =========
  function getMission(){
    const key = 'mission_'+todayKey();
    let m = JGET(key, null);
    if(!m){
      const dueCount = computeGlobalDue();
      m = { createdAt: now(), goals:{ srs: Math.min(10, Math.max(3, dueCount)), unsolved: 3, any: 7 }, progress:{ srs:0, unsolved:0, any:0 }, done:false };
      JSET(key, m);
    }
    return m;
  }
  function setMission(m){ JSET('mission_'+todayKey(), m); }
  function computeGlobalDue(){
    try{
      const all = store && store.kifuByPath ? store.kifuByPath : {};
      const t = Date.now();
      let cnt = 0;
      Object.values(all).forEach(arr => (arr||[]).forEach(k => { if(k && k.enabled!==false && typeof k.srsDue==='number' && k.srsDue <= t) cnt++; }));
      return cnt;
    }catch(_){ return 0; }
  }
  function ensureMissionModal(){
    if(document.getElementById('missionModal')) return;
    const modal = document.createElement('div'); modal.className='modal'; modal.id='missionModal';
    modal.innerHTML = '<div class="window">\
      <header><h3>デイリーミッション</h3><button class="ghost" id="missionCloseBtn">閉じる</button></header>\
      <div class="body">\
        <div id="missionBody" class="mission-progress"></div>\
        <div class="small muted">「今日のメニュー」でキューに積むと進めやすいです。SRSは期限の問題を優先してカウントします。</div>\
      </div>\
      <div class="footer"><div class="row">\
        <button class="ghost" id="missionRebuildBtn">今日のメニューを作る</button>\
        <button class="ghost" id="missionResetBtn">本日のミッションを再生成</button>\
      </div></div>\
    </div>';
    document.body.appendChild(modal);
    modal.addEventListener('click', (e)=>{ if(e.target===modal) modal.style.display='none'; });
    modal.querySelector('#missionCloseBtn').addEventListener('click', ()=> modal.style.display='none');
    const rebuild = modal.querySelector('#missionRebuildBtn');
    if(rebuild) rebuild.addEventListener('click', ()=>{ try{ (window.buildTodayPlaylist||function(){ alert('v12の「今日のメニュー」機能が必要です'); })(); }catch(_){ } });
    const reset = modal.querySelector('#missionResetBtn');
    if(reset) reset.addEventListener('click', ()=>{ localStorage.removeItem(K('mission_'+todayKey())); openMission(true); });
  }
  function openMission(force){
    ensureMissionModal();
    if(force===true){ /* no-op */ }
    const modal = document.getElementById('missionModal');
    const body = document.getElementById('missionBody');
    const m = getMission();
    function row(label, key){
      const g = m.goals[key], p = m.progress[key]||0;
      const div = document.createElement('div'); div.className='mission-row';
      const name = document.createElement('div'); name.innerHTML = '<span class="badge">' + (key==='srs'?'SRS':key==='unsolved'?'未クリア':'おまかせ') + '</span> ' + label;
      const bar = document.createElement('div'); bar.className='mbar'; const fill = document.createElement('div'); fill.className='fill'; bar.appendChild(fill);
      fill.style.width = (Math.min(100, 100*p/Math.max(1,g))) + '%';
      const txt = document.createElement('div'); txt.className='small'; txt.textContent = p + ' / ' + g;
      div.appendChild(name); div.appendChild(bar); div.appendChild(txt);
      return div;
    }
    body.innerHTML='';
    body.appendChild(row('期限のある問題を解く', 'srs'));
    body.appendChild(row('未クリアの問題を新規クリア', 'unsolved'));
    body.appendChild(row('その他の練習をこなす', 'any'));
    modal.style.display='flex';
    updateMissionBadge();
  }
  function updateMissionBadge(){
    try{
      const m = getMission();
      const done = (m.progress.srs>=m.goals.srs) && (m.progress.unsolved>=m.goals.unsolved) && (m.progress.any>=m.goals.any);
      const btn = document.getElementById('missionBtn');
      if(btn){
        const sum = Math.min(m.progress.srs, m.goals.srs) + Math.min(m.progress.unsolved, m.goals.unsolved) + Math.min(m.progress.any, m.goals.any);
        const target = m.goals.srs + m.goals.unsolved + m.goals.any;
        btn.textContent = 'ミッション ' + sum + '/' + target;
      }
      if(done && !m.done){
        m.done = true; setMission(m);
        grantXP(24, 'デイリーミッションクリア');
        try{ speakJa && speakJa('デイリーミッション達成'); }catch(_){}
      }
    }catch(_){}
  }

  // Capture context at start to classify for mission
  window._v14_ctx = { wasSrsDue:false, wasUnsolved:false };
  if(typeof window.startTrainingCore === 'function' && !window._v14_start_wrap){
    const orig = window.startTrainingCore;
    window.startTrainingCore = function(picked){
      try{
        const pk = currentPath(); const arr = store.kifuByPath[pk] || [];
        const k = arr.find(x=> x.id===picked.id);
        window._v14_ctx.wasSrsDue = !!(k && typeof k.srsDue==='number' && k.srsDue <= Date.now());
        window._v14_ctx.wasUnsolved = !!(k && !isCleared(k));
      }catch(_){ window._v14_ctx.wasSrsDue=false; window._v14_ctx.wasUnsolved=false; }
      return orig(picked);
    };
    window._v14_start_wrap = true;
  }

  // ========= Hook celebrate to award XP, achievements, mission =========
  if(typeof window.showCelebrate === 'function' && !window._v14_celeb_wrap){
    const origSC = window.showCelebrate;
    window.showCelebrate = function(total, mistakes){
      const out = origSC(total, mistakes);
      try{
        const ms = (window._v9 && _v9.timerStart) ? Math.max(0, Date.now() - _v9.timerStart) : null;
        const sec = ms!=null ? ms/1000 : null;

        // XP: base on length, quality, speed, SRS
        let xp = 5 + Math.round(total/4);
        if(mistakes===0) xp += 8;
        if(sec!=null && sec <= Math.max(8, Math.ceil(total*0.9))) xp += 4; // speed bonus
        const pk = currentPath(); const arr = store.kifuByPath[pk] || []; const k = arr.find(x=>x.id===currentKifuId);
        if(k && typeof k.srsDue==='number' && k.srsDue <= Date.now()) xp += 6; // SRS due bonus
        grantXP(xp, (mistakes===0?'ノーミス':'完了'));

        // Coach tip
        try{
          const infoBox = document.getElementById('resultInfo');
          if(infoBox && !document.getElementById('coachRow')){
            const row = document.createElement('div'); row.className='field'; row.id='coachRow';
            const lab = document.createElement('label'); lab.className='small'; lab.textContent='コーチから一言';
            const p = document.createElement('div'); p.className='small muted';
            let msg = 'いい流れ！この調子でいこう。';
            if(mistakes===0 && sec!=null){ msg = (sec<total)?'速い！手のパターンが身体に入っています。':'安定感あり。次は少しだけスピードを意識。'; }
            else if(mistakes>0){ msg = 'ミスは宝。ヒートマップの赤いマスを重点的に復習しよう。'; }
            p.textContent = msg; row.appendChild(lab); row.appendChild(p); infoBox.appendChild(row);
          }
        }catch(_){}

        // Achievements
        try{
          if(mistakes===0) unlock('FIRST_CLEAR');
          if(mistakes===0 && countPerfectClears()>=10) unlock('TEN_NO_MISS');
          if(mistakes===0 && total>=40) unlock('MARATHON');
          if(mistakes===0 && sec!=null && total>=12 && sec<=15) unlock('SPEEDSTER');
          const hour = (new Date()).getHours(); if(mistakes===0 && (hour>=23 || hour<5)) unlock('NIGHT_OWL');
          if(computeStreak()>=7) unlock('STREAK_7');
        }catch(_){}

        // Mission progress
        try{
          const m = getMission();
          if(mistakes===0){
            if(window._v14_ctx.wasSrsDue) m.progress.srs = Math.min(m.goals.srs, (m.progress.srs||0)+1);
            else if(window._v14_ctx.wasUnsolved) m.progress.unsolved = Math.min(m.goals.unsolved, (m.progress.unsolved||0)+1);
            else m.progress.any = Math.min(m.goals.any, (m.progress.any||0)+1);
            setMission(m);
            updateMissionBadge();
            // Sub goal reward thresholds
            const r = [];
            if(m.progress.srs===m.goals.srs) r.push('SRS');
            if(m.progress.unsolved===m.goals.unsolved) r.push('未クリア');
            if(m.progress.any===m.goals.any) r.push('おまかせ');
            if(r.length){ grantXP(6, r.join('・')+' 完了'); }
          }
        }catch(_){}

        // Add share image button
        try{
          const actions = document.querySelector('#celebrate .actions');
          if(actions && !document.getElementById('shareCardBtn')){
            const b = document.createElement('button'); b.id='shareCardBtn'; b.className='ghost'; b.textContent='シェア画像を保存';
            b.addEventListener('click', saveShareCard);
            actions.insertBefore(b, actions.firstChild);
            const tip = document.createElement('div'); tip.className='share-tip'; tip.textContent='結果をSNS等に共有できる画像を生成します。';
            actions.parentNode.appendChild(tip);
          }
        }catch(_){}

      }catch(_){}
      return out;
    };
    window._v14_celeb_wrap = true;
  }

  // ========= Share Card (PNG) =========
  function saveShareCard(){
    try{
      const cell = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell')) || 56;
      const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 2;
      const N = 8, boardSize = N*cell + (N-1)*gap;
      const pad = 24, W = boardSize + pad*2, H = boardSize + 140;
      const cvs = document.createElement('canvas'); cvs.width = W; cvs.height = H;
      const ctx = cvs.getContext('2d');

      // bg
      ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg') || '#ffffff';
      ctx.fillRect(0,0,W,H);

      // title
      ctx.fillStyle = '#111'; if(document.body.classList.contains('theme-dark')) ctx.fillStyle = '#e7ebf3';
      ctx.font = 'bold 20px system-ui, -apple-system, Segoe UI, Roboto, Noto Sans JP, sans-serif';
      ctx.fillText('オセロ暗記トレーナー v14', pad, 28);

      // board draw (reuse simplified painter)
      function drawBoard(x0, y0){
        ctx.save(); ctx.translate(x0, y0);
        ctx.fillStyle = '#0a5a2a'; ctx.fillRect(0,0,boardSize,boardSize);
        for(let r=0;r<N;r++){
          for(let c=0;c<N;c++){
            const x = c*(cell+gap);
            const y = r*(cell+gap);
            ctx.fillStyle = '#1e7a3b';
            const rad = 6, w=cell, h=cell;
            ctx.beginPath();
            ctx.moveTo(x+rad, y);
            ctx.arcTo(x+w, y, x+w, y+h, rad);
            ctx.arcTo(x+w, y+h, x, y+h, rad);
            ctx.arcTo(x, y+h, x, y, rad);
            ctx.arcTo(x, y, x+w, y, rad);
            ctx.closePath(); ctx.fill();
          }
        }
        for(let r=0;r<N;r++){
          for(let c=0;c<N;c++){
            const v = (window.board && board[r]) ? board[r][c] : 0;
            if(!v) continue;
            const x = c*(cell+gap) + cell/2;
            const y = r*(cell+gap) + cell/2;
            const radius = cell*0.41;
            ctx.beginPath(); ctx.arc(x,y,radius,0,Math.PI*2);
            ctx.fillStyle = (v===1) ? '#111' : '#eee'; ctx.fill();
            ctx.globalAlpha = 0.15;
            ctx.beginPath(); ctx.arc(x - radius*0.35, y - radius*0.35, radius*0.65, 0, Math.PI*2);
            ctx.fillStyle = '#fff'; ctx.fill(); ctx.globalAlpha = 1;
          }
        }
        ctx.restore();
      }
      drawBoard(pad, 44);

      // meta
      const ms = (window._v9 && _v9.timerStart) ? Math.max(0, Date.now() - _v9.timerStart) : null;
      const sec = ms!=null ? (ms/1000).toFixed(2)+'s' : '—';
      const total = Math.max(0, (window.rangeEnd||0) - (window.rangeStart||1) + 1);
      const mistakes = (typeof window.sessionMistakes==='number') ? window.sessionMistakes : 0;
      const xp = window._v14_lastXpGain || 0;

      ctx.font = '14px system-ui, -apple-system, Segoe UI, Roboto, Noto Sans JP, sans-serif';
      ctx.fillText('範囲：' + (window.rangeStart||1) + '〜' + (window.rangeEnd||0) + '（全' + total + '手）', pad, H - 86);
      ctx.fillText('誤答：' + mistakes + '回', pad, H - 66);
      ctx.fillText('タイム：' + sec, pad, H - 46);
      ctx.fillText('XP +' + xp + ' ｜ Lv.' + (JGET('xpState', xpState).level||1), pad, H - 26);

      const url = cvs.toDataURL('image/png');
      const a = document.createElement('a'); a.href=url;
      const dt = new Date();
      const y = dt.getFullYear(), m = String(dt.getMonth()+1).padStart(2,'0'), d=String(dt.getDate()).padStart(2,'0');
      a.download = 'reversi_share_'+y+m+d+'.png';
      document.body.appendChild(a); a.click(); a.remove();
    }catch(e){ alert('シェア画像の生成に失敗しました'); }
  }

  // ========= Tag mastery injected into Stats =========
  function injectTagMastery(){
    try{
      const modal = document.getElementById('statsModal');
      if(!modal || modal.style.display!=='flex') return;
      const body = document.getElementById('statsBody');
      if(!body || document.getElementById('tagMasteryBox')) return;
      const pk = currentPath(); const arr = store.kifuByPath[pk] || [];
      const map = {}; // tag -> {attempts, solved, mistakes}
      arr.forEach(k => {
        const tags = (k.tags||[]);
        const st = k.stats||{};
        tags.forEach(t => {
          const o = map[t] || (map[t] = {attempts:0, solved:0, mistakes:0, count:0});
          o.attempts += (st.attempts||0);
          o.solved += (st.solved||0);
          o.mistakes += (st.mistakes||0);
          o.count += 1;
        });
      });
      const tags = Object.keys(map);
      if(!tags.length) return;
      const box = document.createElement('div'); box.id='tagMasteryBox'; box.className='field';
      box.innerHTML = '<b>タグ別マスタリー</b>';
      tags.sort((a,b)=> (map[b].solved/Math.max(1,map[b].attempts)) - (map[a].solved/Math.max(1,map[a].attempts)));
      tags.slice(0,12).forEach(t => {
        const o=map[t]; const rate = o.attempts? ((o.solved/o.attempts*100).toFixed(0)+'%') : '—';
        const row = document.createElement('div'); row.className='small';
        const medal = o.solved>=20 ? '🥇' : o.solved>=10 ? '🥈' : o.solved>=5 ? '🥉' : '▫️';
        row.textContent = medal + ' #' + t + '｜正解率 ' + rate + '｜試行 ' + o.attempts + '｜正解 ' + o.solved + '｜問題数 ' + o.count;
        box.appendChild(row);
      });
      body.appendChild(box);
    }catch(_){}
  }
  // hook the "統計" button to inject after open
  (function hookStatsButton(){
    const btn = document.getElementById('openStatsBtn');
    if(btn && !btn.dataset.v14){
      btn.dataset.v14='1';
      btn.addEventListener('click', ()=> setTimeout(injectTagMastery, 120), {capture:true});
    }
  })();

  // ========= Title bump to v14 =========
  try{
    // [refactor] removed version bump
    // [refactor] removed version bump
  }catch(_){}

  // Initial update
  updateXpUI();
  updateMissionBadge();

})(); // end v14
</script>
<!-- ===== v15 Addons by ChatGPT (2025-10-19) ===== -->
<style>
/* v15: calendar, weekly challenge, freeze */
.cal-modal .window{ width:min(960px,94vw); }
.cal-wrap{ display:grid; gap:10px; }
.cal-grid{ display:grid; grid-template-columns: 24px repeat(20, 12px); gap:4px 3px; align-items:center; }
.cal-week{ font-size:.78rem; color:#666; }
body.theme-dark .cal-week{ color:#a9b2c3; }
.cal-cell{ width:12px; height:12px; border-radius:3px; background:#eee; }
body.theme-dark .cal-cell{ background:#272d36; }
.cal-legend{ display:flex; gap:8px; align-items:center; font-size:.82rem; color:#666; }
body.theme-dark .cal-legend{ color:#a9b2c3; }
.cal-legend .cal-cell{ width:14px; height:14px; }
.challenge-modal .window{ width:min(700px,94vw); }
.challenge-row{ display:grid; gap:6px; }
.challenge-meta{ font-size:.9rem; color:#666; }
body.theme-dark .challenge-meta{ color:#a9b2c3; }
.challenge-score{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
.badge.small{ padding:2px 6px; font-size:.78rem; border:1px solid #ddd; border-radius:999px; background:#fafafa; }
body.theme-dark .badge.small{ background:#1a2028; border-color:#2a2f3a; }
.freeze-modal .window{ width:min(520px, 92vw); }
</style>
<script>
(function(){
  // ---- helpers ----
  const K = (k)=> STORE_PREFIX + 'opt15_' + k;
  const JGET = (k,d)=>{ try{ const v=localStorage.getItem(K(k)); return v==null?d:JSON.parse(v);}catch(_){ return d; } };
  const JSET = (k,v)=>{ try{ localStorage.setItem(K(k), JSON.stringify(v)); }catch(_){ } };
  
  function dayKey(d){ const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), dd=String(d.getDate()).padStart(2,'0'); return y+'-'+m+'-'+dd; }
  function isoWeekKey(dt){
    const d = new Date(Date.UTC(dt.getFullYear(), dt.getMonth(), dt.getDate()));
    const dayNum = d.getUTCDay() || 7; d.setUTCDate(d.getUTCDate() + 4 - dayNum);
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(),0,1));
    const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1)/7);
    return d.getUTCFullYear() + '-W' + String(weekNo).padStart(2,'0');
  }
  function seedRnd(seedStr){
    let h=0; for(let i=0;i<seedStr.length;i++){ h = (h*31 + seedStr.charCodeAt(i))>>>0; }
    return function(){ h = (h*1664525 + 1013904223)>>>0; return h/4294967296; };
  }
  function pickEnabledCurrent(){
    const pk = currentPath();
    const arr = (store.kifuByPath[pk]||[]).filter(k=>k.enabled!==false);
    return arr.map(k=>k.id);
  }

  // ---- Topbar buttons (Calendar / Challenge / Freeze / Pomodoro placeholder created in v16) ----
  (function ensureBtns(){
    const bar=document.querySelector('.topbar');
    if(!bar) return;
    function add(id, text, fn){
      if(document.getElementById(id)) return;
      const b=document.createElement('button'); b.id=id; b.className='ghost tiny'; b.textContent=text; b.addEventListener('click', fn);
      bar.appendChild(b);
    }
    add('calendarBtn','カレンダー', openCalendar);
    add('challengeBtn','チャレンジ', openChallenge);
    add('freezeBtn','フリーズ', openFreeze);
  })();

  // ---- Calendar modal ----
  function ensureCalModal(){
    if(document.getElementById('calendarModal')) return;
    const modal = document.createElement('div'); modal.className='modal cal-modal'; modal.id='calendarModal';
    modal.innerHTML = '<div class="window">      <header><h3>貢献カレンダー</h3><button class="ghost" id="calClose">閉じる</button></header>      <div class="body"><div class="cal-wrap">        <div class="cal-legend">過去20週の達成状況：<span class="cal-cell" style="background:#e2e8f0"></span>0<span class="cal-cell" style="background:#c7d2fe"></span>1<span class="cal-cell" style="background:#a5b4fc"></span>2<span class="cal-cell" style="background:#818cf8"></span>3<span class="cal-cell" style="background:#6366f1"></span>4+ </div>        <div id="calGrid" class="cal-grid"></div>      </div></div>      <div class="footer"><span class="small muted">各マスは1日のミスなしクリア件数（ログ基準）</span></div>    </div>';
    document.body.appendChild(modal);
    modal.addEventListener('click', (e)=>{ if(e.target===modal) modal.style.display='none'; });
    modal.querySelector('#calClose').addEventListener('click', ()=> modal.style.display='none');
  }
  function openCalendar(){
    ensureCalModal();
    const modal = document.getElementById('calendarModal');
    const grid = document.getElementById('calGrid');
    const logs = getLogs().filter(r=>r && r.solved);
    const count = {}; logs.forEach(r=>{ const day=String(r.timestamp).slice(0,10); count[day] = (count[day]||0) + 1; });
    grid.innerHTML='';
    const today = new Date();
    // start from Monday of 19 weeks ago
    const start = new Date(today); start.setDate(today.getDate() - 7*19);
    // align to Monday
    const wd = (start.getDay()||7); start.setDate(start.getDate() - (wd-1));
    for(let week=0; week<20; week++){
      const weekLabel = document.createElement('div'); weekLabel.className='cal-week';
      const ref = new Date(start); ref.setDate(start.getDate() + week*7);
      const k = isoWeekKey(ref).replace('W','週');
      weekLabel.textContent = k;
      grid.appendChild(weekLabel);
      for(let d=0; d<7; d++){
        const dt = new Date(ref); dt.setDate(ref.getDate()+d);
        if(dt > today){ const cell=document.createElement('div'); cell.className='cal-cell'; cell.style.opacity='.3'; grid.appendChild(cell); continue; }
        const key = dayKey(dt);
        const n = count[key]||0;
        const cell = document.createElement('div'); cell.className='cal-cell'; cell.title = key + '：' + n + '件';
        let color = '#e2e8f0';
        if(n>=4) color = '#6366f1';
        else if(n===3) color = '#818cf8';
        else if(n===2) color = '#a5b4fc';
        else if(n===1) color = '#c7d2fe';
        else color = '#e2e8f0';
        cell.style.background = color;
        grid.appendChild(cell);
      }
    }
    modal.style.display='flex';
  }

  // ---- Streak Freeze ----
  function openFreeze(){
    ensureFreezeModal();
    refreshFreezeUI();
    document.getElementById('freezeModal').style.display='flex';
  }
  function ensureFreezeModal(){
    if(document.getElementById('freezeModal')) return;
    const modal = document.createElement('div'); modal.className='modal freeze-modal'; modal.id='freezeModal';
    modal.innerHTML = '<div class="window">      <header><h3>ストリーク・フリーズ</h3><button class="ghost" id="freezeClose">閉じる</button></header>      <div class="body">        <div class="field">          <div class="small muted">「フリーズ」を使うと、その日を1回だけ“練習した日”としてカウントできます（週に1回まで）。忙しい日でもストリークを守ろう！</div>        </div>        <div class="field"><div id="freezeStatus" class="challenge-meta">—</div></div>        <div class="row wrap">          <button class="ghost" id="freezeYesterdayBtn">前日をフリーズ</button>          <button class="ghost" id="freezeTodayBtn">今日をフリーズ</button>        </div>      </div>      <div class="footer"><span class="small muted">フリーズの使用履歴はローカルに保存されます。</span></div>    </div>';
    document.body.appendChild(modal);
    modal.addEventListener('click', (e)=>{ if(e.target===modal) modal.style.display='none'; });
    modal.querySelector('#freezeClose').addEventListener('click', ()=> modal.style.display='none');
    modal.querySelector('#freezeYesterdayBtn').addEventListener('click', ()=> useFreeze(-1));
    modal.querySelector('#freezeTodayBtn').addEventListener('click', ()=> useFreeze(0));
  }
  function getFreezeDays(){ return JGET('freezeDays', []); }
  function setFreezeDays(a){ JSET('freezeDays', a||[]); }
  function weekBudgetKey(wk){ return 'freezeBudget_'+wk; }
  function getWeekBudget(wk){ return JGET(weekBudgetKey(wk), { used:0, limit:1 }); }
  function setWeekBudget(wk, obj){ JSET(weekBudgetKey(wk), obj||{used:0,limit:1}); }
  function refreshFreezeUI(){
    const now = new Date();
    const wk = isoWeekKey(now);
    const budget = getWeekBudget(wk);
    const days = new Set(getFreezeDays());
    const y = new Date(); y.setDate(now.getDate()-1);
    const status = [
      '今週のフリーズ使用：' + budget.used + ' / ' + budget.limit,
      'フリーズ済み日数：' + days.size + '（直近：' + (Array.from(days).sort().slice(-1)[0] || '—') + '）'
    ].join('　｜　');
    const el = document.getElementById('freezeStatus'); if(el) el.textContent = status;
    const logs = getLogs().filter(r=>r && r.solved);
    const solved = new Set(logs.map(r => String(r.timestamp).slice(0,10)));
    const keyY = dayKey(y), keyT = dayKey(now);
    const by = document.getElementById('freezeYesterdayBtn');
    const bt = document.getElementById('freezeTodayBtn');
    if(by){ by.disabled = solved.has(keyY) || days.has(keyY) || (budget.used>=budget.limit); }
    if(bt){ bt.disabled = solved.has(keyT) || days.has(keyT) || (budget.used>=budget.limit); }
  }
  function useFreeze(delta){
    const dt = new Date(); dt.setDate(dt.getDate() + delta);
    const key = dayKey(dt);
    const wk = isoWeekKey(new Date());
    const budget = getWeekBudget(wk);
    if(budget.used >= budget.limit){ alert('今週のフリーズは使い切りました'); return; }
    const days = new Set(getFreezeDays());
    if(days.has(key)){ alert('その日は既にフリーズ済みです'); return; }
    days.add(key); setFreezeDays(Array.from(days));
    budget.used += 1; setWeekBudget(wk, budget);
    showToast('フリーズを使いました：' + key);
    refreshFreezeUI();
    try{ if(window._v13_updateStreak) window._v13_updateStreak(); }catch(_){}
  }

  // Override streak computation to include freeze days
  (function(){
    if(typeof window._v13_updateStreak === 'function' && !window._v15_streak_patched){
      const upd = function(){
        try{
          const logs = getLogs().filter(r=>r && r.solved);
          const solvedDays = new Set(logs.map(r => String(r.timestamp).slice(0,10)));
          const freezer = new Set(getFreezeDays());
          const today = new Date();
          const todayKey = dayKey(today);
          const todayCnt = solvedDays.has(todayKey) ? (logs.filter(r=> String(r.timestamp).slice(0,10)===todayKey).length) : 0;
          let streak = 0;
          for(let i=0;i<3650;i++){
            const d = new Date(today); d.setDate(today.getDate()-i);
            const k = dayKey(d);
            if(solvedDays.has(k) || freezer.has(k)) streak++; else break;
          }
          const el1=document.getElementById('streakDays'); const el2=document.getElementById('todaySolved');
          if(el1) el1.textContent=String(streak);
          if(el2) el2.textContent=String(todayCnt);
        }catch(_){}
      };
      window._v13_updateStreak = upd;
      window._v15_streak_patched = true;
      setTimeout(()=>{ try{ upd(); }catch(_){} }, 200);
    }
  })();

  // ---- Weekly Challenge (Boss Run) ----
  function ensureChallengeModal(){
    if(document.getElementById('challengeModal')) return;
    const modal = document.createElement('div'); modal.className='modal challenge-modal'; modal.id='challengeModal';
    modal.innerHTML = '<div class="window">      <header><h3>ウィークリーチャレンジ</h3><button class="ghost" id="chClose">閉じる</button></header>      <div class="body">        <div class="challenge-row">          <div class="challenge-meta" id="chMeta">—</div>          <div class="row wrap">            <label class="small">本数：</label><input type="number" id="chCount" min="3" max="30" value="10" style="width:80px;">            <label class="small">対象：この小フォルダの「出題オン」から選出</label>          </div>          <div class="challenge-score" id="chScore"></div>          <div class="row wrap">            <button class="primary" id="chStart">開始</button>            <button class="ghost" id="chStop">中断</button>            <button class="ghost" id="chCopy">結果をコピー</button>          </div>        </div>      </div>      <div class="footer"><span class="small muted">週ごとに固定のシードで選出（共有しやすい）。結果はローカル保存。</span></div>    </div>';
    document.body.appendChild(modal);
    modal.addEventListener('click', (e)=>{ if(e.target===modal) modal.style.display='none'; });
    modal.querySelector('#chClose').addEventListener('click', ()=> modal.style.display='none');
    modal.querySelector('#chStart').addEventListener('click', startChallenge);
    modal.querySelector('#chStop').addEventListener('click', stopChallenge);
    modal.querySelector('#chCopy').addEventListener('click', copyChallengeResult);
  }
  function openChallenge(){
    ensureChallengeModal();
    refreshChallengeUI();
    document.getElementById('challengeModal').style.display='flex';
  }
  function refreshChallengeUI(){
    const meta = document.getElementById('chMeta'); if(!meta) return;
    const wk = isoWeekKey(new Date());
    meta.textContent = '今週のキー：' + wk + '｜対象フォルダ：' + currentPath();
    const rs = getChallengeResult(wk, currentPath());
    const box = document.getElementById('chScore');
    box.innerHTML='';
    if(rs){
      const b = document.createElement('span'); b.className='badge small'; b.textContent='ベスト：' + ((rs.bestMs/1000).toFixed(2)) + 's / ミス ' + rs.mistakes;
      box.appendChild(b);
      const t = document.createElement('span'); t.className='small muted'; t.textContent='（' + rs.list.length + '問 ' + new Date(rs.at).toLocaleString() + '）';
      box.appendChild(t);
    }else{
      const t = document.createElement('span'); t.className='small muted'; t.textContent='まだ記録がありません';
      box.appendChild(t);
    }
  }
  function buildChallengeList(count){
    const wk = isoWeekKey(new Date());
    const rnd = seedRnd(wk + '|' + currentPath());
    const ids = pickEnabledCurrent().slice();
    if(!ids.length) return [];
    // shuffle
    for(let i=ids.length-1;i>0;i--){ const j=Math.floor(rnd()*(i+1)); const tmp=ids[i]; ids[i]=ids[j]; ids[j]=tmp; }
    return ids.slice(0, Math.min(count, ids.length));
  }
  function getChallengeResult(wk, path){
    return JGET('ch_'+wk+'_'+(path||''), null);
  }
  function setChallengeResult(wk, path, obj){
    JSET('ch_'+wk+'_'+(path||''), obj);
  }
  window._v15_ch = { active:false, wk:'', list:[], idx:0, start:0, totalMs:0, mistakes:0 };
  function startChallenge(){
    const cnt = Math.max(3, Math.min(30, parseInt(document.getElementById('chCount').value||'10',10) ));
    const list = buildChallengeList(cnt);
    if(!list.length){ alert('出題オンの問題が足りません'); return; }
    const wk = isoWeekKey(new Date());
    window._v15_ch = { active:true, wk, list, idx:0, start:Date.now(), totalMs:0, mistakes:0, results:[] };
    document.getElementById('challengeModal').style.display='none';
    try{ startTrainingWithKifuId(list[0]); }catch(_){ alert('開始に失敗しました'); window._v15_ch.active=false; }
  }
  function stopChallenge(){
    const st = window._v15_ch || {}; st.active=false; showToast('チャレンジを中断しました');
  }
  function copyChallengeResult(){
    try{
      const wk = isoWeekKey(new Date());
      const rs = getChallengeResult(wk, currentPath());
      if(!rs){ alert('記録がありません'); return; }
      const payload = { type:'reversi_trainer_weekly_v1', week:wk, path:currentPath(), result:rs };
      const txt = JSON.stringify(payload, null, 2);
      navigator.clipboard.writeText(txt).then(()=> showToast('結果をコピーしました'));
    }catch(_){ alert('コピーに失敗しました'); }
  }
  function onCelebrateForChallenge(total, mistakes){
    const st = window._v15_ch||{};
    if(!st.active) return;
    try{
      const ms = (window._v9 && _v9.timerStart) ? Math.max(0, Date.now() - _v9.timerStart) : 0;
      st.results.push({ len: total, mistakes: mistakes, ms: ms });
      st.totalMs += ms; st.mistakes += mistakes;
      st.idx++;
      if(st.idx < st.list.length){
        // proceed to next
        setTimeout(()=>{ try{ document.getElementById('nextBtn')?.click(); hideCelebrate?.(); startTrainingWithKifuId(st.list[st.idx]); }catch(_){} }, 500);
      }else{
        st.active=false;
        const wk = st.wk;
        const best = getChallengeResult(wk, currentPath());
        const now = { at: new Date().toISOString(), list: st.list.slice(), bestMs: st.totalMs, mistakes: st.mistakes };
        if(!best || (now.bestMs < best.bestMs)){ setChallengeResult(wk, currentPath(), now); }
        setTimeout(()=>{
          alert('ウィークリーチャレンジ完了！\n合計時間：' + (st.totalMs/1000).toFixed(2) + '秒\n総ミス：' + st.mistakes + '\n（記録はミニウィンドウ「チャレンジ」に表示されます）');
          try{ openChallenge(); }catch(_){}
        }, 300);
      }
    }catch(_){}
  }
  if(typeof window.showCelebrate === 'function' && !window._v15_celebrate_hook){
    const orig = window.showCelebrate;
    window.showCelebrate = function(total, mistakes){
      const out = orig(total, mistakes);
      try{ onCelebrateForChallenge(total, mistakes); }catch(_){}
      return out;
    };
    window._v15_celebrate_hook = true;
  }

})(); // end v15
</script>
<!-- ===== v16 Addons by ChatGPT (2025-10-19) ===== -->
<style>
/* v16: coach overlay & pomodoro */
.coach-overlay{
  position:absolute; right:10px; top:44px; z-index:7;
  background:rgba(0,0,0,.55); color:#fff; padding:6px 8px; border-radius:8px; max-width:46ch; font-size:.9rem;
}
.pomo-overlay{
  position:fixed; right:16px; bottom:16px; z-index:50;
  background:rgba(0,0,0,.75); color:#fff; padding:10px 12px; border-radius:12px; backdrop-filter: blur(2px);
}
.pomo-overlay .row{ display:flex; gap:8px; align-items:center; }
.pomo-overlay .time{ font-variant-numeric: tabular-nums; font-size:1.1rem; }
.title-badge{ font-size:.82rem; border:1px solid #ddd; padding:2px 6px; border-radius:999px; background:#fff8e1; color:#7a5300; }
body.theme-dark .title-badge{ background:#2b2414; border-color:#3a321a; color:#ffd54f; }
</style>
<script>
(function(){
  const K = (k)=> STORE_PREFIX + 'opt16_' + k;
  const JGET = (k,d)=>{ try{ const v=localStorage.getItem(K(k)); return v==null?d:JSON.parse(v);}catch(_){ return d; } };
  const JSET = (k,v)=>{ try{ localStorage.setItem(K(k), JSON.stringify(v)); }catch(_){ } };

  // ---- Version bump to v16 ----
  try{
    // [refactor] removed version bump
    // [refactor] removed version bump
  }catch(_){}

  // ---- Level titles ----
  function levelTitle(lv){
    if(lv>=30) return '伝説';
    if(lv>=25) return '師範';
    if(lv>=20) return '達人';
    if(lv>=15) return '名人';
    if(lv>=10) return '上級';
    if(lv>=5)  return '中級';
    return '初級';
  }
  function attachTitleBadge(){
    try{
      const stat = document.getElementById('xpStat');
      if(!stat || stat.querySelector('.title-badge')) return;
      const lvEl = document.getElementById('lvNum');
      const lv = lvEl ? parseInt(lvEl.textContent||'1',10) : 1;
      const t = document.createElement('span'); t.className='title-badge'; t.id='titleBadge'; t.textContent=levelTitle(lv);
      stat.querySelector('.xpwrap')?.appendChild(t);
    }catch(_){}
  }
  attachTitleBadge();
  // keep in sync after XP UI updates (v14 calls updateXpUI)
  if(!window._v16_xp_sync && typeof window.updateXpUI === 'function'){
    const orig = window.updateXpUI;
    window.updateXpUI = function(){ orig(); try{ const lv=parseInt(document.getElementById('lvNum')?.textContent||'1',10); const b=document.getElementById('titleBadge'); if(b) b.textContent=levelTitle(lv); else attachTitleBadge(); }catch(_){} };
    window._v16_xp_sync = true;
  }

  // ---- Coach persona ----
  const COACH = {
    "NEKKETSU": { ok:'よし！その調子！', ng:'惜しい！すぐリカバリー！', success:'ナイスクリア！', tip:['スピード×正確性で限界突破！','赤マス（誤答）を潰していこう。','ハードモードで肩慣らしだ。'] },
    "GENTLE":   { ok:'いいですね。', ng:'大丈夫、次はできる。', success:'落ち着いて完璧でした。', tip:['少しゆっくり、丁寧に。','迷ったら定石に戻りましょう。','深呼吸してもう一巡。'] },
    "MINIMAL":  { ok:'OK', ng:'NG', success:'✓', tip:['継続。','次へ。','集中。'] },
    "KANSAI":   { ok:'ええやん！', ng:'おしいわ〜', success:'やったな！', tip:['赤いとこ、潰しとこか。','ええ流れやで。','焦らんといこ。'] }
  };
  function coachTone(){ return JGET('coach','GENTLE'); }
  function coachSay(msg){
    try{
      let o=document.getElementById('coachOverlay');
      if(!o){ o=document.createElement('div'); o.id='coachOverlay'; o.className='coach-overlay'; const wrap=document.getElementById('boardWrap'); if(wrap) wrap.appendChild(o); }
      o.textContent = String(msg||''); o.style.display='inline-block';
      clearTimeout(window._v16_coach_t);
      window._v16_coach_t = setTimeout(()=>{ if(o) o.style.display='none'; }, 1400);
    }catch(_){}
  }
  // settings UI injection
  (function(){
    const cards = document.querySelectorAll('.dockGrid .card');
    const settings = cards && cards[0] ? cards[0] : null;
    if(!settings || document.getElementById('coachSel')) return;
    const field = document.createElement('div'); field.className='field row wrap';
    const lab = document.createElement('label'); lab.textContent='コーチ：'; field.appendChild(lab);
    const sel = document.createElement('select'); sel.id='coachSel';
    [['NEKKETSU','熱血'],['GENTLE','やさしい'],['MINIMAL','ミニマル'],['KANSAI','関西']].forEach(([v,t])=>{
      const o=document.createElement('option'); o.value=v; o.textContent=t; if(v===coachTone()) o.selected=true; sel.appendChild(o);
    });
    sel.addEventListener('change', ()=> JSET('coach', sel.value));
    field.appendChild(sel);
    settings.appendChild(field);
  })();

  // Patch playSound (v11 already patched); add coach messages
  if(typeof window.playSound === 'function' && !window._v16_sound_patched){
    const orig = window.playSound;
    window.playSound = function(type){
      try{
        orig(type);
        const tone = COACH[coachTone()]||COACH.GENTLE;
        if(type==='ok') coachSay(tone.ok);
        else if(type==='ng') coachSay(tone.ng);
        else if(type==='success') coachSay(tone.success);
      }catch(_){}
    };
    window._v16_sound_patched = true;
  }
  // Add coach tip on celebrate (replace existing simple tip in v14)
  if(typeof window.showCelebrate === 'function' && !window._v16_tip_patched){
    const orig = window.showCelebrate;
    window.showCelebrate = function(total, mistakes){
      const out = orig(total, mistakes);
      try{
        const tone = COACH[coachTone()]||COACH.GENTLE;
        const tips = tone.tip||[];
        const pick = tips[Math.floor(Math.random()*tips.length)] || '';
        const info = document.getElementById('resultInfo');
        if(info){
          let row = document.getElementById('coachRow');
          if(!row){ row = document.createElement('div'); row.className='field'; row.id='coachRow'; info.appendChild(row); }
          row.innerHTML = '<label class="small">コーチから一言</label><div class="small muted">'+ pick +'</div>';
        }
      }catch(_){}
      return out;
    };
    window._v16_tip_patched = true;
  }

  // ---- Pomodoro (work/break cycles) ----
  const POMO = { on:false, work:25*60, rest:5*60, remain:0, phase:'work', id:null };
  function ensurePomoOverlay(){
    if(document.getElementById('pomoOverlay')) return;
    const o = document.createElement('div'); o.id='pomoOverlay'; o.className='pomo-overlay'; o.style.display='none';
    o.innerHTML = '<div class="row"><b>ポモドーロ</b><span id="pomoPhase" class="badge">作業</span><span id="pomoTime" class="time">25:00</span></div>      <div class="row"><button class="ghost tiny" id="pomoStart">開始</button><button class="ghost tiny" id="pomoStop">停止</button>      <label class="small">作業</label><input id="pomoWork" type="number" min="1" step="1" value="25" style="width:64px;">      <label class="small">休憩</label><input id="pomoRest" type="number" min="1" step="1" value="5" style="width:64px;"></div>';
    document.body.appendChild(o);
    o.querySelector('#pomoStart').addEventListener('click', ()=> startPomo());
    o.querySelector('#pomoStop').addEventListener('click', stopPomo);
    o.querySelector('#pomoWork').addEventListener('change', (e)=>{ POMO.work = Math.max(1, parseInt(e.target.value||'25',10))*60; if(!POMO.on) POMO.remain=POMO.work; renderPomo(); });
    o.querySelector('#pomoRest').addEventListener('change', (e)=>{ POMO.rest = Math.max(1, parseInt(e.target.value||'5',10))*60; });
  }
  function showPomoOverlay(){ ensurePomoOverlay(); const o=document.getElementById('pomoOverlay'); if(o) o.style.display='block'; }
  function hidePomoOverlay(){ const o=document.getElementById('pomoOverlay'); if(o) o.style.display='none'; }
  function renderPomo(){
    const t = document.getElementById('pomoTime'); const p = document.getElementById('pomoPhase');
    if(t){ const m = Math.floor(POMO.remain/60), s = POMO.remain%60; t.textContent = String(m).padStart(2,'0') + ':' + String(s).padStart(2,'0'); }
    if(p){ p.textContent = (POMO.phase==='work'?'作業':'休憩'); }
  }
  function startPomo(){
    POMO.on = true; if(!POMO.remain){ POMO.phase='work'; POMO.remain = POMO.work; } renderPomo();
    clearInterval(POMO.id);
    POMO.id = setInterval(()=>{
      POMO.remain = Math.max(0, POMO.remain - 1);
      renderPomo();
      if(POMO.remain<=0){
        try{ playSound && playSound('success'); }catch(_){}
        if(POMO.phase==='work'){ POMO.phase='rest'; POMO.remain = POMO.rest; }
        else { POMO.phase='work'; POMO.remain = POMO.work; }
        renderPomo();
      }
    }, 1000);
  }
  function stopPomo(){ POMO.on=false; clearInterval(POMO.id); POMO.id=null; }
  // topbar button
  (function(){
    const bar=document.querySelector('.topbar');
    if(!bar) return;
    if(!document.getElementById('pomoBtn')){
      const b=document.createElement('button'); b.id='pomoBtn'; b.className='ghost tiny'; b.textContent='ポモドーロ';
      b.addEventListener('click', ()=>{ const o=document.getElementById('pomoOverlay'); if(o && o.style.display==='block'){ hidePomoOverlay(); } else { showPomoOverlay(); POMO.remain=POMO.work; renderPomo(); } });
      bar.appendChild(b);
    }
  })();

})(); // end v16
</script>
<!-- ===== v17 Addon: その他機能の表示/非表示トグル（2025-10-19） ===== -->
<style>
  /* 「その他機能一覧」用のラッパ。初期は非表示 */
  .more-wrap { display: none; gap: 8px; align-items: center; flex-wrap: wrap; }
</style>
<script>
(function(){
  try{
    const topbar = document.querySelector('.topbar');
    if(!topbar) return;

    // 作成ヘルパ
    function makeBtn(id, text, onClick){
      let b = document.getElementById(id);
      if(!b){
        b = document.createElement('button');
        b.id = id;
        b.className = 'ghost tiny';
        b.textContent = text;
        if(typeof onClick === 'function') b.addEventListener('click', onClick);
      }
      return b;
    }

    // 「その他機能」ラッパ
    let moreWrap = document.getElementById('moreWrap');
    if(!moreWrap){
      moreWrap = document.createElement('span');
      moreWrap.id = 'moreWrap';
      moreWrap.className = 'more-wrap';
      // topbar の末尾に配置（集中モードなど常時表示項目はそのまま）
      topbar.appendChild(moreWrap);
    }

    // トグルボタン（常時表示）
    const showBtn = makeBtn('moreShowBtn', 'その他機能一覧表示', ()=>{
      moreWrap.style.display = 'inline-flex';
      showBtn.style.display = 'none';
      hideBtn.style.display = 'inline-block';
    });
    const hideBtn = makeBtn('moreHideBtn', '非表示', ()=>{
      moreWrap.style.display = 'none';
      showBtn.style.display = 'inline-block';
      hideBtn.style.display = 'none';
    });
    hideBtn.style.display = 'none'; // 初期は隠す（一覧が隠れているため）

    // すでに同名ボタンが topbar に存在しなければ追加
    if(!document.getElementById('moreShowBtn')) topbar.appendChild(showBtn);
    if(!document.getElementById('moreHideBtn')) topbar.appendChild(hideBtn);

    // 折りたたみ対象のボタンID（機能数は減らさず、初期は非表示）
    const FOLD_IDS = [
      'openStatsBtn',     // 統計
      'todayBtn',         // 今日のメニュー
      'voiceBtn',         // 音声入力
      'dupBtn',           // 重複チェック
      'shareBtn',         // 共有（今の問題）
      'achiBtn',          // 実績
      'missionBtn',       // ミッション
      'calendarBtn',      // カレンダー
      'challengeBtn',     // チャレンジ
      'freezeBtn',        // フリーズ
      'pomoBtn'           // ポモドーロ
      // ※ 「集中モード」(focusBtn) は常時表示のため含めない
    ];

    // 対象ボタンを moreWrap へ移動
    function moveTargets(){
      FOLD_IDS.forEach(id=>{
        const el = document.getElementById(id);
        if(el && el.parentNode !== moreWrap){
          moreWrap.appendChild(el);
        }
      });
    }

    // 初回実行（既に生成済みのボタンを移動）
    moveTargets();

    // これから追加されるボタンにも追従（各 vXX アドオンが後から生成するため）
    const obs = new MutationObserver((mutations)=>{
      let need = false;
      for(const m of mutations){
        if(m.addedNodes && m.addedNodes.length){
          for(const n of m.addedNodes){
            if(n.nodeType === 1 && FOLD_IDS.includes(n.id)){ need = true; break; }
          }
        }
      }
      if(need) moveTargets();
    });
    obs.observe(topbar, { childList: true });

    // 初期状態は非表示（ユーザーが「その他機能一覧表示」を押したときに表示）
    moreWrap.style.display = 'none';
  }catch(e){ console.warn('more toggle init failed:', e); }
})();
</script>
<!-- ===== /v17 Addon ===== -->
<!-- ===== v17 Patch by ChatGPT (全体マージ・インポート + コーチ機能の廃止) ===== -->
<script>
(function(){
  // ========= disable Coach features visually and functionally =========
  try{
    const css = document.createElement('style');
    css.textContent = '.coach-overlay, #coachBtn, .coach-btn, .coach-select { display:none !important; }';
    document.head.appendChild(css);
  }catch(e){}

  // ========= helpers =========
  const uniq = (arr)=> Array.from(new Set((arr||[]).filter(x=>x!==null && x!==undefined && x!=='')));
  function normalizeKifu(k){
    if(!k) k={};
    if(!Array.isArray(k.moves)) k.moves=[];
    // canonicalSignature is defined in base; fallback if not
    if(!k.sig){
      try{
        if(typeof canonicalSignature==='function'){
          k.sig = canonicalSignature(k.moves);
        }else{
          const norm = (k.moves||[]).map(t=>String(t).toUpperCase()).filter(t=>t!=='P' && t!=='PASS');
          k.sig = norm.join(',');
        }
      }catch(_){}
    }
    if(!k.stats) k.stats={ attempts:0, solved:0, mistakes:0 };
    if(typeof k.enabled==='undefined') k.enabled=true;
    if(!Array.isArray(k.tags)) k.tags=[];
    if(typeof k.comment!=='string') k.comment='';
    if(!k.id) k.id = Date.now().toString(36)+Math.random().toString(36).slice(2,7);
    return k;
  }
  function mergeStats(a,b){
    a=a||{}; b=b||{};
    const out = {
      attempts: (a.attempts||0)+(b.attempts||0),
      solved:   (a.solved||0)+(b.solved||0),
      mistakes: (a.mistakes||0)+(b.mistakes||0)
    };
    if(a.lastAt||b.lastAt) out.lastAt = Math.max(a.lastAt||0, b.lastAt||0);
    if(a.bestMs && b.bestMs) out.bestMs = Math.min(a.bestMs, b.bestMs);
    else out.bestMs = a.bestMs || b.bestMs;
    return out;
  }
  function mergeOne(base, inc){
    base = normalizeKifu(base); inc = normalizeKifu(inc);
    base.tags = uniq([...(base.tags||[]), ...(inc.tags||[])]);
    if((inc.comment||'').trim()){
      const txt = (inc.comment||'').trim();
      if(!(base.comment||'').includes(txt)){
        base.comment = (base.comment?base.comment+'\n':'' ) + '【追記（マージ）】' + txt;
      }
    }
    // enabled: true が1つでもあれば true
    base.enabled = (base.enabled!==false) || (inc.enabled!==false);
    // 手動クリア: OR
    base.manualCleared = !!(base.manualCleared || inc.manualCleared);
    // nameは既存優先、なければ取り込み
    base.name = base.name || inc.name || '';
    // 統計は加算
    base.stats = mergeStats(base.stats, inc.stats);
    // SRS は保守的（早い期限・長い連続・平均イーズ）
    if(inc.srsDue!=null || inc.srsInterval!=null || inc.srsEase!=null || inc.srsStreak!=null){
      base.srsDue = Math.min(base.srsDue||Infinity, inc.srsDue||Infinity);
      if(!isFinite(base.srsDue)) delete base.srsDue;
      base.srsInterval = Math.max(base.srsInterval||0, inc.srsInterval||0) || undefined;
      const aE = (base.srsEase==null?null:base.srsEase), bE = (inc.srsEase==null?null:inc.srsEase);
      base.srsEase = (aE!=null && bE!=null) ? ((aE + bE)/2) : (aE!=null? aE : bE);
      base.srsStreak = Math.max(base.srsStreak||0, inc.srsStreak||0) || undefined;
    }
    return base;
  }
  function ensurePath(st, big, sm){
    if(!(st.bigFolders||[]).some(b => b.name===big)){ (st.bigFolders|| (st.bigFolders=[])).push({name:big, defaultColor:""}); }
    if(!st.smallByBig[big]) st.smallByBig[big] = [];
    if(sm && !st.smallByBig[big].includes(sm)) st.smallByBig[big].push(sm);
    const pk = big + '/' + (sm||'__ROOT__');
    if(!st.kifuByPath[pk]) st.kifuByPath[pk]=[];
    if(!st.queueByPath[pk]) st.queueByPath[pk]=[];
    return pk;
  }
  function mergeStore(base, incoming){
    if(!incoming || typeof incoming!=='object') throw new Error('不正なJSONです');
    const isStore = incoming && incoming.kifuByPath && incoming.bigFolders;
    const isFolderExport = incoming && incoming.type==='reversi_trainer_folder_export_v1';
    if(!isStore && !isFolderExport) throw new Error('対応形式は「フルストアJSON」または「フォルダエクスポートJSON」です');

    if(isStore){
      // bigFolders のメタをマージ（defaultColor は既存優先）
      (incoming.bigFolders||[]).forEach(b=>{
        const name = b.name;
        const meta = (base.bigFolders||[]).find(x=>x.name===name);
        if(!meta){ base.bigFolders.push({ name, defaultColor: b.defaultColor||"" }); }
        else if(!meta.defaultColor && b.defaultColor){ meta.defaultColor = b.defaultColor; }
      });
      // small をユニオン
      Object.keys(incoming.smallByBig||{}).forEach(big=>{
        base.smallByBig[big] = uniq([...(base.smallByBig[big]||[]), ...(incoming.smallByBig[big]||[])]);
      });
      // 棋譜マージ（sigで重複判定）
      Object.keys(incoming.kifuByPath||{}).forEach(pk=>{
        const [big, smPart] = pk.split('/');
        const sm = (smPart==='__ROOT__'? null : smPart);
        const pk2 = ensurePath(base, big, sm);
        const mine = base.kifuByPath[pk2] || (base.kifuByPath[pk2]=[]);
        const map = new Map();
        mine.forEach(k=>{ const kk=normalizeKifu(k); map.set(kk.sig, kk); });
        (incoming.kifuByPath[pk]||[]).forEach(k=>{
          const inc = normalizeKifu(k);
          const hit = map.get(inc.sig);
          if(hit){ mergeOne(hit, inc); }
          else{
            mine.push(normalizeKifu(inc));
            map.set(inc.sig, mine[mine.length-1]);
          }
        });
      });
      // queue はIDベースでユニオン（新規IDに対しては効果限定的）
      Object.keys(incoming.queueByPath||{}).forEach(pk=>{
        const [big, smPart] = pk.split('/');
        const sm = (smPart==='__ROOT__'? null : smPart);
        const pk2 = ensurePath(base, big, sm);
        base.queueByPath[pk2] = uniq([...(base.queueByPath[pk2]||[]), ...(incoming.queueByPath[pk]||[])]);
      });
    }else if(isFolderExport){
      const p = incoming.path || 'Imported/__ROOT__';
      const [big, smPart] = p.split('/');
      const sm = (smPart && smPart!=='__ROOT__') ? smPart : null;
      const pk2 = ensurePath(base, big, sm);
      const mine = base.kifuByPath[pk2] || (base.kifuByPath[pk2]=[]);
      const map = new Map(); mine.forEach(k=>{ const kk=normalizeKifu(k); map.set(kk.sig, kk); });
      (incoming.items||[]).forEach(it=>{
        const inc = normalizeKifu(Array.isArray(it) ? { moves: it } : it);
        const hit = map.get(inc.sig);
        if(hit){ mergeOne(hit, inc); } else { mine.push(inc); map.set(inc.sig, inc); }
      });
    }

    // 「覚えた棋譜（ユニーク）」は sig で集合化
    try{
      const sigSet = new Set();
      Object.values(base.kifuByPath||{}).forEach(list=>{
        (list||[]).forEach(k=>{ const ok = !!(k && k.stats && (k.stats.solved||0)>0);
        const sig = k && (k.sig || (k.moves ? canonicalSignature(k.moves) : null));
        if(ok && sig) sigSet.add(sig);
});
      });
      base.learnedOnceSigs = Array.from(sigSet);
    }catch(_){}
    return base;
  }

  // ========= UI: 全体マージ・インポート =========
  (function installMergeImport(){
    const importBtn = document.getElementById('importBtn');
    if(!importBtn) return;
    if(document.getElementById('mergeImportBtn')) return;
    const btn = document.createElement('button'); btn.className='ghost'; btn.id='mergeImportBtn'; btn.textContent='全体マージ・インポート';
    const file = document.createElement('input'); file.type='file'; file.id='mergeImportFile'; file.accept='application/json'; file.style.display='none';
    importBtn.insertAdjacentElement('afterend', btn);
    btn.insertAdjacentElement('afterend', file);

    btn.addEventListener('click', ()=> file.click());
    file.addEventListener('change', (e)=>{
      const f = e.target.files && e.target.files[0]; if(!f) return;
      const reader = new FileReader();
      reader.onload = ()=>{
        try{
          const obj = JSON.parse(String(reader.result||'{}'));
          const base = (typeof store!=='undefined' && store) ? store : (window.loadStore? loadStore() : null);
          if(!base) { alert('内部ストアが見つかりません'); return; }
          const merged = mergeStore(base, obj);
          saveStore(merged);
          window.store = merged;
          if(typeof refreshBigSelect==='function') refreshBigSelect();
          if(typeof updateCountsAndPath==='function') updateCountsAndPath();
          if(typeof renderKifuList==='function') try{ renderKifuList(); }catch(_){}
          if(typeof showToast==='function') showToast('マージ・インポートが完了しました（重複は統合）');
          else alert('マージ・インポートが完了しました（重複は統合）');
        }catch(err){
          console.error(err);
          alert('マージに失敗：' + (err && err.message ? err.message : String(err)));
        }finally{
          try{ e.target.value=''; }catch(_){}
        }
      };
      reader.readAsText(f, 'utf-8');
    });
  })();

  // ========= override: 「覚えた棋譜（ユニーク）」は sig で数える =========
  ;(function overrideUniqueCounter(){
    function updateUnique(){
      try{
        const set = new Set();
        Object.values(store.kifuByPath||{}).forEach(list=>{
          (list||[]).forEach(k=>{
          const ok = !!(k && k.stats && (k.stats.solved||0)>0);
          const sig = k && (k.sig || (k.moves ? canonicalSignature(k.moves) : null));
          if(ok && sig) set.add(sig);
        });
});
        const el = document.getElementById('uniqueSolved'); if(el) el.textContent = String(set.size);
      }catch(_){}
    }
    if(typeof window.updateCountsAndPath==='function'){
      const orig = window.updateCountsAndPath;
      window.updateCountsAndPath = function(){ orig(); updateUnique(); };
    }else{
      updateUnique();
    }
    setTimeout(updateUnique, 300);
  })();

  // ========= hard-disable any coach openers =========
  window.openCoach = function(){ alert('コーチ機能は廃止されました。'); };
  window.showCoachMessage = function(){};

  // ========= bump title =========
  try{
    document.title = (document.title||'').replace(/v(\d+)/, 'v17') || 'オセロ暗記トレーナー v17';
    // [refactor] removed version bump
  }catch(_){}
})();
</script>
<style>
/* === Coach feature removed (UI hidden) === */
#coachSel, #coachRow, #coachOverlay { display: none !important; }
</style>
<script>
// === Coach feature removed (hard disable & UI cleanup) ===
(function(){
  function removeCoachUI(){
    try {
      var sel = document.getElementById('coachSel');
      if (sel) {
        var field = sel.closest ? sel.closest('.field') : null;
        if (field && field.parentNode) field.parentNode.removeChild(field);
        else sel.parentNode && sel.parentNode.removeChild(sel);
      }
      var row = document.getElementById('coachRow');
      if (row && row.parentNode) row.parentNode.removeChild(row);
      var ov = document.getElementById('coachOverlay');
      if (ov && ov.parentNode) ov.parentNode.removeChild(ov);
      // Remove any label showing 'コーチ：'
      var labels = Array.prototype.slice.call(document.querySelectorAll('label'));
      labels.forEach(function(lb){
        if (/^\s*コーチ\s*：?\s*$/.test(lb.textContent || '')) {
          var wrap = lb.closest ? lb.closest('.field') : null;
          if (wrap && wrap.parentNode) wrap.parentNode.removeChild(wrap);
          else lb.parentNode && lb.parentNode.removeChild(lb);
        }
      });
    } catch (_) {}
  }
  function disableCoach(){
    try {
      // Override any coach functions if they exist
      if (typeof window.coachSay === 'function') window.coachSay = function(){};
      if (typeof window.coachTone === 'function') window.coachTone = function(){ return 'GENTLE'; };
    } catch(_) {}
  }
  function run(){
    disableCoach();
    removeCoachUI();
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', run);
  } else {
    run();
  }
  // Sweep a few times in case UI is injected late
  var n = 0;
  var t = setInterval(function(){
    removeCoachUI();
    if (++n >= 8) clearInterval(t);
  }, 400);
})();
</script>
<!-- ===== v17 Fixes by ChatGPT (2025-10-20) ===== -->
<script>
// v17-1: 「暗記成功！」画面を最小構成にクリーンアップ（PNGに載っている情報のみ表示）
// v17-2: 「盤面リセット」→「トレーニング開始」で直前の問題を再スタート

(function(){
  // --- v17-1: Clean up success modal ---
  function cleanResultInfoMinimal(){
    try{
      var box = document.getElementById('resultInfo');
      if(!box) return;
      var kifu = document.getElementById('resultKifuText');
      var note = document.getElementById('resultCommentInput');
      // 残すべきもの（棋譜フィールド／コメントフィールド）以外の .field を削除
      Array.prototype.slice.call(box.querySelectorAll('.field')).forEach(function(f){
        if(f.contains(kifu) || f.contains(note)) return;
        f.parentNode && f.parentNode.removeChild(f);
      });
      // ついでに後付けされた既知の行IDを明示的に除去
      ['srsRatingRow','coachRow'].forEach(function(id){
        var n = document.getElementById(id);
        if(n && n.parentNode === box) n.parentNode.removeChild(n);
      });
    }catch(e){ /* ignore */ }
  }
  if (typeof window.showCelebrate === 'function' && !window._v17_minimalCelebratePatched){
    var _origShowCelebrate = window.showCelebrate;
    window.showCelebrate = function(total, mistakes){
      var out = _origShowCelebrate(total, mistakes);
      try{ cleanResultInfoMinimal(); }catch(_){}
      return out;
    };
    window._v17_minimalCelebratePatched = true;
  }

  // --- v17-2: Reset keeps current problem; Start resumes same id ---
  (function(){
    var reset = document.getElementById('resetBtn');
    var start = document.getElementById('startBtn');
    if(!reset || !start) return;
    window._v17_resumeAfterReset = false;

    // Reset: 盤面だけ初期化し、同一問題を再開フラグを立てる
    reset.addEventListener('click', function(){
      window._v17_resumeAfterReset = true;
      // ラベルが消えないように、リセット直後に番号ラベルを再描画
      setTimeout(function(){ try{ if (typeof updateBoardIndexLabel==='function') updateBoardIndexLabel(); }catch(_){} }, 0);
    }, {capture:true});

    // Start: フラグが立っていれば直前の currentKifuId を再スタート
    start.addEventListener('click', function(e){
      try{
        if(window._v17_resumeAfterReset && typeof startTrainingWithKifuId==='function' && typeof currentKifuId!=='undefined' && currentKifuId){
          e.stopImmediatePropagation(); // 既存の startTraining() ハンドラをキャンセル
          window._v17_resumeAfterReset = false;
          try{
            startTrainingWithKifuId(currentKifuId);
          }catch(ex){
            // 念のためフォールバック
            if (typeof startTraining === 'function') startTraining();
          }
        }
      }catch(_){}
    }, {capture:true});
  })();
})();
</script>
<!-- v17 note-bar patch (備考を座標行の直下に常時表示／トレ中のみ) -->
<style>
  .note-bar{ margin-top:6px; padding:8px 10px; background:#fffdfa; border:1px solid #f1e3c7; border-radius:8px; font-size:0.92rem; }
  body.theme-dark .note-bar{ background:#2a2418; border-color:#4a3f24; }
  .note-bar .title{ font-weight:700; margin-right:6px; }
</style>
<script>
(function(){
  function ensureNoteBar(){
    try{
      var card = document.querySelector('.rightDock .card'); // board card
      if(!card) return null;
      var rowJust = card.querySelector('.row-just');
      if(!rowJust) return null;
      var ex = document.getElementById('liveNoteBar');
      if(ex) return ex;
      var bar = document.createElement('div');
      bar.id = 'liveNoteBar';
      bar.className = 'note-bar';
      bar.style.display = 'none';
      bar.innerHTML = '<span class="title">備考</span><span id="liveNoteText"></span>';
      rowJust.insertAdjacentElement('afterend', bar);
      return bar;
    }catch(_){ return null; }
  }
  function currentKifu(){
    try{
      var pk = (typeof currentPath==='function') ? currentPath() : null;
      var arr = pk ? (store.kifuByPath[pk]||[]) : [];
      return arr.find(function(x){ return x && x.id===(typeof currentKifuId !== "undefined" ? currentKifuId : window.currentKifuId); }) || null;
    }catch(_){ return null; }
  }
  function updateLiveNote(){
    try{
      var bar = ensureNoteBar();
      if(!bar) return;
      var k = currentKifu();
      var txt = (k && typeof k.comment==='string') ? k.comment.trim() : '';
      var _isTraining = (typeof training !== "undefined" ? training : !!window.training);
      var show = !!(_isTraining && txt);
      bar.style.display = show ? 'block' : 'none';
      var span = document.getElementById('liveNoteText'); if(span) span.textContent = txt;
    }catch(_){}
  }
  // patch startTrainingCore to update when a problem starts
  if(typeof window.startTrainingCore === 'function' && !window._notePatchApplied){
    var orig = window.startTrainingCore;
    window.startTrainingCore = function(p){
      var out = orig(p);
      try{ updateLiveNote(); }catch(_){}
      return out;
    };
    window._notePatchApplied = true;
  }
  // update when comment is edited in result panel
  document.addEventListener('input', function(e){
    if(e && e.target && e.target.id === 'resultCommentInput'){ try{ updateLiveNote(); }catch(_){} }
  }, true);
  // also update on renderBoard (safe, cheap)
  if(typeof window.renderBoard === 'function'){
    var origRB = window.renderBoard;
    window.renderBoard = function(){ var r = origRB(); try{ updateLiveNote(); }catch(_){ } return r; };
  }
  // initialize once DOM is ready
  document.addEventListener('DOMContentLoaded', function(){ setTimeout(updateLiveNote, 60); });
})();
</script>
<!-- ===== v17 Maintainability Layer (2025-10-23) ===== -->
<script>
;(()=>{'use strict';
/**
 * Reversi Trainer Maintainability Layer
 * - Provides a tiny event bus (RT.bus) and central wrappers for legacy globals
 * - Centralizes "unique solved" recomputation and version title bump
 * - Adds a small action registry to avoid scattered anonymous handlers
 *   (All features are no-op compatible and keep behavior unchanged.)
 */

/** @namespace */
const RT = window.RT || (window.RT = {});
RT.VERSION = '17.1-maint';
RT.conf = Object.freeze({ STORE_PREFIX: (window.STORE_PREFIX || 'othello_trainer__') });

/** micro event bus */
RT.bus = (function(){
  const map = new Map();
  return {
    on(evt, fn){
      const arr = map.get(evt) || [];
      arr.push(fn);
      map.set(evt, arr);
      return ()=>{ const a = map.get(evt)||[]; const i = a.indexOf(fn); if(i>=0){ a.splice(i,1); } };
    },
    emit(evt, payload){ (map.get(evt)||[]).slice().forEach(fn=>{ try{ fn(payload); }catch(e){ console.error('[RT.bus]', evt, e); } }); }
  };
})();

/** helpers */
const $ = (id)=> document.getElementById(id);
const onReady = (fn)=> (document.readyState === 'loading' ? document.addEventListener('DOMContentLoaded', fn, {once:true}) : fn());
const assert = (cond, msg)=>{ if(!cond){ console.warn('ASSERT:', msg); } return !!cond; };
RT.ls = {
  get(key, d){ try{ const v = localStorage.getItem(RT.conf.STORE_PREFIX + key); return v==null?d:JSON.parse(v);}catch(_){ return d; } },
  set(key, v){ try{ localStorage.setItem(RT.conf.STORE_PREFIX + key, JSON.stringify(v)); }catch(_){ } }
};

/** store facade keeps legacy shape but gives single place to change in future */
RT.store = {
  get(){ try{ return window.store || (window.loadStore? window.loadStore() : null); }catch(_){ return null; } },
  save(s){ if(typeof window.saveStore==='function'){ window.saveStore(s); RT.bus.emit('store:saved', s); } else { window.store = s; RT.bus.emit('store:saved', s); } },
  currentPath(){ try{ return (typeof window.currentPath==='function') ? window.currentPath() : (window.selectedPath || ''); }catch(_){ return ''; } },
  listAt(path){ const s=this.get(); return (s && s.kifuByPath && s.kifuByPath[path]) ? s.kifuByPath[path] : []; },
  findById(id){
    const s=this.get(); if(!s||!s.kifuByPath) return null;
    for(const [p,arr] of Object.entries(s.kifuByPath)){ const k = (arr||[]).find(k=>k&&k.id===id); if(k) return {path:p, kifu:k}; }
    return null;
  }
};

/** Centralize "version title bump" to avoid many scattered patches */
RT.bumpTitle = function(versionLabel){
  try{
    const label = 'オセロ暗記トレーナー ' + versionLabel;
    document.title = label;
    const h1 = document.querySelector('h1'); if(h1) h1.textContent = label;
  }catch(_){}
};

/** one-time wrappers -> emit lifecycle events */
(function wireLifecycle(){
  const wrapOnce = (name, evt, after=true)=>{
    const fn = window[name];
    if(typeof fn !== 'function' || window['__rt_wrapped__'+name]) return;
    window['__rt_wrapped__'+name] = true;
    window[name] = function(){
      if(!after) RT.bus.emit(evt, {args:arguments});
      const ret = fn.apply(this, arguments);
      if(after) RT.bus.emit(evt, {args:arguments, ret});
      return ret;
    };
  };
  wrapOnce('renderBoard', 'ui:renderBoard', true);
  wrapOnce('updateCountsAndPath', 'stats:updated', true);
  wrapOnce('saveStore', 'store:saved', true);
  wrapOnce('showCelebrate', 'ui:celebrate', true);
  wrapOnce('startTraining', 'training:started', true);
  wrapOnce('startTrainingWithKifuId', 'training:started', true);
})();

/** Unify "unique solved" computation here (removes multiple ad-hoc overrides) */
RT.recomputeUniqueSolved = function(){
  try{
    const s = RT.store.get(); if(!s||!s.kifuByPath) return;
    const set = new Set();
    const isCleared = (typeof window.isCleared === 'function') ? window.isCleared : (k=> !!(k?.stats?.solved>0));
    Object.values(s.kifuByPath).forEach(arr=> (arr||[]).forEach(k=>{ if(isCleared(k) && k.sig) set.add(k.sig); }));
    const el = $('uniqueSolved'); if(el) el.textContent = String(set.size);
  }catch(e){ console.warn(e); }
};
RT.bus.on('stats:updated', RT.recomputeUniqueSolved);
onReady(RT.recomputeUniqueSolved);

/** Small, declarative action registry reduces scattered anonymous handlers */
RT.actions = Object.create(null);
RT.registerAction = function(id, handler){
  if(!assert(typeof handler==='function', 'handler must be function')) return;
  RT.actions[id] = handler;
  const btn = $(id);
  if(btn && !btn.__rt_bound){
    btn.__rt_bound = true;
    btn.addEventListener('click', (ev)=>handler(ev));
  }
};

/** Example: centralize exportStats action if button exists */
RT.registerAction('exportStatsBtn', function(){
  const pk = RT.store.currentPath(); if(!pk) return;
  const arr = RT.store.listAt(pk);
  const toCsv = (rows)=> rows.map(r=> r.map(x=>'"'+String(x).replaceAll('"','""')+'"').join(',')).join('\\n');
  const header = ['id','name','len','enabled','attempts','solved','mistakes','best_ms','avg_ms','tags'];
  const rows = [header];
  arr.forEach(k=>{
    const tm = k.stats?.time || {};
    rows.push([
      k.id, k.name||'', (k.moves||[]).length, (k.enabled!==false)?1:0,
      k.stats?.attempts||0, k.stats?.solved||0, k.stats?.mistakes||0,
      (typeof tm.bestMs==='number'?tm.bestMs:''), (typeof tm.avgMs==='number'?Math.round(tm.avgMs):''), (k.tags||[]).join('|')
    ]);
  });
  const blob = new Blob([toCsv(rows)], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download=(pk.replaceAll('/','__')||'folder')+'_stats.csv';
  document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url), 1200);
});

/** Finalize */
onReady(()=> RT.bumpTitle('v17') );
})();
</script>
<script>
(function(){
  // Hard-disable any coach entry points safely (idempotent)
  try{
    window.openCoach = function(){ alert('コーチ機能は廃止されました。'); };
    window.showCoachMessage = function(){};
  }catch(_){}

  // Defensive: update "覚えた棋譜（ユニーク）" by sig after counts update (idempotent)
  if(!window._v17_unique_sig_patch){
    function _v17_updateUniqueBySig(){
      try{
        var set = new Set();
        var byPath = (window.store && window.store.kifuByPath) ? window.store.kifuByPath : {};
        Object.keys(byPath).forEach(function(p){
          (byPath[p]||[]).forEach(function(k){
            if(k && k.sig && ((k.stats && k.stats.solved>0) || (k.cleared===true))) set.add(k.sig);
          });
        });
        var el = document.getElementById('uniqueSolved'); if(el) el.textContent = String(set.size);
      }catch(_){}
    }
    if(typeof window.updateCountsAndPath === 'function'){
      var orig = window.updateCountsAndPath;
      window.updateCountsAndPath = function(){ orig(); _v17_updateUniqueBySig(); };
    }else{
      document.addEventListener('DOMContentLoaded', _v17_updateUniqueBySig, { once: true });
      setTimeout(_v17_updateUniqueBySig, 500);
    }
    window._v17_unique_sig_patch = true;
  }

  // Safer localStorage access (fallback to in-memory store if blocked)
  if(!window._v17_safe_ls){
    (function(){
      try{
        var k='__ls_test__'; localStorage.setItem(k,'1'); localStorage.removeItem(k);
      }catch(e){
        console.warn('localStorage unavailable; falling back to memory store.');
        var mem = {};
        window.localStorage = {
          getItem: function(key){ return mem.hasOwnProperty(key) ? mem[key] : null; },
          setItem: function(key, val){ mem[String(key)] = String(val); },
          removeItem: function(key){ delete mem[String(key)]; }
        };
      }
    })();
    window._v17_safe_ls = true;
  }
})();
</script>
<style id="patch-v18-rec-ordering">
/* v18 fixes: recorder panel positioning and click-through */
.rec-layer{
  position: fixed !important;
  top: 16px !important;
  left: 16px !important;
  right: auto !important;
  bottom: auto !important;
  background: none !important;
  pointer-events: none !important;
  display: none;
  z-index: 1000 !important;
}
.rec-layer .panel{
  width: min(420px, 42vw) !important;
  max-height: 80vh !important;
  overflow: auto !important;
  pointer-events: auto !important;
}
@media (max-width: 900px){
  .rec-layer{
    top: auto !important;
    left: 12px !important;
    right: 12px !important;
    bottom: 12px !important;
  }
  .rec-layer .panel{
    width: auto !important;
  }
}
</style>
<script id="patch-v18-keyboard">
/* v18 keyboard fixes
   - Reserve A–H for board coordinates: block global shortcuts when letter typed as coordinate (capture-phase).
   - ESC cancels mid coordinate input (ensures overlay hidden).
   - Remap shortcuts off A–H:
       * K: open kifu list (was G)
       * Q: toggle MCQ overlay (was C)
   - Keep original bindings as fallback with modifiers (Ctrl+G still opens list).
*/
(function(){
  function isTypingField(el){
    const t = (el && el.tagName) ? el.tagName.toLowerCase() : '';
    return t==='input' || t==='textarea' || t==='select' || el?.isContentEditable;
  }

  // Capture-phase guard: swallow A–H / 1–8 when used for coordinate typing
  window.addEventListener('keydown', function(e){
    try{
      if(!window.training) return;
      if(isTypingField(e.target)) return;
      // cancel coordinate buffer with ESC by hiding overlay; original handler will also see this and do nothing
      if(e.key === 'Escape'){
        const o = document.getElementById('kbdOverlay'); if(o){ o.style.display='none'; }
        // Best-effort: mark cancelled to avoid any downstream handling
        window.__kbdEscCancelledAt = Date.now();
        e.stopPropagation(); if(e.stopImmediatePropagation) e.stopImmediatePropagation();
        return; // Do not preventDefault so other uses of ESC still work (modals have their own listeners)
      }
      const isCoordLetter = /^[a-hA-H]$/.test(e.key) && !e.ctrlKey && !e.metaKey && !e.altKey;
      const isCoordDigit  = /^[1-8]$/.test(e.key);
      if(isCoordLetter || isCoordDigit){
        // Let original coordinate handler run (it was also registered in capture-phase before this),
        // but stop the event from bubbling to global shortcut handlers.
        e.preventDefault();
        e.stopPropagation(); if(e.stopImmediatePropagation) e.stopImmediatePropagation();
        // Note: we intentionally do NOT return false; the earlier capture handler already handled UI.
      }

      // Block legacy bare 'g' and 'c' shortcuts during training to avoid conflict with coordinates
      if((e.key==='g' || e.key==='G' || e.key==='c' || e.key==='C') && !e.ctrlKey && !e.metaKey && !e.altKey){
        e.preventDefault();
        e.stopPropagation(); if(e.stopImmediatePropagation) e.stopImmediatePropagation();
      }
    }catch(_){}
  }, {capture:true});

  // New non-conflicting shortcuts (bubble-phase OK)
  window.addEventListener('keydown', function(e){
    try{
      if(isTypingField(e.target)) return;
      // Open kifu list: K (or Ctrl+G for people used to the old key)
      if((e.key==='k' || e.key==='K') && typeof window.openKifuModal === 'function'){
        e.preventDefault(); window.openKifuModal(); return;
      }
      if((e.key==='g' || e.key==='G') && (e.ctrlKey || e.metaKey) && typeof window.openKifuModal === 'function'){
        e.preventDefault(); window.openKifuModal(); return;
      }
      // Toggle MCQ overlay: Q (or Ctrl+C)
      if((e.key==='q' || e.key==='Q') && typeof window.OPT === 'function' && typeof window.SETOPT === 'function'){
        e.preventDefault();
        try{
          const v = !window.OPT('mcq', false);
          window.SETOPT('mcq', v);
          if(typeof window.updateMCQ === 'function') window.updateMCQ();
        }catch(_){}
        return;
      }
      if((e.key==='c' || e.key==='C') && (e.ctrlKey || e.metaKey) && typeof window.OPT === 'function'){
        e.preventDefault();
        try{
          const v = !window.OPT('mcq', false);
          window.SETOPT('mcq', v);
          if(typeof window.updateMCQ === 'function') window.updateMCQ();
        }catch(_){}
        return;
      }
    }catch(_){}
  });
})();
</script>
<!-- ===== v18.1 Keyboard & UX fixes (2025-10-23) ===== -->
<script>
(function(){
  function isTypingField(el){
    const t = (el && el.tagName) ? el.tagName.toLowerCase() : '';
    return t==='input' || t==='textarea' || t==='select' || (el && el.isContentEditable);
  }

  // Remove the inline legacy tip text that mentions old shortcuts.
  document.addEventListener('DOMContentLoaded', function(){
    document.querySelectorAll('.small.muted').forEach(function(el){
      const tx = (el.textContent || '').trim();
      if(/ショートカット：T=白視点/.test(tx) || //.test(tx)){
        el.remove();
      }
    });
  });

  // Override the "ショートカット一覧" help to show the complete, updated list.
  function showShortcutsHelp(){
    alert([
      'ショートカット：',
      '  N：次の問題を出題',
      '  R：今の問題をもう一度',
      '  L：期待手ハイライトの切替',
      '  M：マス内座標の切替',
      '  S：効果音の切替',
      '  T：白視点の切替',
      '  V：読み上げの切替',
      '  J：両方を自分で打つの切替',
                  '  A〜H→1〜8：座標入力（例：C3）',
      '  L：棋譜一覧を開く',
      '  ← / →：確認モードで1手戻る／進む',
      '  Esc：祝福画面／一覧を閉じる、確認中は「暗記再開」と同じ'
    ].join('\\n'));
  }
  // Capture-phase override so older listeners won't fire.
  document.addEventListener('click', function(e){
    const t = e.target;
    if(t && t.classList && t.classList.contains('inline-help') && /ショートカット一覧/.test(t.textContent||'')){
      e.preventDefault();
      e.stopPropagation();
      if(e.stopImmediatePropagation) e.stopImmediatePropagation();
      showShortcutsHelp();
    }
  }, true);

  // L：いつでも棋譜一覧を開く（入力中は無効）
  window.addEventListener('keydown', function(e){
    if(isTypingField(e.target)) return;
    if(e.key==='l' || e.key==='L'){
      e.preventDefault();
      try{
        if(typeof window.openKifuModal === 'function'){ window.openKifuModal(); }
        else if(typeof window.openKifuList === 'function'){ window.openKifuList(); }
        else {
          var btn = document.getElementById('openListBtn') || document.getElementById('kifuListBtn');
          if(btn) btn.click();
        }
      }catch(_){}
    }
  }, true);

  // J：両方を自分で打つ の切替（B は使わない）
  window.addEventListener('keydown', function(e){
    if(isTypingField(e.target)) return;
    if(e.key==='j' || e.key==='J'){
      e.preventDefault();
      try{
        var el = (typeof window.toggleSelfBothEl !== 'undefined' && window.toggleSelfBothEl)
                  ? window.toggleSelfBothEl
                  : document.getElementById('toggleSelfBoth');
        if(el){
          el.checked = !el.checked;
          el.dispatchEvent(new Event('change'));
        }else if(typeof window.toggleSelfBoth === 'function'){
          window.toggleSelfBoth();
        }
      }catch(_){}
    }
  }, true);

  // 確認中（inspectMode）に Esc で「暗記再開」と同じ処理
  window.addEventListener('keydown', function(e){
    try{
      if(e.key==='Escape' && window.inspectMode){
        e.preventDefault();
        if(typeof window.exitInspectResume === 'function'){
          window.exitInspectResume();
        }else{
          var btn = document.getElementById('resumeBtn');
          if(btn) btn.click();
        }
      }
    }catch(_){}
  }, true);

  // 「カレンダー」「フリーズ」が確実に開くようにフォールバックを配線
  function ensureCalendarWired(){
    var btn = document.getElementById('calendarBtn');
    if(btn && !btn._wired){
      btn.addEventListener('click', function(ev){
        ev.preventDefault();
        try{
          if(typeof window.openCalendar === 'function'){
            window.openCalendar();
          }else if(typeof window.ensureCalModal === 'function'){
            window.ensureCalModal();
            var m = document.getElementById('calendarModal');
            if(m) m.style.display='flex';
          }
        }catch(_){}
      });
      btn._wired = true;
    }
  }
  function ensureFreezeWired(){
    var btn = document.getElementById('freezeBtn');
    if(btn && !btn._wired){
      btn.addEventListener('click', function(ev){
        ev.preventDefault();
        try{
          if(typeof window.openFreeze === 'function'){
            window.openFreeze();
          }else if(typeof window.ensureFreezeModal === 'function'){
            window.ensureFreezeModal();
            var m = document.getElementById('freezeModal');
            if(m) m.style.display='flex';
          }
        }catch(_){}
      });
      btn._wired = true;
    }
  }
  document.addEventListener('DOMContentLoaded', function(){
    ensureCalendarWired();
    ensureFreezeWired();
  });
})();
</script>
<!-- ===== storage-compress patch (disabled: 2025-10-24 fix) ===== -->
<script>
// This patch has been disabled because the embedded LZString snippet was corrupted
// and caused syntax errors in some browsers. The app falls back to the default
// JSON-based saveStore()/loadStore() defined earlier.
</script>
<!-- ===== v19 Addons by ChatGPT (2025-10-23) ===== -->
<style>
/* v19: solved list chips + recorder overlay rotation guard */
#boardWrap.rot180 .rec-layer,
#boardWrap.rot180 #recorderOverlay,
#boardWrap.rot180 #recorderWindow { transform: none !important; }

/* Make solved list look like chips if not already */
#solvedList.chips .chip{ margin: 2px 4px 2px 0; }
</style>
<script>
// ===== v19 Addons by ChatGPT (2025-10-23) =====
(function(){
  'use strict';

  // ---------- 1) 暗記一覧（クリアリスト）に「正解カウント」を表示 ----------
  function _v19_renderSolvedList_override(){
    try{
      const el = document.getElementById('solvedList');
      if(!el) return;
      el.classList.add('chips'); // chip スタイルを有効に
      const pk = (typeof window.currentPath==='function') ? currentPath() : '';
      const arr = (typeof window.getArrayByPath==='function') ? getArrayByPath(pk) : ((window.store && store.kifuByPath && store.kifuByPath[pk]) ? store.kifuByPath[pk] : []);
      const items = [];
      (arr||[]).forEach((k, idx)=>{
        try{
          const cleared = (typeof window.isCleared==='function') ? isCleared(k) : !!(k && k.stats && (k.stats.solved||0)>0);
          if(cleared){
            const n = (typeof k._idx==='number' ? k._idx+1 : idx+1);
            const cnt = (k && k.stats && k.stats.solved)|0;
            items.push({ n, cnt });
          }
        }catch(_){}
      });
      el.innerHTML = '';
      if(!items.length){
        el.textContent = '（まだ正解に到達した棋譜はありません）';
      }else{
        items.sort((a,b)=> a.n - b.n);
        items.forEach(it=>{
          const chip = document.createElement('span');
          chip.className = 'chip';
          chip.textContent = '棋譜' + it.n + '｜✓ ' + it.cnt + ' 回';
          el.appendChild(chip);
        });
      }

      // ユニーク達成数（sigベース）を再集計してヘッダの表示を更新
      try{
        const set = new Set();
        const all = (window.store && store.kifuByPath) ? store.kifuByPath : {};
        Object.values(all).forEach(list=> (list||[]).forEach(k=>{
          try{
            const ok = !!(k && k.stats && (k.stats.solved||0)>0);
            const sig = k && (k.sig || (k.moves ? canonicalSignature(k.moves) : null));
            if(ok && sig) set.add(sig);
}catch(_){}
        }));
        const uEl = document.getElementById('uniqueSolved');
        if(uEl) uEl.textContent = String(set.size);
      }catch(_){}
    }catch(_){
      // fall back to original implementation if anything goes wrong
      try{ if(typeof window._v19_orig_renderSolvedList==='function') _v19_orig_renderSolvedList(); }catch(_){}
    }
  }

  if(typeof window.renderSolvedList==='function' && !window._v19_renderSolvedList_patched){
    window._v19_orig_renderSolvedList = window.renderSolvedList;
    window.renderSolvedList = _v19_renderSolvedList_override;
    window._v19_renderSolvedList_patched = true;
  }

  // 初期表示も整える
  try{ _v19_renderSolvedList_override(); }catch(_){}

  // ---------- 2) 実績：ユニーク達成（覚えた棋譜の数）を追加 ----------
  const K14 = (k)=> (window.STORE_PREFIX || '') + 'opt14_' + k;
  function getAch14(){ try{ const v=localStorage.getItem(K14('ach')); return v?JSON.parse(v):{}; }catch(_){ return {}; } }
  function setAch14(m){ try{ localStorage.setItem(K14('ach'), JSON.stringify(m||{})); }catch(_){ } }
  function uniqueSolvedCount(){
  try{
    const all = (window.store && store.kifuByPath) ? store.kifuByPath : {};
    const set = new Set();
    Object.values(all).forEach(list => (list||[]).forEach(k => {
      try{
        const ok = !!(k && k.stats && (k.stats.solved||0)>0); // ノーミスクリアのみ
        const sig = k && (k.sig || (k.moves ? canonicalSignature(k.moves) : null));
        if(ok && sig) set.add(sig);
      }catch(_){ }
    }));
    return set.size;
  }catch(_){ return 0; }
};
      const set = new Set();
      Object.values(all).forEach(list => (list||[]).forEach(k => {
        try{
          const ok = !!(k && k.stats && (k.stats.solved||0)>0);
            const sig = k && (k.sig || (k.moves ? canonicalSignature(k.moves) : null));
            if(ok && sig) set.add(sig);
}catch(_){}
      }));
      return set.size;
    }catch(_){ return 0; }
  }
  const _v19_uniqueTiers = [
    [10,'UNQ_10','駆け出し暗記人'],
    [30,'UNQ_30','暗記人'],
    [50,'UNQ_50','暗記職人'],
    [100,'UNQ_100','暗記名人'],
    [200,'UNQ_200','暗記達人'],
    [300,'UNQ_300','暗記仙人'],
    [400,'UNQ_400','暗記星人'],
    [500,'UNQ_500','暗記神様']
  ];
  function unlockUniqueTier(key, title){
    const m = getAch14();
    if(m[key]) return false;
    m[key] = { at: new Date().toISOString() };
    setAch14(m);
    try{ if(typeof window.showToast==='function') showToast('実績解除：' + title); }catch(_){}
    try{ if(typeof window.speakJa==='function') speakJa('実績解除'); }catch(_){}
    return true;
  }
  function awardUniqueIfMet(){
    const u = uniqueSolvedCount();
    _v19_uniqueTiers.forEach(([n,key,title])=>{ if(u>=n) unlockUniqueTier(key, title); });
  }
  // クリア時にユニーク実績も評価（ノーミス時のみ）
  if(typeof window.showCelebrate==='function' && !window._v19_ach_hooked){
    const orig = window.showCelebrate;
    window.showCelebrate = function(total, mistakes){
      const out = orig(total, mistakes);
      try{ if(mistakes===0){
        try{
          const pk = currentPath();
          const arr = (store && store.kifuByPath && store.kifuByPath[pk]) ? store.kifuByPath[pk] : [];
          const k = arr.find(x=>x.id===currentKifuId);
          const sig = k && (k.sig || (k.moves ? canonicalSignature(k.moves) : null));
          if(sig){ const set = new Set(store.learnedOnceSigs||[]); set.add(sig); store.learnedOnceSigs = Array.from(set); saveStore(store); }
        }catch(_){ }
        awardUniqueIfMet();
      } }catch(_){}
      return out;
    };
    window._v19_ach_hooked = true;
  }
  // 実績モーダルにユニーク段位を追記
  if(typeof window.openAchievements==='function' && !window._v19_ach_ui){
    const origOpen = window.openAchievements;
    window.openAchievements = function(){
      origOpen();
      try{
        const body = document.getElementById('achBody'); if(!body) return;
        if(document.getElementById('unqBlock')) return;
        const owned = getAch14();
        const block = document.createElement('div'); block.id='unqBlock';
        block.style.gridColumn = '1 / -1';
        const hdr = document.createElement('div'); hdr.className='small muted'; hdr.textContent='— 覚えた棋譜（ユニーク）ランク —';
        block.appendChild(hdr);
        const grid = document.createElement('div'); grid.style.display='grid'; grid.style.gridTemplateColumns='repeat(auto-fill,minmax(200px,1fr))'; grid.style.gap='10px';
        _v19_uniqueTiers.forEach(([n,key,title])=>{
          const card = document.createElement('div'); card.className='achi-card' + (owned[key]?'':' locked');
          const t = document.createElement('div'); t.className='achi-title'; t.textContent = '📚 ' + title;
          const d = document.createElement('div'); d.className='achi-desc';
          d.textContent = '覚えた棋譜（ユニーク）：' + n + ' 以上' + (owned[key]? ('｜解除日：' + (owned[key].at||'')) : '');
          card.appendChild(t); card.appendChild(d); grid.appendChild(card);
        });
        const u = uniqueSolvedCount();
        const prog = document.createElement('div'); prog.className='small muted'; prog.textContent = '現在のユニーク達成数：' + u;
        block.appendChild(grid); block.appendChild(prog);
        body.appendChild(block);
      }catch(_){}
    };
    window._v19_ach_ui = true;
  }

  // ---------- 3) 「録画」の設定ウィンドウが回転しないように修正 ----------
  function relocateRecLayer(){
    try{
      const wrap = document.getElementById('boardWrap');
      const layer = document.querySelector('.rec-layer');
      if(layer && wrap && layer.parentElement === wrap){
        document.body.appendChild(layer);
        layer.style.position = 'fixed';
        layer.style.transform = 'none';
        layer.style.zIndex = '1000';
      }
    }catch(_){}
  }
  // 初回＆今後の生成にも追従
  try{ relocateRecLayer(); }catch(_){}
  try{
    const mo = new MutationObserver(()=> relocateRecLayer());
    mo.observe(document.body, { childList:true, subtree:true });
  }catch(_){}

})(); // end v19
</script>
<!-- ==== Patch: Remove Global Heatmap + Add Clear Buttons (2025-10-24) ==== -->
<script>
(function(){
  try {
    // --- Abolish Global Heatmap feature entirely ---
    // Force option off and delete any stored global data.
    try {
      if (typeof SETOPT === 'function') { SETOPT('globalHeat', false); }
    } catch(_) {}
    try {
      if (typeof STORE_PREFIX !== 'undefined' && window.localStorage) {
        localStorage.removeItem(STORE_PREFIX + 'opt11_globalMistake');
      }
    } catch(_) {}

    // Neutralize any global-heat related functions if present.
    try { window.getGlobalMap = function(){ return {}; }; } catch(_) {}
    try { window.setGlobalMap = function(_){ /* removed */ }; } catch(_) {}
    try { window.updateGlobalHeatUI = function(){ /* removed */ }; } catch(_) {}
    try { window.drawGlobalHeat = function(){ /* removed */ }; } catch(_) {}
    // Avoid any previous "flashX" wrappers from logging to global map by disabling the marker.
    try { window._v11_flash_patched = true; } catch(_) {}

    // Remove Global Heat toggle UI if it exists.
    try {
      var chk = document.getElementById('globalHeatChk');
      if (chk) {
        var label = chk.closest('label') || chk.parentElement;
        if (label && label.remove) label.remove();
        else chk.remove();
      }
    } catch(_) {}

    // --- Add "clear counts" buttons for per-kifu heatmap ---
    function clearCurrentKifuMistakes() {
      try{
        if (typeof getCurrentKifuObj !== 'function') { alert('現棋譜の取得に失敗しました。'); return; }
        var k = getCurrentKifuObj();
        if (!k) { alert('現棋譜が見つかりません。'); return; }
        delete k.mistakeCounts;
        delete k.mistakeByTurn;
        if (typeof saveStore === 'function') saveStore(store);
        if (typeof updateHeatOverlay === 'function') updateHeatOverlay();
        alert('現棋譜のカウント情報を全て消去しました。');
      }catch(e){
        console.warn(e);
        alert('現棋譜のカウント消去でエラーが発生しました。');
      }
    }

    function clearAllKifuMistakes() {
      try{
        if (!window.store || !store.kifuByPath) { alert('データストアが見つかりません。'); return; }
        Object.keys(store.kifuByPath).forEach(function(pathKey){
          var arr = store.kifuByPath[pathKey] || [];
          arr.forEach(function(k){
            if (k) { delete k.mistakeCounts; delete k.mistakeByTurn; }
          });
        });
        if (typeof saveStore === 'function') saveStore(store);
        if (typeof updateHeatOverlay === 'function') updateHeatOverlay();
        // ついでにグローバルヒートの残骸も掃除
        try {
          if (typeof STORE_PREFIX !== 'undefined' && window.localStorage) {
            localStorage.removeItem(STORE_PREFIX + 'opt11_globalMistake');
          }
        } catch(_) {}
        alert('すべての棋譜のカウント情報を全て消去しました。');
      }catch(e){
        console.warn(e);
        alert('全棋譜のカウント消去でエラーが発生しました。');
      }
    }

    // Insert buttons next to the existing per-kifu heatmap toggle.
    try{
      var heatChk = document.getElementById('heatChk');
      if (heatChk) {
        var container = heatChk.closest('.field') || (heatChk.parentElement && heatChk.parentElement.parentElement) || null;
        if (container && !document.getElementById('clearCurrKifuBtn')) {
          var spacer1 = document.createTextNode('　');
          var btn1 = document.createElement('button');
          btn1.id = 'clearCurrKifuBtn';
          btn1.type = 'button';
          btn1.className = 'small';
          btn1.textContent = '現棋譜のカウントを全消去';

          var spacer2 = document.createTextNode(' ');
          var btn2 = document.createElement('button');
          btn2.id = 'clearAllKifuBtn';
          btn2.type = 'button';
          btn2.className = 'small';
          btn2.textContent = 'すべての棋譜のカウントを全消去';

          container.appendChild(spacer1);
          container.appendChild(btn1);
          container.appendChild(spacer2);
          container.appendChild(btn2);

          btn1.addEventListener('click', function(ev){ ev.preventDefault(); clearCurrentKifuMistakes(); });
          btn2.addEventListener('click', function(ev){ ev.preventDefault(); 
            if (confirm('本当に全ての棋譜のカウントを消去しますか？この操作は元に戻せません。')) {
              clearAllKifuMistakes();
            }
          });
        }
      }
    }catch(e){ console.warn(e); }
  } catch(e) { console.warn('Patch error', e); }
})();
</script>
<!-- ==== Patch: UI fixes (2025-10-24) ==== -->
<script id="patch-2025-10-24-ui-fixes">
(function(){
  try {
    // 1) Ensure bottom-left keyboard typing overlay exists and is styled.
    (function ensureKbdOverlay(){
      var o = document.getElementById('kbdOverlay');
      if(!o){
        o = document.createElement('div');
        o.id = 'kbdOverlay';
        o.style.position = 'fixed';
        o.style.left = '8px';
        o.style.bottom = '8px';
        o.style.padding = '4px 8px';
        o.style.background = 'rgba(0,0,0,0.65)';
        o.style.color = '#fff';
        o.style.borderRadius = '4px';
        o.style.fontSize = '12px';
        o.style.lineHeight = '1.4';
        o.style.whiteSpace = 'pre';
        o.style.zIndex = '9999';
        o.style.pointerEvents = 'none';
        o.style.display = 'none';
        document.body.appendChild(o);
      }
    })();

    // 2) Move "対称変換：" + selector to directly under "すべての棋譜のカウントを全消去"
    ;(function fixSymPlacement(){
      var tries = 0;
      function attempt(){
        tries++;
        var btn2 = document.getElementById('clearAllKifuBtn'); // 「すべての棋譜のカウントを全消去」
        var symSel = document.getElementById('symmetrySel');
        // try to locate the symmetry label within the same field
        var symLbl = null;
        if(symSel){
          var root = symSel.closest('.field') || symSel.parentNode || document;
          var labels = root.querySelectorAll('label');
          for(var i=0;i<labels.length;i++){
            var t = (labels[i].textContent||'').replace(/\s+/g,'').trim();
            if(t.indexOf('対称変換') !== -1){ symLbl = labels[i]; break; }
          }
        }
        if(btn2 && symSel && symLbl){
          // Remove from current position
          try { if(symLbl.parentNode) symLbl.parentNode.removeChild(symLbl); } catch(_) {}
          try { if(symSel.parentNode) symSel.parentNode.removeChild(symSel); } catch(_) {}
          // Wrap to force a new line under the clear-all button (flex row wrap container)
          var wrap = document.createElement('div');
          wrap.className = 'symmetry-wrap';
          wrap.style.flexBasis = '100%';
          wrap.style.marginTop = '6px';
          wrap.appendChild(symLbl);
          wrap.appendChild(symSel);
          btn2.insertAdjacentElement('afterend', wrap);
          return true;
        }
        if(tries < 60){ setTimeout(attempt, 250); }
        return false;
      }
      attempt();
    })();
  } catch(e) { console.warn('patch-2025-10-24-ui-fixes error', e); }
})();
</script>
<script id="v20-kbdpos-freeze-calfix">
(function(){
  'use strict';

  // ---------- helpers (local to this patch) ----------
  function byId(id){ return document.getElementById(id); }
  function dayKey(d){
    var y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), dd=String(d.getDate()).padStart(2,'0');
    return y+'-'+m+'-'+dd;
  }
  function isoWeekKey(dt){
    var d = new Date(Date.UTC(dt.getFullYear(), dt.getMonth(), dt.getDate()));
    var dayNum = d.getUTCDay() || 7;
    d.setUTCDate(d.getUTCDate() + 4 - dayNum);
    var yearStart = new Date(Date.UTC(d.getUTCFullYear(),0,1));
    var weekNo = Math.ceil((((d - yearStart) / 86400000) + 1)/7);
    return d.getUTCFullYear() + '-W' + String(weekNo).padStart(2,'0');
  }
  function getLogsPatched(){
    try{ return JSON.parse(localStorage.getItem((typeof STORE_PREFIX!=='undefined'?STORE_PREFIX:'reversi_trainer_') + 'opt10_logs')||'[]'); }
    catch(_){ return []; }
  }
  function K15(k){ return (typeof STORE_PREFIX!=='undefined'?STORE_PREFIX:'reversi_trainer_') + 'opt15_' + k; }
  function jget(k, d){ try{ var v = localStorage.getItem(K15(k)); return v==null?d:JSON.parse(v); }catch(_){ return d; } }
  function jset(k, v){ try{ localStorage.setItem(K15(k), JSON.stringify(v)); }catch(_){ } }

  // ---------- 1) Keyboard overlay: ensure exists & show at board lower-left ----------
  function ensureKbdOverlay(){
    var wrap = byId('boardWrap');
    if(!wrap) return;
    var o = byId('kbdOverlay');
    if(!o){
      o = document.createElement('div');
      o.id = 'kbdOverlay';
      o.className = 'kbd-overlay';
      o.setAttribute('aria-live','polite');
      wrap.appendChild(o);
    }else{
      // If it exists but is NOT under boardWrap (older patch), move it and reset inline positioning
      if(o.parentElement !== wrap){
        wrap.appendChild(o);
      }
      // reset any inline positioning from old patch
      o.style.position = '';
      o.style.left = '';
      o.style.bottom = '';
      o.style.right = '';
      o.style.top = '';
      o.style.zIndex = '';
      o.style.pointerEvents = 'none';
      // keep display hidden until needed
      o.style.display = 'none';
      if(o.className.indexOf('kbd-overlay') === -1){
        o.className = (o.className ? o.className + ' ' : '') + 'kbd-overlay';
      }
    }
  }
  function hookKbdOverlay(){
    if(window._v20_kbdHooked) return;
    window._v20_kbdHooked = true;
    var buf = '';
    function show(txt){
      var o = byId('kbdOverlay'); if(!o) return;
      o.textContent = txt; o.style.display = 'inline-block';
    }
    function hide(){ var o=byId('kbdOverlay'); if(o) o.style.display='none'; }

    window.addEventListener('keydown', function(e){
      try{
        var tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
        if(tag==='input' || tag==='textarea' || tag==='select' || e.isComposing) return;
        var k = e.key;
        if(/^[a-hA-H]$/.test(k)){
          buf = k.toUpperCase();
          show('入力: ' + buf + ' _');
        }else if(buf && /^[1-8]$/.test(k)){
          var coord = buf + k;
          show('入力: ' + coord);
          buf = '';
          setTimeout(hide, 1200);
        }else if(k==='Escape'){
          buf = ''; hide();
        }
      }catch(_){}
    }, true);
  }

  // ---------- 2) Calendar & Freeze buttons (robust) ----------
  function ensureButtons(){
    var topbar = document.querySelector('.topbar');
    if(!topbar) return;
    var holder = document.getElementById('moreWrap') || topbar;

    function attach(id, text, onClick){
      var b = byId(id);
      if(!b){
        b = document.createElement('button');
        b.id = id; b.className = 'ghost tiny'; b.textContent = text;
        holder.appendChild(b);
      }
      if(!b._v20_click){
        b.addEventListener('click', function(ev){ ev.preventDefault(); onClick(); });
        b._v20_click = true;
      }
    }

    attach('calendarBtn', 'カレンダー', openCalendarPatched);
    attach('freezeBtn', 'フリーズ', openFreezePatched);
  }

  // ---------- 2-a) Calendar (patched fallback) ----------
  function ensureCalendarModalPatched(){
    if(byId('calendarModal')) return;
    var modal = document.createElement('div');
    modal.className = 'modal cal-modal'; modal.id = 'calendarModal';
    modal.innerHTML = ''
      + '<div class="window">'
      + '  <header><h3>カレンダー</h3><button class="ghost" id="calClose">閉じる</button></header>'
      + '  <div class="body">'
      + '    <div class="small muted">直近20週間の達成状況（1日1回以上「正解」でカウント）。</div>'
      + '    <div id="calGrid" class="grid" style="display:grid; grid-template-columns:auto repeat(7, 18px); gap:4px; align-items:center; font-size:12px; margin-top:8px;"></div>'
      + '  </div>'
      + '  <div class="footer"><span class="small muted">※ ローカル保存の試行ログから集計</span></div>'
      + '</div>';
    document.body.appendChild(modal);
    modal.addEventListener('click', function(e){ if(e.target===modal) modal.style.display='none'; });
    modal.querySelector('#calClose').addEventListener('click', function(){ modal.style.display='none'; });
  }
  function renderCalendarGridPatched(){
    var grid = byId('calGrid'); if(!grid) return;
    var count = Object.create(null);
    try{
      var logs = getLogsPatched().filter(function(r){ return r && (r.solved || r.mistakes===0); });
      logs.forEach(function(r){
        if(r && r.timestamp){
          var dd = String(r.timestamp).slice(0,10);
          count[dd] = (count[dd]||0) + 1;
        }
      });
      (jget('freezeDays', [])||[]).forEach(function(dd){ count[dd] = (count[dd]||0) + 1; });
    }catch(_){}

    grid.innerHTML = '';
    var today = new Date();
    var start = new Date(today); start.setDate(today.getDate() - 7*19);
    var wd = (start.getDay()||7); start.setDate(start.getDate() - (wd-1)); // Monday align

    for(var week=0; week<20; week++){
      var ref = new Date(start); ref.setDate(start.getDate() + week*7);
      var weekLabel = document.createElement('div');
      weekLabel.className='cal-week';
      weekLabel.textContent = isoWeekKey(ref).replace('W','週');
      grid.appendChild(weekLabel);
      for(var d=0; d<7; d++){
        var dt = new Date(ref); dt.setDate(ref.getDate()+d);
        var cell = document.createElement('div'); cell.className='cal-cell';
        if(dt > today){ cell.style.opacity='.3'; grid.appendChild(cell); continue; }
        var key = dayKey(dt);
        var n = count[key]||0;
        var color = '#e2e8f0';
        if(n>=4) color = '#6366f1';
        else if(n===3) color = '#818cf8';
        else if(n===2) color = '#a5b4fc';
        else if(n===1) color = '#c7d2fe';
        cell.style.width='18px'; cell.style.height='18px'; cell.style.borderRadius='3px'; cell.style.background=color;
        cell.title = key + '：' + n + '件';
        grid.appendChild(cell);
      }
    }
  }
  function openCalendarPatched(){
    try{ if(typeof window.openCalendar === 'function'){ window.openCalendar(); return; } }catch(_){}
    ensureCalendarModalPatched();
    renderCalendarGridPatched();
    var m = byId('calendarModal'); if(m) m.style.display='flex';
  }

  // ---------- 2-b) Freeze (patched fallback) ----------
  function ensureFreezeModalPatched(){
    if(byId('freezeModal')) return;
    var modal = document.createElement('div'); modal.className='modal freeze-modal'; modal.id='freezeModal';
    modal.innerHTML = ''
      + '<div class="window">'
      + '  <header><h3>ストリーク・フリーズ</h3><button class="ghost" id="freezeClose">閉じる</button></header>'
      + '  <div class="body">'
      + '    <div class="field"><div class="small muted">週に1回まで「練習した日」として扱う救済機能です。</div></div>'
      + '    <div class="field"><div id="freezeStatus" class="challenge-meta">—</div></div>'
      + '    <div class="row wrap">'
      + '      <button class="ghost" id="freezeYesterdayBtn">前日をフリーズ</button>'
      + '      <button class="ghost" id="freezeTodayBtn">今日をフリーズ</button>'
      + '    </div>'
      + '  </div>'
      + '  <div class="footer"><span class="small muted">※ ローカルに保存されます</span></div>'
      + '</div>';
    document.body.appendChild(modal);
    modal.addEventListener('click', function(e){ if(e.target===modal) modal.style.display='none'; });
    modal.querySelector('#freezeClose').addEventListener('click', function(){ modal.style.display='none'; });
    modal.querySelector('#freezeYesterdayBtn').addEventListener('click', function(){ useFreezePatched(-1); });
    modal.querySelector('#freezeTodayBtn').addEventListener('click', function(){ useFreezePatched(0); });
  }
  function getFreezeDaysPatched(){ return jget('freezeDays', []); }
  function setFreezeDaysPatched(a){ jset('freezeDays', a||[]); }
  function weekBudgetKeyPatched(wk){ return 'freezeBudget_'+wk; }
  function getWeekBudgetPatched(wk){ return jget(weekBudgetKeyPatched(wk), { used:0, limit:1 }); }
  function setWeekBudgetPatched(wk, obj){ jset(weekBudgetKeyPatched(wk), obj||{used:0,limit:1}); }

  function refreshFreezeUIPatched(){
    var now = new Date();
    var wk = isoWeekKey(now);
    var budget = getWeekBudgetPatched(wk);
    var days = new Set(getFreezeDaysPatched());
    var y = new Date(); y.setDate(now.getDate()-1);
    var status = [
      '今週のフリーズ使用：' + budget.used + ' / ' + budget.limit,
      'フリーズ済み日数：' + days.size + '（直近：' + (Array.from(days).sort().slice(-1)[0] || '—') + '）'
    ].join('　｜　');
    var el = byId('freezeStatus'); if(el) el.textContent = status;

    var logs = getLogsPatched().filter(function(r){ return r && r.solved; });
    var solved = new Set(logs.map(function(r){ return String(r.timestamp).slice(0,10); }));
    var keyY = dayKey(y), keyT = dayKey(now);
    var byn = byId('freezeYesterdayBtn'), btn = byId('freezeTodayBtn');
    if(byn){ byn.disabled = solved.has(keyY) || days.has(keyY) || (budget.used>=budget.limit); }
    if(btn){ btn.disabled = solved.has(keyT) || days.has(keyT) || (budget.used>=budget.limit); }
  }
  function useFreezePatched(delta){
    var dt = new Date(); dt.setDate(dt.getDate() + delta);
    var key = dayKey(dt);
    var wk = isoWeekKey(new Date());
    var budget = getWeekBudgetPatched(wk);
    if(budget.used >= budget.limit){ alert('今週のフリーズは使い切りました'); return; }
    var days = new Set(getFreezeDaysPatched());
    if(days.has(key)){ alert('その日は既にフリーズ済みです'); return; }
    days.add(key); setFreezeDaysPatched(Array.from(days));
    budget.used += 1; setWeekBudgetPatched(wk, budget);
    try{ if(typeof showToast==='function') showToast('フリーズを使いました：' + key); }catch(_){}
    refreshFreezeUIPatched();
    try{ if(window._v13_updateStreak) window._v13_updateStreak(); }catch(_){}
  }
  function openFreezePatched(){
    try{ if(typeof window.openFreeze === 'function'){ window.openFreeze(); return; } }catch(_){}
    ensureFreezeModalPatched();
    refreshFreezeUIPatched();
    var m = byId('freezeModal'); if(m) m.style.display='flex';
  }

  // ---------- init after DOM ready ----------
  function init(){
    ensureKbdOverlay();
    hookKbdOverlay();
    ensureButtons();
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  }else{
    init();
  }
})();
</script>
<script>
  // PWA service worker registration
  (function(){
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function() {
        navigator.serviceWorker.register('./sw.js').catch(function(e){
          console && console.warn && console.warn('SW registration failed:', e);
        });
      });
    }
  })();
</script></body></html>
<!-- === Final patch: remove MCQ & range-auto, and harden coordinate typing === -->
<script>
(function(){
  try{
    // Force MCQ off and remove artifacts
    if (typeof STORE_PREFIX === 'string') {
      try{ localStorage.removeItem(STORE_PREFIX + 'opt11_mcq'); }catch(_){}
      try{ localStorage.removeItem(STORE_PREFIX + 'opt_mcq'); }catch(_){}
    }
  }catch(_){}
  try{
    window.updateMCQ = function(){};  // no-op
  }catch(_){}
  try{
    document.querySelectorAll('#mcqOverlay, .mcq-overlay').forEach(n=> n.remove());
  }catch(_){}

  // Override any residual "ショートカット一覧" to exclude MCQ.
  try{
    window.showShortcutsHelp = function(){
      alert([
        'ショートカット：',
        '  N：次の問題を出題',
        '  R：今の問題をもう一度',
        '  L：期待手ハイライトの切替',
        '  M：マス内座標の切替',
        '  S：効果音の切替',
        '  T：白視点の切替',
        '  V：読み上げの切替',
        '  J：両方を自分で打つの切替',
        '  A〜H→1〜8：座標入力（例：C3）',
        '  ← / →：確認モードで1手戻る／進む',
        '  Esc：祝福画面／一覧を閉じる、確認中は「暗記再開」と同じ'
      ].join('\\n'));
    };
  }catch(_){}

  // Harden coordinate typing: capture early and dispatch click to the cell.
  (function(){
    var buf = '';
    function resetBuf(){
      buf='';
      try{
        var o=document.getElementById('kbdOverlay'); if(o) o.style.display='none';
      }catch(_){}
    }
    window.addEventListener('keydown', function(e){
      try{
        var t = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
        if(t==='input' || t==='textarea' || t==='select' || (e.target && e.target.isContentEditable)) return;

        // A-H
        if(/^[a-h]$/i.test(e.key)){
          buf = e.key.toUpperCase();
          var o=document.getElementById('kbdOverlay');
          if(o){ o.textContent = '入力: ' + buf + ' _'; o.style.display='inline-block'; }
          e.preventDefault(); e.stopPropagation(); if(e.stopImmediatePropagation) e.stopImmediatePropagation();
          return;
        }
        // 1-8
        if(/^[1-8]$/.test(e.key) && buf){
          var coord = buf + e.key;
          var o=document.getElementById('kbdOverlay'); if(o){ o.textContent = '入力: ' + coord; }
          var cell = document.querySelector('.cell[data-coord="'+coord+'"]');
          setTimeout(resetBuf, 600);
          if(cell){
            e.preventDefault(); e.stopPropagation(); if(e.stopImmediatePropagation) e.stopImmediatePropagation();
            cell.click();
          }
          return;
        }
        if(e.key==='Escape'){ resetBuf(); return; }
        if(e.key==='Backspace'){ resetBuf(); return; }
      }catch(_){}
    }, true); // capture to run before bubble handlers
  })();
})();
</script>
