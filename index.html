<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover"
  />
  <title>Othello Trainer (PWA)</title>

  <!-- PWA -->
  <link rel="manifest" href="./manifest.webmanifest">
  <meta name="theme-color" content="#0b3d2e">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">

  <style>
    /* レイアウトの基礎 */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: #0a0a0a;
      color: #111;
      -webkit-tap-highlight-color: transparent;
    }
    /* 100vh のモバイル問題対策（アドレスバーの出入りでのズレ） */
    :root { --vh: 1vh; }
    .app {
      height: calc(var(--vh, 1vh) * 100);
      width: 100%;
      display: flex;
      flex-direction: column;
    }
    /* アプリ本体は iframe で読み込み（同一オリジン前提） */
    #appFrame {
      flex: 1 1 auto;
      width: 100%;
      border: 0;
      display: block;
      background: #111;
    }

    /* タッチで押しやすい基準ボタン */
    .touch-btn {
      font: inherit;
      line-height: 1;
      min-height: 44px;          /* タップ領域基準 */
      padding: 10px 14px;
      border-radius: 8px;
      border: 1px solid #ccc;
      background: #fff;
      cursor: pointer;
      touch-action: manipulation; /* 300ms 遅延回避 */
      user-select: none;
      -webkit-user-select: none;
    }

    /* スマホ用に iframe 内へ挿入するナビボタンの見た目を統一 */
    .ot-nav-inline {
      display: inline-flex;
      gap: 8px;
      margin-right: 8px;
      vertical-align: middle;
    }
    .ot-nav-inline .nav-btn {
      font-size: 16px;
      min-width: 44px;
      justify-content: center;
      align-items: center;
    }

    /* フォールバックのフローティングバー（PNGボタンが見つからない場合） */
    .fallback-bar {
      position: fixed;
      left: 0; right: 0; bottom: env(safe-area-inset-bottom, 0);
      display: none; /* 使う時だけ表示 */
      gap: 12px;
      padding: 12px 16px calc(12px + env(safe-area-inset-bottom, 0));
      background: rgba(20,20,20,.9);
      backdrop-filter: blur(10px);
      justify-content: center;
      z-index: 9999;
    }
    .fallback-bar .touch-btn {
      background: #f7f7f7;
    }
  </style>
</head>
<body>
  <noscript>このアプリを利用するには JavaScript を有効にしてください。</noscript>

  <div class="app">
    <!-- 既存のアプリ本体を読み込む。ファイル名は必要に応じて調整OK -->
    <iframe id="appFrame"
            title="Othello Trainer"
            src="./othello_trainer_v23_20251025.html"
            tabindex="0"
            allow="clipboard-write">
    </iframe>
  </div>

  <!-- PNGボタンが見つからない場合のフォールバック（スマホだけ表示） -->
  <div id="fallbackBar" class="fallback-bar" aria-hidden="true">
    <button type="button" class="touch-btn" id="fbPrevBtn" aria-label="前へ">◀</button>
    <button type="button" class="touch-btn" id="fbNextBtn" aria-label="次へ">▶</button>
  </div>

  <script>
    // 100vh 調整
    function setVh() {
      document.documentElement.style.setProperty('--vh', (window.innerHeight * 0.01) + 'px');
    }
    setVh();
    window.addEventListener('resize', setVh);

    // SW 登録（相対パス・サブディレクトリ運用も可）
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js', { scope: './' }).catch(console.error);
      });
    }

    // 端末種別（スマホ）判定：coarse ポインタ＆hoverなし
    const isMobileLike = matchMedia('(hover: none) and (pointer: coarse)').matches;

    const frame = document.getElementById('appFrame');
    const fallbackBar = document.getElementById('fallbackBar');

    // 親→子（iframe）へキーボードイベントをフォワード
    function forwardKeyToIframe(e) {
      try {
        const w = frame.contentWindow;
        if (!w) return;

        // iframe 側へ同等の KeyboardEvent を投げる
        const init = {
          key: e.key, code: e.code, keyCode: e.keyCode, which: e.which,
          altKey: e.altKey, ctrlKey: e.ctrlKey, metaKey: e.metaKey, shiftKey: e.shiftKey,
          bubbles: true, cancelable: true
        };
        const ev = new KeyboardEvent('keydown', init);
        // keyCode/which を必要とする古い実装対策
        Object.defineProperty(ev, 'keyCode', {get: () => e.keyCode});
        Object.defineProperty(ev, 'which', {get: () => e.which});

        // フォーカスが無くても受け取れるように window へ
        w.dispatchEvent(ev);
      } catch (_) { /* noop */ }
    }

    // ハードウェアキーボードでの操作（スマホでもPCでも動作）
    window.addEventListener('keydown', forwardKeyToIframe);

    // スマホ時のみ：アプリ内部の「盤面をPNG保存」ボタンの左へ ◀ ▶ を差し込む
    frame.addEventListener('load', () => {
      // iframe をフォーカス（キーボード入力を取りやすく）
      try { frame.contentWindow.focus(); } catch (_) {}

      if (!isMobileLike) return; // スマホのみ

      const doc = frame.contentDocument || frame.contentWindow?.document;
      if (!doc) return;

      // 「盤面をPNG保存」ボタンを探す
      function findPngButton(d) {
        const candidates = d.querySelectorAll('button, input[type="button"], input[type="submit"], a[role="button"], .btn, [role="button"]');
        const targetWords = ['盤面をPNG保存', 'PNG保存', 'PNG', '盤面PNG'];
        for (const el of candidates) {
          const text = (el.innerText || el.value || '').trim();
          if (!text) continue;
          if (targetWords.some(w => text.includes(w))) return el;
        }
        return null;
      }

      // ←/→ と同等の処理を起動
      function triggerArrow(direction /* -1: left, +1: right */) {
        const key = direction < 0 ? 'ArrowLeft' : 'ArrowRight';
        const code = key;
        const keyCode = direction < 0 ? 37 : 39;

        const w = frame.contentWindow;
        const d = frame.contentDocument;

        // 1) KeyboardEvent（モダン実装向け）
        try {
          const ev = new KeyboardEvent('keydown', {
            key, code, keyCode, which: keyCode, bubbles: true, cancelable: true
          });
          Object.defineProperty(ev, 'keyCode', {get: () => keyCode});
          Object.defineProperty(ev, 'which', {get: () => keyCode});
          (d.activeElement || d.body).dispatchEvent(ev);
        } catch (_) {}

        // 2) 既知関数があれば直接呼ぶ（フォールバック）
        try {
          const wFuncsLeft  = ['goPrev','prev','onPrev','historyPrev','movePrev','stepPrev','arrowLeft'];
          const wFuncsRight = ['goNext','next','onNext','historyNext','moveNext','stepNext','arrowRight'];
          const list = direction < 0 ? wFuncsLeft : wFuncsRight;
          for (const name of list) {
            if (typeof w[name] === 'function') { w[name](); break; }
          }
        } catch (_) {}
      }

      // 挿入処理
      const pngBtn = findPngButton(doc);

      if (pngBtn && pngBtn.parentElement) {
        const wrap = doc.createElement('span');
        wrap.className = 'ot-nav-inline';
        const prevBtn = doc.createElement('button');
        prevBtn.type = 'button';
        prevBtn.className = 'touch-btn nav-btn';
        prevBtn.setAttribute('aria-label', '前へ');
        prevBtn.textContent = '◀';

        const nextBtn = doc.createElement('button');
        nextBtn.type = 'button';
        nextBtn.className = 'touch-btn nav-btn';
        nextBtn.setAttribute('aria-label', '次へ');
        nextBtn.textContent = '▶';

        // イベント（pointer / touch / click すべてOK）
        const handlerPrev = (e) => { e.preventDefault(); e.stopPropagation(); triggerArrow(-1); };
        const handlerNext = (e) => { e.preventDefault(); e.stopPropagation(); triggerArrow(+1); };

        ['pointerup','click','touchend'].forEach(t => {
          prevBtn.addEventListener(t, handlerPrev, {passive:false});
          nextBtn.addEventListener(t, handlerNext, {passive:false});
        });

        wrap.appendChild(prevBtn);
        wrap.appendChild(nextBtn);

        // PNGボタンの直前（=左側）に差し込む
        pngBtn.parentElement.insertBefore(wrap, pngBtn);
      } else {
        // PNGボタンが見つからない場合はフローティングのフォールバックバーを表示
        fallbackBar.style.display = 'flex';
        fallbackBar.setAttribute('aria-hidden', 'false');
        const fbPrev = document.getElementById('fbPrevBtn');
        const fbNext = document.getElementById('fbNextBtn');
        ['pointerup','click','touchend'].forEach(t => {
          fbPrev.addEventListener(t, (e) => { e.preventDefault(); triggerArrow(-1); }, {passive:false});
          fbNext.addEventListener(t, (e) => { e.preventDefault(); triggerArrow(+1); }, {passive:false});
        });
      }
    });
  </script>
</body>
</html>
